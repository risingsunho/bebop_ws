/*
    Copyright (C) 2014 Parrot SA

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:
    * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in
    the documentation and/or other materials provided with the
    distribution.
    * Neither the name of Parrot nor the names
    of its contributors may be used to endorse or promote products
    derived from this software without specific prior written
    permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
    OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
    OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.
*/
/********************************************
 *            AUTOGENERATED FILE            *
 *             DO NOT MODIFY IT             *
 *                                          *
 * To add new commands :                    *
 *  - Modify ../Xml/commands.xml file       *
 *  - Re-run generateCommandsList.py script *
 *                                          *
 ********************************************/
#include <config.h>
#include <stdio.h>
#include "ARCOMMANDS_ReadWrite.h"
#include <libARCommands/ARCOMMANDS_Types.h>
#include <libARCommands/ARCOMMANDS_Decoder.h>
#include <libARCommands/ARCOMMANDS_Ids.h>
#include <libARSAL/ARSAL_Mutex.h>

// ARCOMMANDS_Decoder_t structure definition
struct ARCOMMANDS_Decoder_t
{
    ARSAL_Mutex_t mutex;

    // Feature generic
    ARCOMMANDS_Decoder_GenericDefaultCallback_t GenericDefaultCallback;
    void *GenericDefaultCustom;

    // Feature ARDrone3
    ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCallback_t ARDrone3PilotingFlatTrimCallback;
    void *ARDrone3PilotingFlatTrimCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCallback_t ARDrone3PilotingTakeOffCallback;
    void *ARDrone3PilotingTakeOffCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCallback_t ARDrone3PilotingPCMDCallback;
    void *ARDrone3PilotingPCMDCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingLandingCallback_t ARDrone3PilotingLandingCallback;
    void *ARDrone3PilotingLandingCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCallback_t ARDrone3PilotingEmergencyCallback;
    void *ARDrone3PilotingEmergencyCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCallback_t ARDrone3PilotingNavigateHomeCallback;
    void *ARDrone3PilotingNavigateHomeCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCallback_t ARDrone3PilotingAutoTakeOffModeCallback;
    void *ARDrone3PilotingAutoTakeOffModeCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingMoveByCallback_t ARDrone3PilotingMoveByCallback;
    void *ARDrone3PilotingMoveByCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingUserTakeOffCallback_t ARDrone3PilotingUserTakeOffCallback;
    void *ARDrone3PilotingUserTakeOffCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingCircleCallback_t ARDrone3PilotingCircleCallback;
    void *ARDrone3PilotingCircleCustom;
    ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCallback_t ARDrone3AnimationsFlipCallback;
    void *ARDrone3AnimationsFlipCustom;
    ARCOMMANDS_Decoder_ARDrone3CameraOrientationCallback_t ARDrone3CameraOrientationCallback;
    void *ARDrone3CameraOrientationCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCallback_t ARDrone3MediaRecordPictureCallback;
    void *ARDrone3MediaRecordPictureCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCallback_t ARDrone3MediaRecordVideoCallback;
    void *ARDrone3MediaRecordVideoCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Callback_t ARDrone3MediaRecordPictureV2Callback;
    void *ARDrone3MediaRecordPictureV2Custom;
    ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Callback_t ARDrone3MediaRecordVideoV2Callback;
    void *ARDrone3MediaRecordVideoV2Custom;
    ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCallback_t ARDrone3NetworkWifiScanCallback;
    void *ARDrone3NetworkWifiScanCustom;
    ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCallback_t ARDrone3NetworkWifiAuthChannelCallback;
    void *ARDrone3NetworkWifiAuthChannelCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCallback_t ARDrone3PilotingSettingsMaxAltitudeCallback;
    void *ARDrone3PilotingSettingsMaxAltitudeCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCallback_t ARDrone3PilotingSettingsMaxTiltCallback;
    void *ARDrone3PilotingSettingsMaxTiltCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCallback_t ARDrone3PilotingSettingsAbsolutControlCallback;
    void *ARDrone3PilotingSettingsAbsolutControlCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCallback_t ARDrone3PilotingSettingsMaxDistanceCallback;
    void *ARDrone3PilotingSettingsMaxDistanceCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback_t ARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback;
    void *ARDrone3PilotingSettingsNoFlyOverMaxDistanceCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCallback_t ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCallback;
    void *ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCallback_t ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCallback;
    void *ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCallback_t ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCallback;
    void *ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCallback_t ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCallback;
    void *ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCallback_t ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCallback;
    void *ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsBankedTurnCallback_t ARDrone3PilotingSettingsBankedTurnCallback;
    void *ARDrone3PilotingSettingsBankedTurnCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMinAltitudeCallback_t ARDrone3PilotingSettingsMinAltitudeCallback;
    void *ARDrone3PilotingSettingsMinAltitudeCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingDirectionCallback_t ARDrone3PilotingSettingsCirclingDirectionCallback;
    void *ARDrone3PilotingSettingsCirclingDirectionCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingRadiusCallback_t ARDrone3PilotingSettingsCirclingRadiusCallback;
    void *ARDrone3PilotingSettingsCirclingRadiusCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingAltitudeCallback_t ARDrone3PilotingSettingsCirclingAltitudeCallback;
    void *ARDrone3PilotingSettingsCirclingAltitudeCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsPitchModeCallback_t ARDrone3PilotingSettingsPitchModeCallback;
    void *ARDrone3PilotingSettingsPitchModeCustom;
    ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCallback_t ARDrone3SpeedSettingsMaxVerticalSpeedCallback;
    void *ARDrone3SpeedSettingsMaxVerticalSpeedCustom;
    ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCallback_t ARDrone3SpeedSettingsMaxRotationSpeedCallback;
    void *ARDrone3SpeedSettingsMaxRotationSpeedCustom;
    ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCallback_t ARDrone3SpeedSettingsHullProtectionCallback;
    void *ARDrone3SpeedSettingsHullProtectionCustom;
    ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCallback_t ARDrone3SpeedSettingsOutdoorCallback;
    void *ARDrone3SpeedSettingsOutdoorCustom;
    ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCallback_t ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCallback;
    void *ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCustom;
    ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCallback_t ARDrone3NetworkSettingsWifiSelectionCallback;
    void *ARDrone3NetworkSettingsWifiSelectionCustom;
    ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSecurityCallback_t ARDrone3NetworkSettingsWifiSecurityCallback;
    void *ARDrone3NetworkSettingsWifiSecurityCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCallback_t ARDrone3PictureSettingsPictureFormatSelectionCallback;
    void *ARDrone3PictureSettingsPictureFormatSelectionCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback_t ARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback;
    void *ARDrone3PictureSettingsAutoWhiteBalanceSelectionCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCallback_t ARDrone3PictureSettingsExpositionSelectionCallback;
    void *ARDrone3PictureSettingsExpositionSelectionCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCallback_t ARDrone3PictureSettingsSaturationSelectionCallback;
    void *ARDrone3PictureSettingsSaturationSelectionCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCallback_t ARDrone3PictureSettingsTimelapseSelectionCallback;
    void *ARDrone3PictureSettingsTimelapseSelectionCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCallback_t ARDrone3PictureSettingsVideoAutorecordSelectionCallback;
    void *ARDrone3PictureSettingsVideoAutorecordSelectionCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoStabilizationModeCallback_t ARDrone3PictureSettingsVideoStabilizationModeCallback;
    void *ARDrone3PictureSettingsVideoStabilizationModeCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoRecordingModeCallback_t ARDrone3PictureSettingsVideoRecordingModeCallback;
    void *ARDrone3PictureSettingsVideoRecordingModeCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoFramerateCallback_t ARDrone3PictureSettingsVideoFramerateCallback;
    void *ARDrone3PictureSettingsVideoFramerateCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoResolutionsCallback_t ARDrone3PictureSettingsVideoResolutionsCallback;
    void *ARDrone3PictureSettingsVideoResolutionsCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCallback_t ARDrone3MediaStreamingVideoEnableCallback;
    void *ARDrone3MediaStreamingVideoEnableCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoStreamModeCallback_t ARDrone3MediaStreamingVideoStreamModeCallback;
    void *ARDrone3MediaStreamingVideoStreamModeCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCallback_t ARDrone3GPSSettingsSetHomeCallback;
    void *ARDrone3GPSSettingsSetHomeCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCallback_t ARDrone3GPSSettingsResetHomeCallback;
    void *ARDrone3GPSSettingsResetHomeCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCallback_t ARDrone3GPSSettingsSendControllerGPSCallback;
    void *ARDrone3GPSSettingsSendControllerGPSCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCallback_t ARDrone3GPSSettingsHomeTypeCallback;
    void *ARDrone3GPSSettingsHomeTypeCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCallback_t ARDrone3GPSSettingsReturnHomeDelayCallback;
    void *ARDrone3GPSSettingsReturnHomeDelayCustom;
    ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCallback_t ARDrone3AntiflickeringElectricFrequencyCallback;
    void *ARDrone3AntiflickeringElectricFrequencyCustom;
    ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCallback_t ARDrone3AntiflickeringSetModeCallback;
    void *ARDrone3AntiflickeringSetModeCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCallback_t ARDrone3MediaRecordStatePictureStateChangedCallback;
    void *ARDrone3MediaRecordStatePictureStateChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCallback_t ARDrone3MediaRecordStateVideoStateChangedCallback;
    void *ARDrone3MediaRecordStateVideoStateChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Callback_t ARDrone3MediaRecordStatePictureStateChangedV2Callback;
    void *ARDrone3MediaRecordStatePictureStateChangedV2Custom;
    ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Callback_t ARDrone3MediaRecordStateVideoStateChangedV2Callback;
    void *ARDrone3MediaRecordStateVideoStateChangedV2Custom;
    ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoResolutionStateCallback_t ARDrone3MediaRecordStateVideoResolutionStateCallback;
    void *ARDrone3MediaRecordStateVideoResolutionStateCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCallback_t ARDrone3MediaRecordEventPictureEventChangedCallback;
    void *ARDrone3MediaRecordEventPictureEventChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCallback_t ARDrone3MediaRecordEventVideoEventChangedCallback;
    void *ARDrone3MediaRecordEventVideoEventChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCallback_t ARDrone3PilotingStateFlatTrimChangedCallback;
    void *ARDrone3PilotingStateFlatTrimChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCallback_t ARDrone3PilotingStateFlyingStateChangedCallback;
    void *ARDrone3PilotingStateFlyingStateChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCallback_t ARDrone3PilotingStateAlertStateChangedCallback;
    void *ARDrone3PilotingStateAlertStateChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCallback_t ARDrone3PilotingStateNavigateHomeStateChangedCallback;
    void *ARDrone3PilotingStateNavigateHomeStateChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCallback_t ARDrone3PilotingStatePositionChangedCallback;
    void *ARDrone3PilotingStatePositionChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCallback_t ARDrone3PilotingStateSpeedChangedCallback;
    void *ARDrone3PilotingStateSpeedChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCallback_t ARDrone3PilotingStateAttitudeChangedCallback;
    void *ARDrone3PilotingStateAttitudeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCallback_t ARDrone3PilotingStateAutoTakeOffModeChangedCallback;
    void *ARDrone3PilotingStateAutoTakeOffModeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCallback_t ARDrone3PilotingStateAltitudeChangedCallback;
    void *ARDrone3PilotingStateAltitudeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingStateGpsLocationChangedCallback_t ARDrone3PilotingStateGpsLocationChangedCallback;
    void *ARDrone3PilotingStateGpsLocationChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingStateLandingStateChangedCallback_t ARDrone3PilotingStateLandingStateChangedCallback;
    void *ARDrone3PilotingStateLandingStateChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingEventMoveByEndCallback_t ARDrone3PilotingEventMoveByEndCallback;
    void *ARDrone3PilotingEventMoveByEndCustom;
    ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCallback_t ARDrone3NetworkStateWifiScanListChangedCallback;
    void *ARDrone3NetworkStateWifiScanListChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCallback_t ARDrone3NetworkStateAllWifiScanChangedCallback;
    void *ARDrone3NetworkStateAllWifiScanChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCallback_t ARDrone3NetworkStateWifiAuthChannelListChangedCallback;
    void *ARDrone3NetworkStateWifiAuthChannelListChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCallback_t ARDrone3NetworkStateAllWifiAuthChannelChangedCallback;
    void *ARDrone3NetworkStateAllWifiAuthChannelChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCallback_t ARDrone3PilotingSettingsStateMaxAltitudeChangedCallback;
    void *ARDrone3PilotingSettingsStateMaxAltitudeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCallback_t ARDrone3PilotingSettingsStateMaxTiltChangedCallback;
    void *ARDrone3PilotingSettingsStateMaxTiltChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCallback_t ARDrone3PilotingSettingsStateAbsolutControlChangedCallback;
    void *ARDrone3PilotingSettingsStateAbsolutControlChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCallback_t ARDrone3PilotingSettingsStateMaxDistanceChangedCallback;
    void *ARDrone3PilotingSettingsStateMaxDistanceChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback_t ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback;
    void *ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback_t ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback;
    void *ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback_t ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback;
    void *ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback_t ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback;
    void *ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback_t ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback;
    void *ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback_t ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback;
    void *ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateBankedTurnChangedCallback_t ARDrone3PilotingSettingsStateBankedTurnChangedCallback;
    void *ARDrone3PilotingSettingsStateBankedTurnChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMinAltitudeChangedCallback_t ARDrone3PilotingSettingsStateMinAltitudeChangedCallback;
    void *ARDrone3PilotingSettingsStateMinAltitudeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingDirectionChangedCallback_t ARDrone3PilotingSettingsStateCirclingDirectionChangedCallback;
    void *ARDrone3PilotingSettingsStateCirclingDirectionChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingRadiusChangedCallback_t ARDrone3PilotingSettingsStateCirclingRadiusChangedCallback;
    void *ARDrone3PilotingSettingsStateCirclingRadiusChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingAltitudeChangedCallback_t ARDrone3PilotingSettingsStateCirclingAltitudeChangedCallback;
    void *ARDrone3PilotingSettingsStateCirclingAltitudeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStatePitchModeChangedCallback_t ARDrone3PilotingSettingsStatePitchModeChangedCallback;
    void *ARDrone3PilotingSettingsStatePitchModeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback_t ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback;
    void *ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback_t ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback;
    void *ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCallback_t ARDrone3SpeedSettingsStateHullProtectionChangedCallback;
    void *ARDrone3SpeedSettingsStateHullProtectionChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCallback_t ARDrone3SpeedSettingsStateOutdoorChangedCallback;
    void *ARDrone3SpeedSettingsStateOutdoorChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback_t ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback;
    void *ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCallback_t ARDrone3NetworkSettingsStateWifiSelectionChangedCallback;
    void *ARDrone3NetworkSettingsStateWifiSelectionChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityChangedCallback_t ARDrone3NetworkSettingsStateWifiSecurityChangedCallback;
    void *ARDrone3NetworkSettingsStateWifiSecurityChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityCallback_t ARDrone3NetworkSettingsStateWifiSecurityCallback;
    void *ARDrone3NetworkSettingsStateWifiSecurityCustom;
    ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCallback_t ARDrone3SettingsStateProductMotorVersionListChangedCallback;
    void *ARDrone3SettingsStateProductMotorVersionListChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCallback_t ARDrone3SettingsStateProductGPSVersionChangedCallback;
    void *ARDrone3SettingsStateProductGPSVersionChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCallback_t ARDrone3SettingsStateMotorErrorStateChangedCallback;
    void *ARDrone3SettingsStateMotorErrorStateChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCallback_t ARDrone3SettingsStateMotorSoftwareVersionChangedCallback;
    void *ARDrone3SettingsStateMotorSoftwareVersionChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCallback_t ARDrone3SettingsStateMotorFlightsStatusChangedCallback;
    void *ARDrone3SettingsStateMotorFlightsStatusChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCallback_t ARDrone3SettingsStateMotorErrorLastErrorChangedCallback;
    void *ARDrone3SettingsStateMotorErrorLastErrorChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCallback_t ARDrone3SettingsStateP7IDCallback;
    void *ARDrone3SettingsStateP7IDCustom;
    ARCOMMANDS_Decoder_ARDrone3SettingsStateCPUIDCallback_t ARDrone3SettingsStateCPUIDCallback;
    void *ARDrone3SettingsStateCPUIDCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCallback_t ARDrone3PictureSettingsStatePictureFormatChangedCallback;
    void *ARDrone3PictureSettingsStatePictureFormatChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback_t ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback;
    void *ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCallback_t ARDrone3PictureSettingsStateExpositionChangedCallback;
    void *ARDrone3PictureSettingsStateExpositionChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCallback_t ARDrone3PictureSettingsStateSaturationChangedCallback;
    void *ARDrone3PictureSettingsStateSaturationChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCallback_t ARDrone3PictureSettingsStateTimelapseChangedCallback;
    void *ARDrone3PictureSettingsStateTimelapseChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCallback_t ARDrone3PictureSettingsStateVideoAutorecordChangedCallback;
    void *ARDrone3PictureSettingsStateVideoAutorecordChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoStabilizationModeChangedCallback_t ARDrone3PictureSettingsStateVideoStabilizationModeChangedCallback;
    void *ARDrone3PictureSettingsStateVideoStabilizationModeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoRecordingModeChangedCallback_t ARDrone3PictureSettingsStateVideoRecordingModeChangedCallback;
    void *ARDrone3PictureSettingsStateVideoRecordingModeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoFramerateChangedCallback_t ARDrone3PictureSettingsStateVideoFramerateChangedCallback;
    void *ARDrone3PictureSettingsStateVideoFramerateChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoResolutionsChangedCallback_t ARDrone3PictureSettingsStateVideoResolutionsChangedCallback;
    void *ARDrone3PictureSettingsStateVideoResolutionsChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCallback_t ARDrone3MediaStreamingStateVideoEnableChangedCallback;
    void *ARDrone3MediaStreamingStateVideoEnableChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoStreamModeChangedCallback_t ARDrone3MediaStreamingStateVideoStreamModeChangedCallback;
    void *ARDrone3MediaStreamingStateVideoStreamModeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCallback_t ARDrone3GPSSettingsStateHomeChangedCallback;
    void *ARDrone3GPSSettingsStateHomeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCallback_t ARDrone3GPSSettingsStateResetHomeChangedCallback;
    void *ARDrone3GPSSettingsStateResetHomeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCallback_t ARDrone3GPSSettingsStateGPSFixStateChangedCallback;
    void *ARDrone3GPSSettingsStateGPSFixStateChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCallback_t ARDrone3GPSSettingsStateGPSUpdateStateChangedCallback;
    void *ARDrone3GPSSettingsStateGPSUpdateStateChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCallback_t ARDrone3GPSSettingsStateHomeTypeChangedCallback;
    void *ARDrone3GPSSettingsStateHomeTypeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCallback_t ARDrone3GPSSettingsStateReturnHomeDelayChangedCallback;
    void *ARDrone3GPSSettingsStateReturnHomeDelayChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCallback_t ARDrone3CameraStateOrientationCallback;
    void *ARDrone3CameraStateOrientationCustom;
    ARCOMMANDS_Decoder_ARDrone3CameraStateDefaultCameraOrientationCallback_t ARDrone3CameraStateDefaultCameraOrientationCallback;
    void *ARDrone3CameraStateDefaultCameraOrientationCustom;
    ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCallback_t ARDrone3AntiflickeringStateElectricFrequencyChangedCallback;
    void *ARDrone3AntiflickeringStateElectricFrequencyChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCallback_t ARDrone3AntiflickeringStateModeChangedCallback;
    void *ARDrone3AntiflickeringStateModeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCallback_t ARDrone3GPSStateNumberOfSatelliteChangedCallback;
    void *ARDrone3GPSStateNumberOfSatelliteChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCallback_t ARDrone3GPSStateHomeTypeAvailabilityChangedCallback;
    void *ARDrone3GPSStateHomeTypeAvailabilityChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCallback_t ARDrone3GPSStateHomeTypeChosenChangedCallback;
    void *ARDrone3GPSStateHomeTypeChosenChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCallback_t ARDrone3PROStateFeaturesCallback;
    void *ARDrone3PROStateFeaturesCustom;

    // Feature common
    ARCOMMANDS_Decoder_CommonNetworkDisconnectCallback_t CommonNetworkDisconnectCallback;
    void *CommonNetworkDisconnectCustom;
    ARCOMMANDS_Decoder_CommonSettingsAllSettingsCallback_t CommonSettingsAllSettingsCallback;
    void *CommonSettingsAllSettingsCustom;
    ARCOMMANDS_Decoder_CommonSettingsResetCallback_t CommonSettingsResetCallback;
    void *CommonSettingsResetCustom;
    ARCOMMANDS_Decoder_CommonSettingsProductNameCallback_t CommonSettingsProductNameCallback;
    void *CommonSettingsProductNameCustom;
    ARCOMMANDS_Decoder_CommonSettingsCountryCallback_t CommonSettingsCountryCallback;
    void *CommonSettingsCountryCustom;
    ARCOMMANDS_Decoder_CommonSettingsAutoCountryCallback_t CommonSettingsAutoCountryCallback;
    void *CommonSettingsAutoCountryCustom;
    ARCOMMANDS_Decoder_CommonCommonAllStatesCallback_t CommonCommonAllStatesCallback;
    void *CommonCommonAllStatesCustom;
    ARCOMMANDS_Decoder_CommonCommonCurrentDateCallback_t CommonCommonCurrentDateCallback;
    void *CommonCommonCurrentDateCustom;
    ARCOMMANDS_Decoder_CommonCommonCurrentTimeCallback_t CommonCommonCurrentTimeCallback;
    void *CommonCommonCurrentTimeCustom;
    ARCOMMANDS_Decoder_CommonCommonRebootCallback_t CommonCommonRebootCallback;
    void *CommonCommonRebootCustom;
    ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCallback_t CommonOverHeatSwitchOffCallback;
    void *CommonOverHeatSwitchOffCustom;
    ARCOMMANDS_Decoder_CommonOverHeatVentilateCallback_t CommonOverHeatVentilateCallback;
    void *CommonOverHeatVentilateCustom;
    ARCOMMANDS_Decoder_CommonControllerIsPilotingCallback_t CommonControllerIsPilotingCallback;
    void *CommonControllerIsPilotingCustom;
    ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCallback_t CommonWifiSettingsOutdoorSettingCallback;
    void *CommonWifiSettingsOutdoorSettingCustom;
    ARCOMMANDS_Decoder_CommonMavlinkStartCallback_t CommonMavlinkStartCallback;
    void *CommonMavlinkStartCustom;
    ARCOMMANDS_Decoder_CommonMavlinkPauseCallback_t CommonMavlinkPauseCallback;
    void *CommonMavlinkPauseCustom;
    ARCOMMANDS_Decoder_CommonMavlinkStopCallback_t CommonMavlinkStopCallback;
    void *CommonMavlinkStopCustom;
    ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCallback_t CommonCalibrationMagnetoCalibrationCallback;
    void *CommonCalibrationMagnetoCalibrationCustom;
    ARCOMMANDS_Decoder_CommonCalibrationPitotCalibrationCallback_t CommonCalibrationPitotCalibrationCallback;
    void *CommonCalibrationPitotCalibrationCustom;
    ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCallback_t CommonGPSControllerPositionForRunCallback;
    void *CommonGPSControllerPositionForRunCustom;
    ARCOMMANDS_Decoder_CommonAudioControllerReadyForStreamingCallback_t CommonAudioControllerReadyForStreamingCallback;
    void *CommonAudioControllerReadyForStreamingCustom;
    ARCOMMANDS_Decoder_CommonHeadlightsIntensityCallback_t CommonHeadlightsIntensityCallback;
    void *CommonHeadlightsIntensityCustom;
    ARCOMMANDS_Decoder_CommonAnimationsStartAnimationCallback_t CommonAnimationsStartAnimationCallback;
    void *CommonAnimationsStartAnimationCustom;
    ARCOMMANDS_Decoder_CommonAnimationsStopAnimationCallback_t CommonAnimationsStopAnimationCallback;
    void *CommonAnimationsStopAnimationCustom;
    ARCOMMANDS_Decoder_CommonAnimationsStopAllAnimationsCallback_t CommonAnimationsStopAllAnimationsCallback;
    void *CommonAnimationsStopAllAnimationsCustom;
    ARCOMMANDS_Decoder_CommonAccessoryConfigCallback_t CommonAccessoryConfigCallback;
    void *CommonAccessoryConfigCustom;
    ARCOMMANDS_Decoder_CommonChargerSetMaxChargeRateCallback_t CommonChargerSetMaxChargeRateCallback;
    void *CommonChargerSetMaxChargeRateCustom;
    ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCallback_t CommonNetworkEventDisconnectionCallback;
    void *CommonNetworkEventDisconnectionCustom;
    ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCallback_t CommonSettingsStateAllSettingsChangedCallback;
    void *CommonSettingsStateAllSettingsChangedCustom;
    ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCallback_t CommonSettingsStateResetChangedCallback;
    void *CommonSettingsStateResetChangedCustom;
    ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCallback_t CommonSettingsStateProductNameChangedCallback;
    void *CommonSettingsStateProductNameChangedCustom;
    ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCallback_t CommonSettingsStateProductVersionChangedCallback;
    void *CommonSettingsStateProductVersionChangedCustom;
    ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCallback_t CommonSettingsStateProductSerialHighChangedCallback;
    void *CommonSettingsStateProductSerialHighChangedCustom;
    ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCallback_t CommonSettingsStateProductSerialLowChangedCallback;
    void *CommonSettingsStateProductSerialLowChangedCustom;
    ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCallback_t CommonSettingsStateCountryChangedCallback;
    void *CommonSettingsStateCountryChangedCustom;
    ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCallback_t CommonSettingsStateAutoCountryChangedCallback;
    void *CommonSettingsStateAutoCountryChangedCustom;
    ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCallback_t CommonCommonStateAllStatesChangedCallback;
    void *CommonCommonStateAllStatesChangedCustom;
    ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCallback_t CommonCommonStateBatteryStateChangedCallback;
    void *CommonCommonStateBatteryStateChangedCustom;
    ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCallback_t CommonCommonStateMassStorageStateListChangedCallback;
    void *CommonCommonStateMassStorageStateListChangedCustom;
    ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCallback_t CommonCommonStateMassStorageInfoStateListChangedCallback;
    void *CommonCommonStateMassStorageInfoStateListChangedCustom;
    ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCallback_t CommonCommonStateCurrentDateChangedCallback;
    void *CommonCommonStateCurrentDateChangedCustom;
    ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCallback_t CommonCommonStateCurrentTimeChangedCallback;
    void *CommonCommonStateCurrentTimeChangedCustom;
    ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCallback_t CommonCommonStateMassStorageInfoRemainingListChangedCallback;
    void *CommonCommonStateMassStorageInfoRemainingListChangedCustom;
    ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCallback_t CommonCommonStateWifiSignalChangedCallback;
    void *CommonCommonStateWifiSignalChangedCustom;
    ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCallback_t CommonCommonStateSensorsStatesListChangedCallback;
    void *CommonCommonStateSensorsStatesListChangedCustom;
    ARCOMMANDS_Decoder_CommonCommonStateProductModelCallback_t CommonCommonStateProductModelCallback;
    void *CommonCommonStateProductModelCustom;
    ARCOMMANDS_Decoder_CommonCommonStateCountryListKnownCallback_t CommonCommonStateCountryListKnownCallback;
    void *CommonCommonStateCountryListKnownCustom;
    ARCOMMANDS_Decoder_CommonCommonStateDeprecatedMassStorageContentChangedCallback_t CommonCommonStateDeprecatedMassStorageContentChangedCallback;
    void *CommonCommonStateDeprecatedMassStorageContentChangedCustom;
    ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentCallback_t CommonCommonStateMassStorageContentCallback;
    void *CommonCommonStateMassStorageContentCustom;
    ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentForCurrentRunCallback_t CommonCommonStateMassStorageContentForCurrentRunCallback;
    void *CommonCommonStateMassStorageContentForCurrentRunCustom;
    ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCallback_t CommonOverHeatStateOverHeatChangedCallback;
    void *CommonOverHeatStateOverHeatChangedCustom;
    ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCallback_t CommonOverHeatStateOverHeatRegulationChangedCallback;
    void *CommonOverHeatStateOverHeatRegulationChangedCustom;
    ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCallback_t CommonWifiSettingsStateOutdoorSettingsChangedCallback;
    void *CommonWifiSettingsStateOutdoorSettingsChangedCustom;
    ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCallback_t CommonMavlinkStateMavlinkFilePlayingStateChangedCallback;
    void *CommonMavlinkStateMavlinkFilePlayingStateChangedCustom;
    ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCallback_t CommonMavlinkStateMavlinkPlayErrorStateChangedCallback;
    void *CommonMavlinkStateMavlinkPlayErrorStateChangedCustom;
    ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCallback_t CommonCalibrationStateMagnetoCalibrationStateChangedCallback;
    void *CommonCalibrationStateMagnetoCalibrationStateChangedCustom;
    ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCallback_t CommonCalibrationStateMagnetoCalibrationRequiredStateCallback;
    void *CommonCalibrationStateMagnetoCalibrationRequiredStateCustom;
    ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback_t CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback;
    void *CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCustom;
    ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCallback_t CommonCalibrationStateMagnetoCalibrationStartedChangedCallback;
    void *CommonCalibrationStateMagnetoCalibrationStartedChangedCustom;
    ARCOMMANDS_Decoder_CommonCalibrationStatePitotCalibrationStateChangedCallback_t CommonCalibrationStatePitotCalibrationStateChangedCallback;
    void *CommonCalibrationStatePitotCalibrationStateChangedCustom;
    ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCallback_t CommonCameraSettingsStateCameraSettingsChangedCallback;
    void *CommonCameraSettingsStateCameraSettingsChangedCustom;
    ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCallback_t CommonFlightPlanStateAvailabilityStateChangedCallback;
    void *CommonFlightPlanStateAvailabilityStateChangedCustom;
    ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCallback_t CommonFlightPlanStateComponentStateListChangedCallback;
    void *CommonFlightPlanStateComponentStateListChangedCustom;
    ARCOMMANDS_Decoder_CommonFlightPlanStateLockStateChangedCallback_t CommonFlightPlanStateLockStateChangedCallback;
    void *CommonFlightPlanStateLockStateChangedCustom;
    ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCallback_t CommonFlightPlanEventStartingErrorEventCallback;
    void *CommonFlightPlanEventStartingErrorEventCustom;
    ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCallback_t CommonFlightPlanEventSpeedBridleEventCallback;
    void *CommonFlightPlanEventSpeedBridleEventCustom;
    ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCallback_t CommonARLibsVersionsStateControllerLibARCommandsVersionCallback;
    void *CommonARLibsVersionsStateControllerLibARCommandsVersionCustom;
    ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback_t CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback;
    void *CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCustom;
    ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCallback_t CommonARLibsVersionsStateDeviceLibARCommandsVersionCallback;
    void *CommonARLibsVersionsStateDeviceLibARCommandsVersionCustom;
    ARCOMMANDS_Decoder_CommonAudioStateAudioStreamingRunningCallback_t CommonAudioStateAudioStreamingRunningCallback;
    void *CommonAudioStateAudioStreamingRunningCustom;
    ARCOMMANDS_Decoder_CommonHeadlightsStateIntensityChangedCallback_t CommonHeadlightsStateIntensityChangedCallback;
    void *CommonHeadlightsStateIntensityChangedCustom;
    ARCOMMANDS_Decoder_CommonAnimationsStateListCallback_t CommonAnimationsStateListCallback;
    void *CommonAnimationsStateListCustom;
    ARCOMMANDS_Decoder_CommonAccessoryStateSupportedAccessoriesListChangedCallback_t CommonAccessoryStateSupportedAccessoriesListChangedCallback;
    void *CommonAccessoryStateSupportedAccessoriesListChangedCustom;
    ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigChangedCallback_t CommonAccessoryStateAccessoryConfigChangedCallback;
    void *CommonAccessoryStateAccessoryConfigChangedCustom;
    ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigModificationEnabledCallback_t CommonAccessoryStateAccessoryConfigModificationEnabledCallback;
    void *CommonAccessoryStateAccessoryConfigModificationEnabledCustom;
    ARCOMMANDS_Decoder_CommonChargerStateMaxChargeRateChangedCallback_t CommonChargerStateMaxChargeRateChangedCallback;
    void *CommonChargerStateMaxChargeRateChangedCustom;
    ARCOMMANDS_Decoder_CommonChargerStateCurrentChargeStateChangedCallback_t CommonChargerStateCurrentChargeStateChangedCallback;
    void *CommonChargerStateCurrentChargeStateChangedCustom;
    ARCOMMANDS_Decoder_CommonChargerStateLastChargeRateChangedCallback_t CommonChargerStateLastChargeRateChangedCallback;
    void *CommonChargerStateLastChargeRateChangedCustom;
    ARCOMMANDS_Decoder_CommonChargerStateChargingInfoCallback_t CommonChargerStateChargingInfoCallback;
    void *CommonChargerStateChargingInfoCustom;
    ARCOMMANDS_Decoder_CommonRunStateRunIdChangedCallback_t CommonRunStateRunIdChangedCallback;
    void *CommonRunStateRunIdChangedCustom;

    // Feature controller_info
    ARCOMMANDS_Decoder_ControllerInfoGpsCallback_t ControllerInfoGpsCallback;
    void *ControllerInfoGpsCustom;
    ARCOMMANDS_Decoder_ControllerInfoBarometerCallback_t ControllerInfoBarometerCallback;
    void *ControllerInfoBarometerCustom;

    // Feature debug
    ARCOMMANDS_Decoder_DebugGetAllSettingsCallback_t DebugGetAllSettingsCallback;
    void *DebugGetAllSettingsCustom;
    ARCOMMANDS_Decoder_DebugSetSettingCallback_t DebugSetSettingCallback;
    void *DebugSetSettingCustom;
    ARCOMMANDS_Decoder_DebugSettingsInfoCallback_t DebugSettingsInfoCallback;
    void *DebugSettingsInfoCustom;
    ARCOMMANDS_Decoder_DebugSettingsListCallback_t DebugSettingsListCallback;
    void *DebugSettingsListCustom;

    // Feature drone_manager
    ARCOMMANDS_Decoder_DroneManagerDiscoverDronesCallback_t DroneManagerDiscoverDronesCallback;
    void *DroneManagerDiscoverDronesCustom;
    ARCOMMANDS_Decoder_DroneManagerConnectCallback_t DroneManagerConnectCallback;
    void *DroneManagerConnectCustom;
    ARCOMMANDS_Decoder_DroneManagerForgetCallback_t DroneManagerForgetCallback;
    void *DroneManagerForgetCustom;
    ARCOMMANDS_Decoder_DroneManagerDroneListItemCallback_t DroneManagerDroneListItemCallback;
    void *DroneManagerDroneListItemCustom;
    ARCOMMANDS_Decoder_DroneManagerConnectionStateCallback_t DroneManagerConnectionStateCallback;
    void *DroneManagerConnectionStateCustom;
    ARCOMMANDS_Decoder_DroneManagerAuthenticationFailedCallback_t DroneManagerAuthenticationFailedCallback;
    void *DroneManagerAuthenticationFailedCustom;
    ARCOMMANDS_Decoder_DroneManagerConnectionRefusedCallback_t DroneManagerConnectionRefusedCallback;
    void *DroneManagerConnectionRefusedCustom;

    // Feature JumpingSumo
    ARCOMMANDS_Decoder_JumpingSumoPilotingPCMDCallback_t JumpingSumoPilotingPCMDCallback;
    void *JumpingSumoPilotingPCMDCustom;
    ARCOMMANDS_Decoder_JumpingSumoPilotingPostureCallback_t JumpingSumoPilotingPostureCallback;
    void *JumpingSumoPilotingPostureCustom;
    ARCOMMANDS_Decoder_JumpingSumoPilotingAddCapOffsetCallback_t JumpingSumoPilotingAddCapOffsetCallback;
    void *JumpingSumoPilotingAddCapOffsetCustom;
    ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpStopCallback_t JumpingSumoAnimationsJumpStopCallback;
    void *JumpingSumoAnimationsJumpStopCustom;
    ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCancelCallback_t JumpingSumoAnimationsJumpCancelCallback;
    void *JumpingSumoAnimationsJumpCancelCustom;
    ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpLoadCallback_t JumpingSumoAnimationsJumpLoadCallback;
    void *JumpingSumoAnimationsJumpLoadCustom;
    ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCallback_t JumpingSumoAnimationsJumpCallback;
    void *JumpingSumoAnimationsJumpCustom;
    ARCOMMANDS_Decoder_JumpingSumoAnimationsSimpleAnimationCallback_t JumpingSumoAnimationsSimpleAnimationCallback;
    void *JumpingSumoAnimationsSimpleAnimationCustom;
    ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureCallback_t JumpingSumoMediaRecordPictureCallback;
    void *JumpingSumoMediaRecordPictureCustom;
    ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoCallback_t JumpingSumoMediaRecordVideoCallback;
    void *JumpingSumoMediaRecordVideoCustom;
    ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureV2Callback_t JumpingSumoMediaRecordPictureV2Callback;
    void *JumpingSumoMediaRecordPictureV2Custom;
    ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoV2Callback_t JumpingSumoMediaRecordVideoV2Callback;
    void *JumpingSumoMediaRecordVideoV2Custom;
    ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsWifiSelectionCallback_t JumpingSumoNetworkSettingsWifiSelectionCallback;
    void *JumpingSumoNetworkSettingsWifiSelectionCustom;
    ARCOMMANDS_Decoder_JumpingSumoNetworkWifiScanCallback_t JumpingSumoNetworkWifiScanCallback;
    void *JumpingSumoNetworkWifiScanCustom;
    ARCOMMANDS_Decoder_JumpingSumoNetworkWifiAuthChannelCallback_t JumpingSumoNetworkWifiAuthChannelCallback;
    void *JumpingSumoNetworkWifiAuthChannelCustom;
    ARCOMMANDS_Decoder_JumpingSumoAudioSettingsMasterVolumeCallback_t JumpingSumoAudioSettingsMasterVolumeCallback;
    void *JumpingSumoAudioSettingsMasterVolumeCustom;
    ARCOMMANDS_Decoder_JumpingSumoAudioSettingsThemeCallback_t JumpingSumoAudioSettingsThemeCallback;
    void *JumpingSumoAudioSettingsThemeCustom;
    ARCOMMANDS_Decoder_JumpingSumoRoadPlanAllScriptsMetadataCallback_t JumpingSumoRoadPlanAllScriptsMetadataCallback;
    void *JumpingSumoRoadPlanAllScriptsMetadataCustom;
    ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptUploadedCallback_t JumpingSumoRoadPlanScriptUploadedCallback;
    void *JumpingSumoRoadPlanScriptUploadedCustom;
    ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptDeleteCallback_t JumpingSumoRoadPlanScriptDeleteCallback;
    void *JumpingSumoRoadPlanScriptDeleteCustom;
    ARCOMMANDS_Decoder_JumpingSumoRoadPlanPlayScriptCallback_t JumpingSumoRoadPlanPlayScriptCallback;
    void *JumpingSumoRoadPlanPlayScriptCustom;
    ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsOutdoorCallback_t JumpingSumoSpeedSettingsOutdoorCallback;
    void *JumpingSumoSpeedSettingsOutdoorCustom;
    ARCOMMANDS_Decoder_JumpingSumoMediaStreamingVideoEnableCallback_t JumpingSumoMediaStreamingVideoEnableCallback;
    void *JumpingSumoMediaStreamingVideoEnableCustom;
    ARCOMMANDS_Decoder_JumpingSumoVideoSettingsAutorecordCallback_t JumpingSumoVideoSettingsAutorecordCallback;
    void *JumpingSumoVideoSettingsAutorecordCustom;
    ARCOMMANDS_Decoder_JumpingSumoPilotingStatePostureChangedCallback_t JumpingSumoPilotingStatePostureChangedCallback;
    void *JumpingSumoPilotingStatePostureChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoPilotingStateAlertStateChangedCallback_t JumpingSumoPilotingStateAlertStateChangedCallback;
    void *JumpingSumoPilotingStateAlertStateChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoPilotingStateSpeedChangedCallback_t JumpingSumoPilotingStateSpeedChangedCallback;
    void *JumpingSumoPilotingStateSpeedChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpLoadChangedCallback_t JumpingSumoAnimationsStateJumpLoadChangedCallback;
    void *JumpingSumoAnimationsStateJumpLoadChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpTypeChangedCallback_t JumpingSumoAnimationsStateJumpTypeChangedCallback;
    void *JumpingSumoAnimationsStateJumpTypeChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpMotorProblemChangedCallback_t JumpingSumoAnimationsStateJumpMotorProblemChangedCallback;
    void *JumpingSumoAnimationsStateJumpMotorProblemChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoSettingsStateProductGPSVersionChangedCallback_t JumpingSumoSettingsStateProductGPSVersionChangedCallback;
    void *JumpingSumoSettingsStateProductGPSVersionChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedCallback_t JumpingSumoMediaRecordStatePictureStateChangedCallback;
    void *JumpingSumoMediaRecordStatePictureStateChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedCallback_t JumpingSumoMediaRecordStateVideoStateChangedCallback;
    void *JumpingSumoMediaRecordStateVideoStateChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedV2Callback_t JumpingSumoMediaRecordStatePictureStateChangedV2Callback;
    void *JumpingSumoMediaRecordStatePictureStateChangedV2Custom;
    ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedV2Callback_t JumpingSumoMediaRecordStateVideoStateChangedV2Callback;
    void *JumpingSumoMediaRecordStateVideoStateChangedV2Custom;
    ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventPictureEventChangedCallback_t JumpingSumoMediaRecordEventPictureEventChangedCallback;
    void *JumpingSumoMediaRecordEventPictureEventChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventVideoEventChangedCallback_t JumpingSumoMediaRecordEventVideoEventChangedCallback;
    void *JumpingSumoMediaRecordEventVideoEventChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsStateWifiSelectionChangedCallback_t JumpingSumoNetworkSettingsStateWifiSelectionChangedCallback;
    void *JumpingSumoNetworkSettingsStateWifiSelectionChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiScanListChangedCallback_t JumpingSumoNetworkStateWifiScanListChangedCallback;
    void *JumpingSumoNetworkStateWifiScanListChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiScanChangedCallback_t JumpingSumoNetworkStateAllWifiScanChangedCallback;
    void *JumpingSumoNetworkStateAllWifiScanChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiAuthChannelListChangedCallback_t JumpingSumoNetworkStateWifiAuthChannelListChangedCallback;
    void *JumpingSumoNetworkStateWifiAuthChannelListChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiAuthChannelChangedCallback_t JumpingSumoNetworkStateAllWifiAuthChannelChangedCallback;
    void *JumpingSumoNetworkStateAllWifiAuthChannelChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoNetworkStateLinkQualityChangedCallback_t JumpingSumoNetworkStateLinkQualityChangedCallback;
    void *JumpingSumoNetworkStateLinkQualityChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateMasterVolumeChangedCallback_t JumpingSumoAudioSettingsStateMasterVolumeChangedCallback;
    void *JumpingSumoAudioSettingsStateMasterVolumeChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateThemeChangedCallback_t JumpingSumoAudioSettingsStateThemeChangedCallback;
    void *JumpingSumoAudioSettingsStateThemeChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptMetadataListChangedCallback_t JumpingSumoRoadPlanStateScriptMetadataListChangedCallback;
    void *JumpingSumoRoadPlanStateScriptMetadataListChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateAllScriptsMetadataChangedCallback_t JumpingSumoRoadPlanStateAllScriptsMetadataChangedCallback;
    void *JumpingSumoRoadPlanStateAllScriptsMetadataChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptUploadChangedCallback_t JumpingSumoRoadPlanStateScriptUploadChangedCallback;
    void *JumpingSumoRoadPlanStateScriptUploadChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptDeleteChangedCallback_t JumpingSumoRoadPlanStateScriptDeleteChangedCallback;
    void *JumpingSumoRoadPlanStateScriptDeleteChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoRoadPlanStatePlayScriptChangedCallback_t JumpingSumoRoadPlanStatePlayScriptChangedCallback;
    void *JumpingSumoRoadPlanStatePlayScriptChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsStateOutdoorChangedCallback_t JumpingSumoSpeedSettingsStateOutdoorChangedCallback;
    void *JumpingSumoSpeedSettingsStateOutdoorChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoMediaStreamingStateVideoEnableChangedCallback_t JumpingSumoMediaStreamingStateVideoEnableChangedCallback;
    void *JumpingSumoMediaStreamingStateVideoEnableChangedCustom;
    ARCOMMANDS_Decoder_JumpingSumoVideoSettingsStateAutorecordChangedCallback_t JumpingSumoVideoSettingsStateAutorecordChangedCallback;
    void *JumpingSumoVideoSettingsStateAutorecordChangedCustom;

    // Feature mapper
    ARCOMMANDS_Decoder_MapperGrabCallback_t MapperGrabCallback;
    void *MapperGrabCustom;
    ARCOMMANDS_Decoder_MapperMapButtonActionCallback_t MapperMapButtonActionCallback;
    void *MapperMapButtonActionCustom;
    ARCOMMANDS_Decoder_MapperMapAxisActionCallback_t MapperMapAxisActionCallback;
    void *MapperMapAxisActionCustom;
    ARCOMMANDS_Decoder_MapperResetMappingCallback_t MapperResetMappingCallback;
    void *MapperResetMappingCustom;
    ARCOMMANDS_Decoder_MapperSetExpoCallback_t MapperSetExpoCallback;
    void *MapperSetExpoCustom;
    ARCOMMANDS_Decoder_MapperSetInvertedCallback_t MapperSetInvertedCallback;
    void *MapperSetInvertedCustom;
    ARCOMMANDS_Decoder_MapperGrabStateCallback_t MapperGrabStateCallback;
    void *MapperGrabStateCustom;
    ARCOMMANDS_Decoder_MapperGrabButtonEventCallback_t MapperGrabButtonEventCallback;
    void *MapperGrabButtonEventCustom;
    ARCOMMANDS_Decoder_MapperGrabAxisEventCallback_t MapperGrabAxisEventCallback;
    void *MapperGrabAxisEventCustom;
    ARCOMMANDS_Decoder_MapperButtonMappingItemCallback_t MapperButtonMappingItemCallback;
    void *MapperButtonMappingItemCustom;
    ARCOMMANDS_Decoder_MapperAxisMappingItemCallback_t MapperAxisMappingItemCallback;
    void *MapperAxisMappingItemCustom;
    ARCOMMANDS_Decoder_MapperApplicationAxisEventCallback_t MapperApplicationAxisEventCallback;
    void *MapperApplicationAxisEventCustom;
    ARCOMMANDS_Decoder_MapperApplicationButtonEventCallback_t MapperApplicationButtonEventCallback;
    void *MapperApplicationButtonEventCustom;
    ARCOMMANDS_Decoder_MapperExpoMapItemCallback_t MapperExpoMapItemCallback;
    void *MapperExpoMapItemCustom;
    ARCOMMANDS_Decoder_MapperInvertedMapItemCallback_t MapperInvertedMapItemCallback;
    void *MapperInvertedMapItemCustom;

    // Feature MiniDrone
    ARCOMMANDS_Decoder_MiniDronePilotingFlatTrimCallback_t MiniDronePilotingFlatTrimCallback;
    void *MiniDronePilotingFlatTrimCustom;
    ARCOMMANDS_Decoder_MiniDronePilotingTakeOffCallback_t MiniDronePilotingTakeOffCallback;
    void *MiniDronePilotingTakeOffCustom;
    ARCOMMANDS_Decoder_MiniDronePilotingPCMDCallback_t MiniDronePilotingPCMDCallback;
    void *MiniDronePilotingPCMDCustom;
    ARCOMMANDS_Decoder_MiniDronePilotingLandingCallback_t MiniDronePilotingLandingCallback;
    void *MiniDronePilotingLandingCustom;
    ARCOMMANDS_Decoder_MiniDronePilotingEmergencyCallback_t MiniDronePilotingEmergencyCallback;
    void *MiniDronePilotingEmergencyCustom;
    ARCOMMANDS_Decoder_MiniDronePilotingAutoTakeOffModeCallback_t MiniDronePilotingAutoTakeOffModeCallback;
    void *MiniDronePilotingAutoTakeOffModeCustom;
    ARCOMMANDS_Decoder_MiniDronePilotingFlyingModeCallback_t MiniDronePilotingFlyingModeCallback;
    void *MiniDronePilotingFlyingModeCustom;
    ARCOMMANDS_Decoder_MiniDronePilotingPlaneGearBoxCallback_t MiniDronePilotingPlaneGearBoxCallback;
    void *MiniDronePilotingPlaneGearBoxCustom;
    ARCOMMANDS_Decoder_MiniDroneAnimationsFlipCallback_t MiniDroneAnimationsFlipCallback;
    void *MiniDroneAnimationsFlipCustom;
    ARCOMMANDS_Decoder_MiniDroneAnimationsCapCallback_t MiniDroneAnimationsCapCallback;
    void *MiniDroneAnimationsCapCustom;
    ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureCallback_t MiniDroneMediaRecordPictureCallback;
    void *MiniDroneMediaRecordPictureCustom;
    ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureV2Callback_t MiniDroneMediaRecordPictureV2Callback;
    void *MiniDroneMediaRecordPictureV2Custom;
    ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxAltitudeCallback_t MiniDronePilotingSettingsMaxAltitudeCallback;
    void *MiniDronePilotingSettingsMaxAltitudeCustom;
    ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxTiltCallback_t MiniDronePilotingSettingsMaxTiltCallback;
    void *MiniDronePilotingSettingsMaxTiltCustom;
    ARCOMMANDS_Decoder_MiniDronePilotingSettingsPlaneModePitchCallback_t MiniDronePilotingSettingsPlaneModePitchCallback;
    void *MiniDronePilotingSettingsPlaneModePitchCustom;
    ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxVerticalSpeedCallback_t MiniDroneSpeedSettingsMaxVerticalSpeedCallback;
    void *MiniDroneSpeedSettingsMaxVerticalSpeedCustom;
    ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxRotationSpeedCallback_t MiniDroneSpeedSettingsMaxRotationSpeedCallback;
    void *MiniDroneSpeedSettingsMaxRotationSpeedCustom;
    ARCOMMANDS_Decoder_MiniDroneSpeedSettingsWheelsCallback_t MiniDroneSpeedSettingsWheelsCallback;
    void *MiniDroneSpeedSettingsWheelsCustom;
    ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxHorizontalSpeedCallback_t MiniDroneSpeedSettingsMaxHorizontalSpeedCallback;
    void *MiniDroneSpeedSettingsMaxHorizontalSpeedCustom;
    ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxPlaneModeRotationSpeedCallback_t MiniDroneSpeedSettingsMaxPlaneModeRotationSpeedCallback;
    void *MiniDroneSpeedSettingsMaxPlaneModeRotationSpeedCustom;
    ARCOMMANDS_Decoder_MiniDroneSettingsCutOutModeCallback_t MiniDroneSettingsCutOutModeCallback;
    void *MiniDroneSettingsCutOutModeCustom;
    ARCOMMANDS_Decoder_MiniDroneGPSControllerLatitudeForRunCallback_t MiniDroneGPSControllerLatitudeForRunCallback;
    void *MiniDroneGPSControllerLatitudeForRunCustom;
    ARCOMMANDS_Decoder_MiniDroneGPSControllerLongitudeForRunCallback_t MiniDroneGPSControllerLongitudeForRunCallback;
    void *MiniDroneGPSControllerLongitudeForRunCustom;
    ARCOMMANDS_Decoder_MiniDroneConfigurationControllerTypeCallback_t MiniDroneConfigurationControllerTypeCallback;
    void *MiniDroneConfigurationControllerTypeCustom;
    ARCOMMANDS_Decoder_MiniDroneConfigurationControllerNameCallback_t MiniDroneConfigurationControllerNameCallback;
    void *MiniDroneConfigurationControllerNameCustom;
    ARCOMMANDS_Decoder_MiniDroneUsbAccessoryLightControlCallback_t MiniDroneUsbAccessoryLightControlCallback;
    void *MiniDroneUsbAccessoryLightControlCustom;
    ARCOMMANDS_Decoder_MiniDroneUsbAccessoryClawControlCallback_t MiniDroneUsbAccessoryClawControlCallback;
    void *MiniDroneUsbAccessoryClawControlCustom;
    ARCOMMANDS_Decoder_MiniDroneUsbAccessoryGunControlCallback_t MiniDroneUsbAccessoryGunControlCallback;
    void *MiniDroneUsbAccessoryGunControlCustom;
    ARCOMMANDS_Decoder_MiniDroneRemoteControllerSetPairedRemoteCallback_t MiniDroneRemoteControllerSetPairedRemoteCallback;
    void *MiniDroneRemoteControllerSetPairedRemoteCustom;
    ARCOMMANDS_Decoder_MiniDronePilotingStateFlatTrimChangedCallback_t MiniDronePilotingStateFlatTrimChangedCallback;
    void *MiniDronePilotingStateFlatTrimChangedCustom;
    ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingStateChangedCallback_t MiniDronePilotingStateFlyingStateChangedCallback;
    void *MiniDronePilotingStateFlyingStateChangedCustom;
    ARCOMMANDS_Decoder_MiniDronePilotingStateAlertStateChangedCallback_t MiniDronePilotingStateAlertStateChangedCallback;
    void *MiniDronePilotingStateAlertStateChangedCustom;
    ARCOMMANDS_Decoder_MiniDronePilotingStateAutoTakeOffModeChangedCallback_t MiniDronePilotingStateAutoTakeOffModeChangedCallback;
    void *MiniDronePilotingStateAutoTakeOffModeChangedCustom;
    ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingModeChangedCallback_t MiniDronePilotingStateFlyingModeChangedCallback;
    void *MiniDronePilotingStateFlyingModeChangedCustom;
    ARCOMMANDS_Decoder_MiniDronePilotingStatePlaneGearBoxChangedCallback_t MiniDronePilotingStatePlaneGearBoxChangedCallback;
    void *MiniDronePilotingStatePlaneGearBoxChangedCustom;
    ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedCallback_t MiniDroneMediaRecordStatePictureStateChangedCallback;
    void *MiniDroneMediaRecordStatePictureStateChangedCustom;
    ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedV2Callback_t MiniDroneMediaRecordStatePictureStateChangedV2Callback;
    void *MiniDroneMediaRecordStatePictureStateChangedV2Custom;
    ARCOMMANDS_Decoder_MiniDroneMediaRecordEventPictureEventChangedCallback_t MiniDroneMediaRecordEventPictureEventChangedCallback;
    void *MiniDroneMediaRecordEventPictureEventChangedCustom;
    ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxAltitudeChangedCallback_t MiniDronePilotingSettingsStateMaxAltitudeChangedCallback;
    void *MiniDronePilotingSettingsStateMaxAltitudeChangedCustom;
    ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxTiltChangedCallback_t MiniDronePilotingSettingsStateMaxTiltChangedCallback;
    void *MiniDronePilotingSettingsStateMaxTiltChangedCustom;
    ARCOMMANDS_Decoder_MiniDronePilotingSettingsStatePlaneModePitchChangedCallback_t MiniDronePilotingSettingsStatePlaneModePitchChangedCallback;
    void *MiniDronePilotingSettingsStatePlaneModePitchChangedCustom;
    ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCallback_t MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCallback;
    void *MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCustom;
    ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCallback_t MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCallback;
    void *MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCustom;
    ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateWheelsChangedCallback_t MiniDroneSpeedSettingsStateWheelsChangedCallback;
    void *MiniDroneSpeedSettingsStateWheelsChangedCustom;
    ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCallback_t MiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCallback;
    void *MiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCustom;
    ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCallback_t MiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCallback;
    void *MiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCustom;
    ARCOMMANDS_Decoder_MiniDroneSettingsStateProductMotorsVersionChangedCallback_t MiniDroneSettingsStateProductMotorsVersionChangedCallback;
    void *MiniDroneSettingsStateProductMotorsVersionChangedCustom;
    ARCOMMANDS_Decoder_MiniDroneSettingsStateProductInertialVersionChangedCallback_t MiniDroneSettingsStateProductInertialVersionChangedCallback;
    void *MiniDroneSettingsStateProductInertialVersionChangedCustom;
    ARCOMMANDS_Decoder_MiniDroneSettingsStateCutOutModeChangedCallback_t MiniDroneSettingsStateCutOutModeChangedCallback;
    void *MiniDroneSettingsStateCutOutModeChangedCustom;
    ARCOMMANDS_Decoder_MiniDroneFloodControlStateFloodControlChangedCallback_t MiniDroneFloodControlStateFloodControlChangedCallback;
    void *MiniDroneFloodControlStateFloodControlChangedCustom;
    ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateLightStateCallback_t MiniDroneUsbAccessoryStateLightStateCallback;
    void *MiniDroneUsbAccessoryStateLightStateCustom;
    ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateClawStateCallback_t MiniDroneUsbAccessoryStateClawStateCallback;
    void *MiniDroneUsbAccessoryStateClawStateCustom;
    ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateGunStateCallback_t MiniDroneUsbAccessoryStateGunStateCallback;
    void *MiniDroneUsbAccessoryStateGunStateCustom;
    ARCOMMANDS_Decoder_MiniDroneNavigationDataStateDronePositionCallback_t MiniDroneNavigationDataStateDronePositionCallback;
    void *MiniDroneNavigationDataStateDronePositionCustom;

    // Feature powerup
    ARCOMMANDS_Decoder_PowerupPilotingPCMDCallback_t PowerupPilotingPCMDCallback;
    void *PowerupPilotingPCMDCustom;
    ARCOMMANDS_Decoder_PowerupPilotingUserTakeOffCallback_t PowerupPilotingUserTakeOffCallback;
    void *PowerupPilotingUserTakeOffCustom;
    ARCOMMANDS_Decoder_PowerupPilotingMotorModeCallback_t PowerupPilotingMotorModeCallback;
    void *PowerupPilotingMotorModeCustom;
    ARCOMMANDS_Decoder_PowerupPilotingSettingsSetCallback_t PowerupPilotingSettingsSetCallback;
    void *PowerupPilotingSettingsSetCustom;
    ARCOMMANDS_Decoder_PowerupMediaRecordPictureV2Callback_t PowerupMediaRecordPictureV2Callback;
    void *PowerupMediaRecordPictureV2Custom;
    ARCOMMANDS_Decoder_PowerupMediaRecordVideoV2Callback_t PowerupMediaRecordVideoV2Callback;
    void *PowerupMediaRecordVideoV2Custom;
    ARCOMMANDS_Decoder_PowerupNetworkSettingsWifiSelectionCallback_t PowerupNetworkSettingsWifiSelectionCallback;
    void *PowerupNetworkSettingsWifiSelectionCustom;
    ARCOMMANDS_Decoder_PowerupNetworkWifiScanCallback_t PowerupNetworkWifiScanCallback;
    void *PowerupNetworkWifiScanCustom;
    ARCOMMANDS_Decoder_PowerupNetworkWifiAuthChannelCallback_t PowerupNetworkWifiAuthChannelCallback;
    void *PowerupNetworkWifiAuthChannelCustom;
    ARCOMMANDS_Decoder_PowerupMediaStreamingVideoEnableCallback_t PowerupMediaStreamingVideoEnableCallback;
    void *PowerupMediaStreamingVideoEnableCustom;
    ARCOMMANDS_Decoder_PowerupVideoSettingsAutorecordCallback_t PowerupVideoSettingsAutorecordCallback;
    void *PowerupVideoSettingsAutorecordCustom;
    ARCOMMANDS_Decoder_PowerupVideoSettingsVideoModeCallback_t PowerupVideoSettingsVideoModeCallback;
    void *PowerupVideoSettingsVideoModeCustom;
    ARCOMMANDS_Decoder_PowerupSoundsBuzzCallback_t PowerupSoundsBuzzCallback;
    void *PowerupSoundsBuzzCustom;
    ARCOMMANDS_Decoder_PowerupPilotingStateAlertStateChangedCallback_t PowerupPilotingStateAlertStateChangedCallback;
    void *PowerupPilotingStateAlertStateChangedCustom;
    ARCOMMANDS_Decoder_PowerupPilotingStateFlyingStateChangedCallback_t PowerupPilotingStateFlyingStateChangedCallback;
    void *PowerupPilotingStateFlyingStateChangedCustom;
    ARCOMMANDS_Decoder_PowerupPilotingStateMotorModeChangedCallback_t PowerupPilotingStateMotorModeChangedCallback;
    void *PowerupPilotingStateMotorModeChangedCustom;
    ARCOMMANDS_Decoder_PowerupPilotingStateAttitudeChangedCallback_t PowerupPilotingStateAttitudeChangedCallback;
    void *PowerupPilotingStateAttitudeChangedCustom;
    ARCOMMANDS_Decoder_PowerupPilotingStateAltitudeChangedCallback_t PowerupPilotingStateAltitudeChangedCallback;
    void *PowerupPilotingStateAltitudeChangedCustom;
    ARCOMMANDS_Decoder_PowerupPilotingSettingsStateSettingChangedCallback_t PowerupPilotingSettingsStateSettingChangedCallback;
    void *PowerupPilotingSettingsStateSettingChangedCustom;
    ARCOMMANDS_Decoder_PowerupMediaRecordStatePictureStateChangedV2Callback_t PowerupMediaRecordStatePictureStateChangedV2Callback;
    void *PowerupMediaRecordStatePictureStateChangedV2Custom;
    ARCOMMANDS_Decoder_PowerupMediaRecordStateVideoStateChangedV2Callback_t PowerupMediaRecordStateVideoStateChangedV2Callback;
    void *PowerupMediaRecordStateVideoStateChangedV2Custom;
    ARCOMMANDS_Decoder_PowerupMediaRecordEventPictureEventChangedCallback_t PowerupMediaRecordEventPictureEventChangedCallback;
    void *PowerupMediaRecordEventPictureEventChangedCustom;
    ARCOMMANDS_Decoder_PowerupMediaRecordEventVideoEventChangedCallback_t PowerupMediaRecordEventVideoEventChangedCallback;
    void *PowerupMediaRecordEventVideoEventChangedCustom;
    ARCOMMANDS_Decoder_PowerupNetworkSettingsStateWifiSelectionChangedCallback_t PowerupNetworkSettingsStateWifiSelectionChangedCallback;
    void *PowerupNetworkSettingsStateWifiSelectionChangedCustom;
    ARCOMMANDS_Decoder_PowerupNetworkStateWifiScanListChangedCallback_t PowerupNetworkStateWifiScanListChangedCallback;
    void *PowerupNetworkStateWifiScanListChangedCustom;
    ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiScanChangedCallback_t PowerupNetworkStateAllWifiScanChangedCallback;
    void *PowerupNetworkStateAllWifiScanChangedCustom;
    ARCOMMANDS_Decoder_PowerupNetworkStateWifiAuthChannelListChangedCallback_t PowerupNetworkStateWifiAuthChannelListChangedCallback;
    void *PowerupNetworkStateWifiAuthChannelListChangedCustom;
    ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiAuthChannelChangedCallback_t PowerupNetworkStateAllWifiAuthChannelChangedCallback;
    void *PowerupNetworkStateAllWifiAuthChannelChangedCustom;
    ARCOMMANDS_Decoder_PowerupNetworkStateLinkQualityChangedCallback_t PowerupNetworkStateLinkQualityChangedCallback;
    void *PowerupNetworkStateLinkQualityChangedCustom;
    ARCOMMANDS_Decoder_PowerupMediaStreamingStateVideoEnableChangedCallback_t PowerupMediaStreamingStateVideoEnableChangedCallback;
    void *PowerupMediaStreamingStateVideoEnableChangedCustom;
    ARCOMMANDS_Decoder_PowerupVideoSettingsStateAutorecordChangedCallback_t PowerupVideoSettingsStateAutorecordChangedCallback;
    void *PowerupVideoSettingsStateAutorecordChangedCustom;
    ARCOMMANDS_Decoder_PowerupVideoSettingsStateVideoModeChangedCallback_t PowerupVideoSettingsStateVideoModeChangedCallback;
    void *PowerupVideoSettingsStateVideoModeChangedCustom;
    ARCOMMANDS_Decoder_PowerupSoundsStateBuzzChangedCallback_t PowerupSoundsStateBuzzChangedCallback;
    void *PowerupSoundsStateBuzzChangedCustom;

    // Feature pro
    ARCOMMANDS_Decoder_ProProBoughtFeaturesCallback_t ProProBoughtFeaturesCallback;
    void *ProProBoughtFeaturesCustom;
    ARCOMMANDS_Decoder_ProProResponseCallback_t ProProResponseCallback;
    void *ProProResponseCustom;
    ARCOMMANDS_Decoder_ProProActivateFeaturesCallback_t ProProActivateFeaturesCallback;
    void *ProProActivateFeaturesCustom;
    ARCOMMANDS_Decoder_ProProStateSupportedFeaturesCallback_t ProProStateSupportedFeaturesCallback;
    void *ProProStateSupportedFeaturesCustom;
    ARCOMMANDS_Decoder_ProProStateFeaturesActivatedCallback_t ProProStateFeaturesActivatedCallback;
    void *ProProStateFeaturesActivatedCustom;
    ARCOMMANDS_Decoder_ProProEventChallengeEventCallback_t ProProEventChallengeEventCallback;
    void *ProProEventChallengeEventCustom;

    // Feature rc
    ARCOMMANDS_Decoder_RcMonitorChannelsCallback_t RcMonitorChannelsCallback;
    void *RcMonitorChannelsCustom;
    ARCOMMANDS_Decoder_RcStartCalibrationCallback_t RcStartCalibrationCallback;
    void *RcStartCalibrationCustom;
    ARCOMMANDS_Decoder_RcInvertChannelCallback_t RcInvertChannelCallback;
    void *RcInvertChannelCustom;
    ARCOMMANDS_Decoder_RcAbortCalibrationCallback_t RcAbortCalibrationCallback;
    void *RcAbortCalibrationCustom;
    ARCOMMANDS_Decoder_RcResetCalibrationCallback_t RcResetCalibrationCallback;
    void *RcResetCalibrationCustom;
    ARCOMMANDS_Decoder_RcReceiverStateCallback_t RcReceiverStateCallback;
    void *RcReceiverStateCustom;
    ARCOMMANDS_Decoder_RcChannelsMonitorStateCallback_t RcChannelsMonitorStateCallback;
    void *RcChannelsMonitorStateCustom;
    ARCOMMANDS_Decoder_RcChannelValueCallback_t RcChannelValueCallback;
    void *RcChannelValueCustom;
    ARCOMMANDS_Decoder_RcCalibrationStateCallback_t RcCalibrationStateCallback;
    void *RcCalibrationStateCustom;
    ARCOMMANDS_Decoder_RcReceiverQualityCallback_t RcReceiverQualityCallback;
    void *RcReceiverQualityCustom;

    // Feature SkyController
    ARCOMMANDS_Decoder_SkyControllerWifiRequestWifiListCallback_t SkyControllerWifiRequestWifiListCallback;
    void *SkyControllerWifiRequestWifiListCustom;
    ARCOMMANDS_Decoder_SkyControllerWifiRequestCurrentWifiCallback_t SkyControllerWifiRequestCurrentWifiCallback;
    void *SkyControllerWifiRequestCurrentWifiCustom;
    ARCOMMANDS_Decoder_SkyControllerWifiConnectToWifiCallback_t SkyControllerWifiConnectToWifiCallback;
    void *SkyControllerWifiConnectToWifiCustom;
    ARCOMMANDS_Decoder_SkyControllerWifiForgetWifiCallback_t SkyControllerWifiForgetWifiCallback;
    void *SkyControllerWifiForgetWifiCustom;
    ARCOMMANDS_Decoder_SkyControllerWifiWifiAuthChannelCallback_t SkyControllerWifiWifiAuthChannelCallback;
    void *SkyControllerWifiWifiAuthChannelCustom;
    ARCOMMANDS_Decoder_SkyControllerDeviceRequestDeviceListCallback_t SkyControllerDeviceRequestDeviceListCallback;
    void *SkyControllerDeviceRequestDeviceListCustom;
    ARCOMMANDS_Decoder_SkyControllerDeviceRequestCurrentDeviceCallback_t SkyControllerDeviceRequestCurrentDeviceCallback;
    void *SkyControllerDeviceRequestCurrentDeviceCustom;
    ARCOMMANDS_Decoder_SkyControllerDeviceConnectToDeviceCallback_t SkyControllerDeviceConnectToDeviceCallback;
    void *SkyControllerDeviceConnectToDeviceCustom;
    ARCOMMANDS_Decoder_SkyControllerSettingsAllSettingsCallback_t SkyControllerSettingsAllSettingsCallback;
    void *SkyControllerSettingsAllSettingsCustom;
    ARCOMMANDS_Decoder_SkyControllerSettingsResetCallback_t SkyControllerSettingsResetCallback;
    void *SkyControllerSettingsResetCustom;
    ARCOMMANDS_Decoder_SkyControllerCommonAllStatesCallback_t SkyControllerCommonAllStatesCallback;
    void *SkyControllerCommonAllStatesCustom;
    ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointSSIDCallback_t SkyControllerAccessPointSettingsAccessPointSSIDCallback;
    void *SkyControllerAccessPointSettingsAccessPointSSIDCustom;
    ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointChannelCallback_t SkyControllerAccessPointSettingsAccessPointChannelCallback;
    void *SkyControllerAccessPointSettingsAccessPointChannelCustom;
    ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsWifiSelectionCallback_t SkyControllerAccessPointSettingsWifiSelectionCallback;
    void *SkyControllerAccessPointSettingsWifiSelectionCustom;
    ARCOMMANDS_Decoder_SkyControllerCameraResetOrientationCallback_t SkyControllerCameraResetOrientationCallback;
    void *SkyControllerCameraResetOrientationCustom;
    ARCOMMANDS_Decoder_SkyControllerGamepadInfosGetGamepadControlsCallback_t SkyControllerGamepadInfosGetGamepadControlsCallback;
    void *SkyControllerGamepadInfosGetGamepadControlsCustom;
    ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetCurrentButtonMappingsCallback_t SkyControllerButtonMappingsGetCurrentButtonMappingsCallback;
    void *SkyControllerButtonMappingsGetCurrentButtonMappingsCustom;
    ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetAvailableButtonMappingsCallback_t SkyControllerButtonMappingsGetAvailableButtonMappingsCallback;
    void *SkyControllerButtonMappingsGetAvailableButtonMappingsCustom;
    ARCOMMANDS_Decoder_SkyControllerButtonMappingsSetButtonMappingCallback_t SkyControllerButtonMappingsSetButtonMappingCallback;
    void *SkyControllerButtonMappingsSetButtonMappingCustom;
    ARCOMMANDS_Decoder_SkyControllerButtonMappingsDefaultButtonMappingCallback_t SkyControllerButtonMappingsDefaultButtonMappingCallback;
    void *SkyControllerButtonMappingsDefaultButtonMappingCustom;
    ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetCurrentAxisMappingsCallback_t SkyControllerAxisMappingsGetCurrentAxisMappingsCallback;
    void *SkyControllerAxisMappingsGetCurrentAxisMappingsCustom;
    ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetAvailableAxisMappingsCallback_t SkyControllerAxisMappingsGetAvailableAxisMappingsCallback;
    void *SkyControllerAxisMappingsGetAvailableAxisMappingsCustom;
    ARCOMMANDS_Decoder_SkyControllerAxisMappingsSetAxisMappingCallback_t SkyControllerAxisMappingsSetAxisMappingCallback;
    void *SkyControllerAxisMappingsSetAxisMappingCustom;
    ARCOMMANDS_Decoder_SkyControllerAxisMappingsDefaultAxisMappingCallback_t SkyControllerAxisMappingsDefaultAxisMappingCallback;
    void *SkyControllerAxisMappingsDefaultAxisMappingCustom;
    ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetCurrentAxisFiltersCallback_t SkyControllerAxisFiltersGetCurrentAxisFiltersCallback;
    void *SkyControllerAxisFiltersGetCurrentAxisFiltersCustom;
    ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetPresetAxisFiltersCallback_t SkyControllerAxisFiltersGetPresetAxisFiltersCallback;
    void *SkyControllerAxisFiltersGetPresetAxisFiltersCustom;
    ARCOMMANDS_Decoder_SkyControllerAxisFiltersSetAxisFilterCallback_t SkyControllerAxisFiltersSetAxisFilterCallback;
    void *SkyControllerAxisFiltersSetAxisFilterCustom;
    ARCOMMANDS_Decoder_SkyControllerAxisFiltersDefaultAxisFiltersCallback_t SkyControllerAxisFiltersDefaultAxisFiltersCallback;
    void *SkyControllerAxisFiltersDefaultAxisFiltersCustom;
    ARCOMMANDS_Decoder_SkyControllerCoPilotingSetPilotingSourceCallback_t SkyControllerCoPilotingSetPilotingSourceCallback;
    void *SkyControllerCoPilotingSetPilotingSourceCustom;
    ARCOMMANDS_Decoder_SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCallback_t SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCallback;
    void *SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCustom;
    ARCOMMANDS_Decoder_SkyControllerFactoryResetCallback_t SkyControllerFactoryResetCallback;
    void *SkyControllerFactoryResetCustom;
    ARCOMMANDS_Decoder_SkyControllerWifiStateWifiListCallback_t SkyControllerWifiStateWifiListCallback;
    void *SkyControllerWifiStateWifiListCustom;
    ARCOMMANDS_Decoder_SkyControllerWifiStateConnexionChangedCallback_t SkyControllerWifiStateConnexionChangedCallback;
    void *SkyControllerWifiStateConnexionChangedCustom;
    ARCOMMANDS_Decoder_SkyControllerWifiStateWifiAuthChannelListChangedCallback_t SkyControllerWifiStateWifiAuthChannelListChangedCallback;
    void *SkyControllerWifiStateWifiAuthChannelListChangedCustom;
    ARCOMMANDS_Decoder_SkyControllerWifiStateAllWifiAuthChannelChangedCallback_t SkyControllerWifiStateAllWifiAuthChannelChangedCallback;
    void *SkyControllerWifiStateAllWifiAuthChannelChangedCustom;
    ARCOMMANDS_Decoder_SkyControllerWifiStateWifiSignalChangedCallback_t SkyControllerWifiStateWifiSignalChangedCallback;
    void *SkyControllerWifiStateWifiSignalChangedCustom;
    ARCOMMANDS_Decoder_SkyControllerDeviceStateDeviceListCallback_t SkyControllerDeviceStateDeviceListCallback;
    void *SkyControllerDeviceStateDeviceListCustom;
    ARCOMMANDS_Decoder_SkyControllerDeviceStateConnexionChangedCallback_t SkyControllerDeviceStateConnexionChangedCallback;
    void *SkyControllerDeviceStateConnexionChangedCustom;
    ARCOMMANDS_Decoder_SkyControllerSettingsStateAllSettingsChangedCallback_t SkyControllerSettingsStateAllSettingsChangedCallback;
    void *SkyControllerSettingsStateAllSettingsChangedCustom;
    ARCOMMANDS_Decoder_SkyControllerSettingsStateResetChangedCallback_t SkyControllerSettingsStateResetChangedCallback;
    void *SkyControllerSettingsStateResetChangedCustom;
    ARCOMMANDS_Decoder_SkyControllerSettingsStateProductSerialChangedCallback_t SkyControllerSettingsStateProductSerialChangedCallback;
    void *SkyControllerSettingsStateProductSerialChangedCustom;
    ARCOMMANDS_Decoder_SkyControllerSettingsStateProductVariantChangedCallback_t SkyControllerSettingsStateProductVariantChangedCallback;
    void *SkyControllerSettingsStateProductVariantChangedCustom;
    ARCOMMANDS_Decoder_SkyControllerSettingsStateProductVersionChangedCallback_t SkyControllerSettingsStateProductVersionChangedCallback;
    void *SkyControllerSettingsStateProductVersionChangedCustom;
    ARCOMMANDS_Decoder_SkyControllerCommonStateAllStatesChangedCallback_t SkyControllerCommonStateAllStatesChangedCallback;
    void *SkyControllerCommonStateAllStatesChangedCustom;
    ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryChangedCallback_t SkyControllerSkyControllerStateBatteryChangedCallback;
    void *SkyControllerSkyControllerStateBatteryChangedCustom;
    ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsFixChangedCallback_t SkyControllerSkyControllerStateGpsFixChangedCallback;
    void *SkyControllerSkyControllerStateGpsFixChangedCustom;
    ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsPositionChangedCallback_t SkyControllerSkyControllerStateGpsPositionChangedCallback;
    void *SkyControllerSkyControllerStateGpsPositionChangedCustom;
    ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryStateCallback_t SkyControllerSkyControllerStateBatteryStateCallback;
    void *SkyControllerSkyControllerStateBatteryStateCustom;
    ARCOMMANDS_Decoder_SkyControllerSkyControllerStateAttitudeChangedCallback_t SkyControllerSkyControllerStateAttitudeChangedCallback;
    void *SkyControllerSkyControllerStateAttitudeChangedCustom;
    ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCallback_t SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCallback;
    void *SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCustom;
    ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointChannelChangedCallback_t SkyControllerAccessPointSettingsStateAccessPointChannelChangedCallback;
    void *SkyControllerAccessPointSettingsStateAccessPointChannelChangedCustom;
    ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateWifiSelectionChangedCallback_t SkyControllerAccessPointSettingsStateWifiSelectionChangedCallback;
    void *SkyControllerAccessPointSettingsStateWifiSelectionChangedCustom;
    ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateGamepadControlCallback_t SkyControllerGamepadInfosStateGamepadControlCallback;
    void *SkyControllerGamepadInfosStateGamepadControlCustom;
    ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateAllGamepadControlsSentCallback_t SkyControllerGamepadInfosStateAllGamepadControlsSentCallback;
    void *SkyControllerGamepadInfosStateAllGamepadControlsSentCustom;
    ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateCurrentButtonMappingsCallback_t SkyControllerButtonMappingsStateCurrentButtonMappingsCallback;
    void *SkyControllerButtonMappingsStateCurrentButtonMappingsCustom;
    ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCallback_t SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCallback;
    void *SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCustom;
    ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAvailableButtonMappingsCallback_t SkyControllerButtonMappingsStateAvailableButtonMappingsCallback;
    void *SkyControllerButtonMappingsStateAvailableButtonMappingsCustom;
    ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCallback_t SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCallback;
    void *SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCustom;
    ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateCurrentAxisMappingsCallback_t SkyControllerAxisMappingsStateCurrentAxisMappingsCallback;
    void *SkyControllerAxisMappingsStateCurrentAxisMappingsCustom;
    ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCallback_t SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCallback;
    void *SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCustom;
    ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAvailableAxisMappingsCallback_t SkyControllerAxisMappingsStateAvailableAxisMappingsCallback;
    void *SkyControllerAxisMappingsStateAvailableAxisMappingsCustom;
    ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCallback_t SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCallback;
    void *SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCustom;
    ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateCurrentAxisFiltersCallback_t SkyControllerAxisFiltersStateCurrentAxisFiltersCallback;
    void *SkyControllerAxisFiltersStateCurrentAxisFiltersCustom;
    ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllCurrentFiltersSentCallback_t SkyControllerAxisFiltersStateAllCurrentFiltersSentCallback;
    void *SkyControllerAxisFiltersStateAllCurrentFiltersSentCustom;
    ARCOMMANDS_Decoder_SkyControllerAxisFiltersStatePresetAxisFiltersCallback_t SkyControllerAxisFiltersStatePresetAxisFiltersCallback;
    void *SkyControllerAxisFiltersStatePresetAxisFiltersCustom;
    ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllPresetFiltersSentCallback_t SkyControllerAxisFiltersStateAllPresetFiltersSentCallback;
    void *SkyControllerAxisFiltersStateAllPresetFiltersSentCustom;
    ARCOMMANDS_Decoder_SkyControllerCoPilotingStatePilotingSourceCallback_t SkyControllerCoPilotingStatePilotingSourceCallback;
    void *SkyControllerCoPilotingStatePilotingSourceCustom;
    ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationStateCallback_t SkyControllerCalibrationStateMagnetoCalibrationStateCallback;
    void *SkyControllerCalibrationStateMagnetoCalibrationStateCustom;
    ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCallback_t SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCallback;
    void *SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCustom;
    ARCOMMANDS_Decoder_SkyControllerButtonEventsSettingsCallback_t SkyControllerButtonEventsSettingsCallback;
    void *SkyControllerButtonEventsSettingsCustom;

    // Feature unknown_feature_1
    ARCOMMANDS_Decoder_UnknownFeature1GeographicRunCallback_t UnknownFeature1GeographicRunCallback;
    void *UnknownFeature1GeographicRunCustom;
    ARCOMMANDS_Decoder_UnknownFeature1RelativeRunCallback_t UnknownFeature1RelativeRunCallback;
    void *UnknownFeature1RelativeRunCustom;
    ARCOMMANDS_Decoder_UnknownFeature1LookAtRunCallback_t UnknownFeature1LookAtRunCallback;
    void *UnknownFeature1LookAtRunCustom;
    ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimRunCallback_t UnknownFeature1SpiralAnimRunCallback;
    void *UnknownFeature1SpiralAnimRunCustom;
    ARCOMMANDS_Decoder_UnknownFeature1SwingAnimRunCallback_t UnknownFeature1SwingAnimRunCallback;
    void *UnknownFeature1SwingAnimRunCustom;
    ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimRunCallback_t UnknownFeature1BoomerangAnimRunCallback;
    void *UnknownFeature1BoomerangAnimRunCustom;
    ARCOMMANDS_Decoder_UnknownFeature1CandleAnimRunCallback_t UnknownFeature1CandleAnimRunCallback;
    void *UnknownFeature1CandleAnimRunCustom;
    ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimRunCallback_t UnknownFeature1DollySlideAnimRunCallback;
    void *UnknownFeature1DollySlideAnimRunCustom;
    ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionCallback_t UnknownFeature1UserFramingPositionCallback;
    void *UnknownFeature1UserFramingPositionCustom;
    ARCOMMANDS_Decoder_UnknownFeature1UserGPSDataCallback_t UnknownFeature1UserGPSDataCallback;
    void *UnknownFeature1UserGPSDataCustom;
    ARCOMMANDS_Decoder_UnknownFeature1UserBaroDataCallback_t UnknownFeature1UserBaroDataCallback;
    void *UnknownFeature1UserBaroDataCustom;
    ARCOMMANDS_Decoder_UnknownFeature1LynxDetectionCallback_t UnknownFeature1LynxDetectionCallback;
    void *UnknownFeature1LynxDetectionCustom;
    ARCOMMANDS_Decoder_UnknownFeature1AvailabilityCallback_t UnknownFeature1AvailabilityCallback;
    void *UnknownFeature1AvailabilityCustom;
    ARCOMMANDS_Decoder_UnknownFeature1RunCallback_t UnknownFeature1RunCallback;
    void *UnknownFeature1RunCustom;
    ARCOMMANDS_Decoder_UnknownFeature1GeographicConfigChangedCallback_t UnknownFeature1GeographicConfigChangedCallback;
    void *UnknownFeature1GeographicConfigChangedCustom;
    ARCOMMANDS_Decoder_UnknownFeature1RelativeConfigChangedCallback_t UnknownFeature1RelativeConfigChangedCallback;
    void *UnknownFeature1RelativeConfigChangedCustom;
    ARCOMMANDS_Decoder_UnknownFeature1AnimRunCallback_t UnknownFeature1AnimRunCallback;
    void *UnknownFeature1AnimRunCustom;
    ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimConfigChangedCallback_t UnknownFeature1SpiralAnimConfigChangedCallback;
    void *UnknownFeature1SpiralAnimConfigChangedCustom;
    ARCOMMANDS_Decoder_UnknownFeature1SwingAnimConfigChangedCallback_t UnknownFeature1SwingAnimConfigChangedCallback;
    void *UnknownFeature1SwingAnimConfigChangedCustom;
    ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimConfigChangedCallback_t UnknownFeature1BoomerangAnimConfigChangedCallback;
    void *UnknownFeature1BoomerangAnimConfigChangedCustom;
    ARCOMMANDS_Decoder_UnknownFeature1CandleAnimConfigChangedCallback_t UnknownFeature1CandleAnimConfigChangedCallback;
    void *UnknownFeature1CandleAnimConfigChangedCustom;
    ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimConfigChangedCallback_t UnknownFeature1DollySlideAnimConfigChangedCallback;
    void *UnknownFeature1DollySlideAnimConfigChangedCustom;
    ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionChangedCallback_t UnknownFeature1UserFramingPositionChangedCallback;
    void *UnknownFeature1UserFramingPositionChangedCustom;

    // Feature wifi
    ARCOMMANDS_Decoder_WifiScanCallback_t WifiScanCallback;
    void *WifiScanCustom;
    ARCOMMANDS_Decoder_WifiUpdateAuthorizedChannelsCallback_t WifiUpdateAuthorizedChannelsCallback;
    void *WifiUpdateAuthorizedChannelsCustom;
    ARCOMMANDS_Decoder_WifiSetApChannelCallback_t WifiSetApChannelCallback;
    void *WifiSetApChannelCustom;
    ARCOMMANDS_Decoder_WifiSetSecurityCallback_t WifiSetSecurityCallback;
    void *WifiSetSecurityCustom;
    ARCOMMANDS_Decoder_WifiSetCountryCallback_t WifiSetCountryCallback;
    void *WifiSetCountryCustom;
    ARCOMMANDS_Decoder_WifiSetEnvironmentCallback_t WifiSetEnvironmentCallback;
    void *WifiSetEnvironmentCustom;
    ARCOMMANDS_Decoder_WifiScannedItemCallback_t WifiScannedItemCallback;
    void *WifiScannedItemCustom;
    ARCOMMANDS_Decoder_WifiAuthorizedChannelCallback_t WifiAuthorizedChannelCallback;
    void *WifiAuthorizedChannelCustom;
    ARCOMMANDS_Decoder_WifiApChannelChangedCallback_t WifiApChannelChangedCallback;
    void *WifiApChannelChangedCustom;
    ARCOMMANDS_Decoder_WifiSecurityChangedCallback_t WifiSecurityChangedCallback;
    void *WifiSecurityChangedCustom;
    ARCOMMANDS_Decoder_WifiCountryChangedCallback_t WifiCountryChangedCallback;
    void *WifiCountryChangedCustom;
    ARCOMMANDS_Decoder_WifiEnvironmentChangedCallback_t WifiEnvironmentChangedCallback;
    void *WifiEnvironmentChangedCustom;
    ARCOMMANDS_Decoder_WifiRssiChangedCallback_t WifiRssiChangedCallback;
    void *WifiRssiChangedCustom;

};


// Constructor
ARCOMMANDS_Decoder_t* ARCOMMANDS_Decoder_NewDecoder (eARCOMMANDS_DECODER_ERROR *error)
{
    ARCOMMANDS_Decoder_t *decoder = NULL;

    decoder = calloc(1, sizeof(*decoder));
    if (decoder)
        ARSAL_Mutex_Init (&decoder->mutex);

    if (error)
        *error = decoder ? ARCOMMANDS_DECODER_OK : ARCOMMANDS_DECODER_ERROR;

    return decoder;
}

// Destructor
void ARCOMMANDS_Decoder_DeleteDecoder (ARCOMMANDS_Decoder_t **decoder)
{
    if (decoder && (*decoder)) {
        ARSAL_Mutex_Destroy(&(*decoder)->mutex);
        free(*decoder);
        *decoder = NULL;
    }
}

// CALLBACK VARIABLES + SETTERS

static ARSAL_Mutex_t ARCOMMANDS_Decoder_Mutex;
static int ARCOMMANDS_Decoder_IsInit = 0;
static int ARCOMMANDS_Decoder_Init (void)
{
    if ((ARCOMMANDS_Decoder_IsInit == 0) &&
        (ARSAL_Mutex_Init (&ARCOMMANDS_Decoder_Mutex) == 0))
    {
        ARCOMMANDS_Decoder_IsInit = 1;
    } // No else --> Do nothing if already initialized
    return ARCOMMANDS_Decoder_IsInit;
}

// Feature generic

void ARCOMMANDS_Decoder_SetGenericDefaultCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_GenericDefaultCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->GenericDefaultCallback = callback;
    decoder->GenericDefaultCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_GenericDefaultCallback_t ARCOMMANDS_Decoder_GenericDefaultCb = NULL;
static void *ARCOMMANDS_Decoder_GenericDefaultCustom = NULL;
void ARCOMMANDS_Decoder_SetGenericDefaultCallback (ARCOMMANDS_Decoder_GenericDefaultCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_GenericDefaultCb = callback;
        ARCOMMANDS_Decoder_GenericDefaultCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature ARDrone3

void ARCOMMANDS_Decoder_SetARDrone3PilotingFlatTrimCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingFlatTrimCallback = callback;
    decoder->ARDrone3PilotingFlatTrimCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingFlatTrimCallback (ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingTakeOffCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingTakeOffCallback = callback;
    decoder->ARDrone3PilotingTakeOffCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingTakeOffCallback (ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingPCMDCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingPCMDCallback = callback;
    decoder->ARDrone3PilotingPCMDCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingPCMDCallback (ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingLandingCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingLandingCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingLandingCallback = callback;
    decoder->ARDrone3PilotingLandingCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingLandingCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingLandingCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingLandingCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingLandingCallback (ARCOMMANDS_Decoder_ARDrone3PilotingLandingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingLandingCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingLandingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingEmergencyCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingEmergencyCallback = callback;
    decoder->ARDrone3PilotingEmergencyCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingEmergencyCallback (ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingNavigateHomeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingNavigateHomeCallback = callback;
    decoder->ARDrone3PilotingNavigateHomeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingNavigateHomeCallback (ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingAutoTakeOffModeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingAutoTakeOffModeCallback = callback;
    decoder->ARDrone3PilotingAutoTakeOffModeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingAutoTakeOffModeCallback (ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingMoveByCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingMoveByCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingMoveByCallback = callback;
    decoder->ARDrone3PilotingMoveByCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingMoveByCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingMoveByCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingMoveByCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingMoveByCallback (ARCOMMANDS_Decoder_ARDrone3PilotingMoveByCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingMoveByCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingMoveByCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingUserTakeOffCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingUserTakeOffCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingUserTakeOffCallback = callback;
    decoder->ARDrone3PilotingUserTakeOffCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingUserTakeOffCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingUserTakeOffCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingUserTakeOffCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingUserTakeOffCallback (ARCOMMANDS_Decoder_ARDrone3PilotingUserTakeOffCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingUserTakeOffCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingUserTakeOffCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingCircleCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingCircleCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingCircleCallback = callback;
    decoder->ARDrone3PilotingCircleCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingCircleCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingCircleCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingCircleCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingCircleCallback (ARCOMMANDS_Decoder_ARDrone3PilotingCircleCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingCircleCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingCircleCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3AnimationsFlipCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3AnimationsFlipCallback = callback;
    decoder->ARDrone3AnimationsFlipCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCallback_t ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3AnimationsFlipCallback (ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCb = callback;
        ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3CameraOrientationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3CameraOrientationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3CameraOrientationCallback = callback;
    decoder->ARDrone3CameraOrientationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3CameraOrientationCallback_t ARCOMMANDS_Decoder_ARDrone3CameraOrientationCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3CameraOrientationCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3CameraOrientationCallback (ARCOMMANDS_Decoder_ARDrone3CameraOrientationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3CameraOrientationCb = callback;
        ARCOMMANDS_Decoder_ARDrone3CameraOrientationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordPictureCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaRecordPictureCallback = callback;
    decoder->ARDrone3MediaRecordPictureCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCallback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordPictureCallback (ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordVideoCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaRecordVideoCallback = callback;
    decoder->ARDrone3MediaRecordVideoCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCallback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordVideoCallback (ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordPictureV2Cb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Callback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaRecordPictureV2Callback = callback;
    decoder->ARDrone3MediaRecordPictureV2Custom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Callback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Cb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Custom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordPictureV2Callback (ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Cb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordVideoV2Cb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Callback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaRecordVideoV2Callback = callback;
    decoder->ARDrone3MediaRecordVideoV2Custom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Callback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Cb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Custom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordVideoV2Callback (ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Cb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3NetworkWifiScanCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3NetworkWifiScanCallback = callback;
    decoder->ARDrone3NetworkWifiScanCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkWifiScanCallback (ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3NetworkWifiAuthChannelCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3NetworkWifiAuthChannelCallback = callback;
    decoder->ARDrone3NetworkWifiAuthChannelCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkWifiAuthChannelCallback (ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsMaxAltitudeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsMaxAltitudeCallback = callback;
    decoder->ARDrone3PilotingSettingsMaxAltitudeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsMaxAltitudeCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsMaxTiltCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsMaxTiltCallback = callback;
    decoder->ARDrone3PilotingSettingsMaxTiltCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsMaxTiltCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsAbsolutControlCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsAbsolutControlCallback = callback;
    decoder->ARDrone3PilotingSettingsAbsolutControlCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsAbsolutControlCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsMaxDistanceCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsMaxDistanceCallback = callback;
    decoder->ARDrone3PilotingSettingsMaxDistanceCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsMaxDistanceCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsNoFlyOverMaxDistanceCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback = callback;
    decoder->ARDrone3PilotingSettingsNoFlyOverMaxDistanceCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCallback = callback;
    decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCallback = callback;
    decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCallback = callback;
    decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCallback = callback;
    decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCallback = callback;
    decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsBankedTurnCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsBankedTurnCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsBankedTurnCallback = callback;
    decoder->ARDrone3PilotingSettingsBankedTurnCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsBankedTurnCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsBankedTurnCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsBankedTurnCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsBankedTurnCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsBankedTurnCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsBankedTurnCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsBankedTurnCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsMinAltitudeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMinAltitudeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsMinAltitudeCallback = callback;
    decoder->ARDrone3PilotingSettingsMinAltitudeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMinAltitudeCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMinAltitudeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMinAltitudeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsMinAltitudeCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMinAltitudeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMinAltitudeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMinAltitudeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsCirclingDirectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingDirectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsCirclingDirectionCallback = callback;
    decoder->ARDrone3PilotingSettingsCirclingDirectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingDirectionCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingDirectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingDirectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsCirclingDirectionCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingDirectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingDirectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingDirectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsCirclingRadiusCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingRadiusCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsCirclingRadiusCallback = callback;
    decoder->ARDrone3PilotingSettingsCirclingRadiusCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingRadiusCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingRadiusCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingRadiusCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsCirclingRadiusCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingRadiusCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingRadiusCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingRadiusCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsCirclingAltitudeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingAltitudeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsCirclingAltitudeCallback = callback;
    decoder->ARDrone3PilotingSettingsCirclingAltitudeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingAltitudeCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingAltitudeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingAltitudeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsCirclingAltitudeCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingAltitudeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingAltitudeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingAltitudeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsPitchModeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsPitchModeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsPitchModeCallback = callback;
    decoder->ARDrone3PilotingSettingsPitchModeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsPitchModeCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsPitchModeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsPitchModeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsPitchModeCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsPitchModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsPitchModeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsPitchModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsMaxVerticalSpeedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SpeedSettingsMaxVerticalSpeedCallback = callback;
    decoder->ARDrone3SpeedSettingsMaxVerticalSpeedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsMaxVerticalSpeedCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsMaxRotationSpeedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SpeedSettingsMaxRotationSpeedCallback = callback;
    decoder->ARDrone3SpeedSettingsMaxRotationSpeedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsMaxRotationSpeedCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsHullProtectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SpeedSettingsHullProtectionCallback = callback;
    decoder->ARDrone3SpeedSettingsHullProtectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsHullProtectionCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsOutdoorCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SpeedSettingsOutdoorCallback = callback;
    decoder->ARDrone3SpeedSettingsOutdoorCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsOutdoorCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsMaxPitchRollRotationSpeedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCallback = callback;
    decoder->ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsMaxPitchRollRotationSpeedCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsWifiSelectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3NetworkSettingsWifiSelectionCallback = callback;
    decoder->ARDrone3NetworkSettingsWifiSelectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsWifiSelectionCallback (ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsWifiSecurityCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSecurityCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3NetworkSettingsWifiSecurityCallback = callback;
    decoder->ARDrone3NetworkSettingsWifiSecurityCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSecurityCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSecurityCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSecurityCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsWifiSecurityCallback (ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSecurityCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSecurityCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSecurityCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsPictureFormatSelectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsPictureFormatSelectionCallback = callback;
    decoder->ARDrone3PictureSettingsPictureFormatSelectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsPictureFormatSelectionCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsAutoWhiteBalanceSelectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback = callback;
    decoder->ARDrone3PictureSettingsAutoWhiteBalanceSelectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsExpositionSelectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsExpositionSelectionCallback = callback;
    decoder->ARDrone3PictureSettingsExpositionSelectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsExpositionSelectionCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsSaturationSelectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsSaturationSelectionCallback = callback;
    decoder->ARDrone3PictureSettingsSaturationSelectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsSaturationSelectionCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsTimelapseSelectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsTimelapseSelectionCallback = callback;
    decoder->ARDrone3PictureSettingsTimelapseSelectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsTimelapseSelectionCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsVideoAutorecordSelectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsVideoAutorecordSelectionCallback = callback;
    decoder->ARDrone3PictureSettingsVideoAutorecordSelectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsVideoAutorecordSelectionCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsVideoStabilizationModeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoStabilizationModeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsVideoStabilizationModeCallback = callback;
    decoder->ARDrone3PictureSettingsVideoStabilizationModeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoStabilizationModeCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoStabilizationModeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoStabilizationModeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsVideoStabilizationModeCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoStabilizationModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoStabilizationModeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoStabilizationModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsVideoRecordingModeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoRecordingModeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsVideoRecordingModeCallback = callback;
    decoder->ARDrone3PictureSettingsVideoRecordingModeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoRecordingModeCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoRecordingModeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoRecordingModeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsVideoRecordingModeCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoRecordingModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoRecordingModeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoRecordingModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsVideoFramerateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoFramerateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsVideoFramerateCallback = callback;
    decoder->ARDrone3PictureSettingsVideoFramerateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoFramerateCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoFramerateCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoFramerateCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsVideoFramerateCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoFramerateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoFramerateCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoFramerateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsVideoResolutionsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoResolutionsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsVideoResolutionsCallback = callback;
    decoder->ARDrone3PictureSettingsVideoResolutionsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoResolutionsCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoResolutionsCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoResolutionsCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsVideoResolutionsCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoResolutionsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoResolutionsCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoResolutionsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaStreamingVideoEnableCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaStreamingVideoEnableCallback = callback;
    decoder->ARDrone3MediaStreamingVideoEnableCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCallback_t ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaStreamingVideoEnableCallback (ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaStreamingVideoStreamModeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoStreamModeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaStreamingVideoStreamModeCallback = callback;
    decoder->ARDrone3MediaStreamingVideoStreamModeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoStreamModeCallback_t ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoStreamModeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoStreamModeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaStreamingVideoStreamModeCallback (ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoStreamModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoStreamModeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoStreamModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsSetHomeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSSettingsSetHomeCallback = callback;
    decoder->ARDrone3GPSSettingsSetHomeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsSetHomeCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsResetHomeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSSettingsResetHomeCallback = callback;
    decoder->ARDrone3GPSSettingsResetHomeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsResetHomeCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsSendControllerGPSCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSSettingsSendControllerGPSCallback = callback;
    decoder->ARDrone3GPSSettingsSendControllerGPSCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsSendControllerGPSCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsHomeTypeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSSettingsHomeTypeCallback = callback;
    decoder->ARDrone3GPSSettingsHomeTypeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsHomeTypeCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsReturnHomeDelayCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSSettingsReturnHomeDelayCallback = callback;
    decoder->ARDrone3GPSSettingsReturnHomeDelayCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsReturnHomeDelayCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3AntiflickeringElectricFrequencyCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3AntiflickeringElectricFrequencyCallback = callback;
    decoder->ARDrone3AntiflickeringElectricFrequencyCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCallback_t ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3AntiflickeringElectricFrequencyCallback (ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCb = callback;
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3AntiflickeringSetModeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3AntiflickeringSetModeCallback = callback;
    decoder->ARDrone3AntiflickeringSetModeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCallback_t ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3AntiflickeringSetModeCallback (ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStatePictureStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaRecordStatePictureStateChangedCallback = callback;
    decoder->ARDrone3MediaRecordStatePictureStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStatePictureStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaRecordStateVideoStateChangedCallback = callback;
    decoder->ARDrone3MediaRecordStateVideoStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStatePictureStateChangedV2Cb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Callback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaRecordStatePictureStateChangedV2Callback = callback;
    decoder->ARDrone3MediaRecordStatePictureStateChangedV2Custom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Callback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Cb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Custom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStatePictureStateChangedV2Callback (ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Cb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoStateChangedV2Cb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Callback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaRecordStateVideoStateChangedV2Callback = callback;
    decoder->ARDrone3MediaRecordStateVideoStateChangedV2Custom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Callback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Cb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Custom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoStateChangedV2Callback (ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Cb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoResolutionStateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoResolutionStateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaRecordStateVideoResolutionStateCallback = callback;
    decoder->ARDrone3MediaRecordStateVideoResolutionStateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoResolutionStateCallback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoResolutionStateCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoResolutionStateCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoResolutionStateCallback (ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoResolutionStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoResolutionStateCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoResolutionStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordEventPictureEventChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaRecordEventPictureEventChangedCallback = callback;
    decoder->ARDrone3MediaRecordEventPictureEventChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCallback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordEventPictureEventChangedCallback (ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordEventVideoEventChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaRecordEventVideoEventChangedCallback = callback;
    decoder->ARDrone3MediaRecordEventVideoEventChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCallback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordEventVideoEventChangedCallback (ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateFlatTrimChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingStateFlatTrimChangedCallback = callback;
    decoder->ARDrone3PilotingStateFlatTrimChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateFlatTrimChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateFlyingStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingStateFlyingStateChangedCallback = callback;
    decoder->ARDrone3PilotingStateFlyingStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateFlyingStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateAlertStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingStateAlertStateChangedCallback = callback;
    decoder->ARDrone3PilotingStateAlertStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateAlertStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateNavigateHomeStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingStateNavigateHomeStateChangedCallback = callback;
    decoder->ARDrone3PilotingStateNavigateHomeStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateNavigateHomeStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingStatePositionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingStatePositionChangedCallback = callback;
    decoder->ARDrone3PilotingStatePositionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStatePositionChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateSpeedChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingStateSpeedChangedCallback = callback;
    decoder->ARDrone3PilotingStateSpeedChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateSpeedChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateAttitudeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingStateAttitudeChangedCallback = callback;
    decoder->ARDrone3PilotingStateAttitudeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateAttitudeChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateAutoTakeOffModeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingStateAutoTakeOffModeChangedCallback = callback;
    decoder->ARDrone3PilotingStateAutoTakeOffModeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateAutoTakeOffModeChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateAltitudeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingStateAltitudeChangedCallback = callback;
    decoder->ARDrone3PilotingStateAltitudeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateAltitudeChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateGpsLocationChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingStateGpsLocationChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingStateGpsLocationChangedCallback = callback;
    decoder->ARDrone3PilotingStateGpsLocationChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingStateGpsLocationChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateGpsLocationChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateGpsLocationChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateGpsLocationChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateGpsLocationChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateGpsLocationChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateGpsLocationChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateLandingStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingStateLandingStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingStateLandingStateChangedCallback = callback;
    decoder->ARDrone3PilotingStateLandingStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingStateLandingStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateLandingStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateLandingStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateLandingStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateLandingStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateLandingStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateLandingStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingEventMoveByEndCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingEventMoveByEndCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingEventMoveByEndCallback = callback;
    decoder->ARDrone3PilotingEventMoveByEndCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingEventMoveByEndCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingEventMoveByEndCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingEventMoveByEndCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingEventMoveByEndCallback (ARCOMMANDS_Decoder_ARDrone3PilotingEventMoveByEndCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingEventMoveByEndCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingEventMoveByEndCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3NetworkStateWifiScanListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3NetworkStateWifiScanListChangedCallback = callback;
    decoder->ARDrone3NetworkStateWifiScanListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkStateWifiScanListChangedCallback (ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3NetworkStateAllWifiScanChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3NetworkStateAllWifiScanChangedCallback = callback;
    decoder->ARDrone3NetworkStateAllWifiScanChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkStateAllWifiScanChangedCallback (ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3NetworkStateWifiAuthChannelListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3NetworkStateWifiAuthChannelListChangedCallback = callback;
    decoder->ARDrone3NetworkStateWifiAuthChannelListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkStateWifiAuthChannelListChangedCallback (ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3NetworkStateAllWifiAuthChannelChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3NetworkStateAllWifiAuthChannelChangedCallback = callback;
    decoder->ARDrone3NetworkStateAllWifiAuthChannelChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkStateAllWifiAuthChannelChangedCallback (ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxAltitudeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateMaxAltitudeChangedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateMaxAltitudeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxAltitudeChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxTiltChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateMaxTiltChangedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateMaxTiltChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxTiltChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAbsolutControlChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateAbsolutControlChangedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateAbsolutControlChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAbsolutControlChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxDistanceChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateMaxDistanceChangedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateMaxDistanceChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxDistanceChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback = callback;
    decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback = callback;
    decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateBankedTurnChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateBankedTurnChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateBankedTurnChangedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateBankedTurnChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateBankedTurnChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateBankedTurnChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateBankedTurnChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateBankedTurnChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateBankedTurnChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateBankedTurnChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateBankedTurnChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMinAltitudeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMinAltitudeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateMinAltitudeChangedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateMinAltitudeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMinAltitudeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMinAltitudeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMinAltitudeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMinAltitudeChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMinAltitudeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMinAltitudeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMinAltitudeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingDirectionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingDirectionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateCirclingDirectionChangedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateCirclingDirectionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingDirectionChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingDirectionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingDirectionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingDirectionChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingDirectionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingDirectionChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingDirectionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingRadiusChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingRadiusChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateCirclingRadiusChangedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateCirclingRadiusChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingRadiusChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingRadiusChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingRadiusChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingRadiusChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingRadiusChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingRadiusChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingRadiusChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingAltitudeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingAltitudeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateCirclingAltitudeChangedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateCirclingAltitudeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingAltitudeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingAltitudeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingAltitudeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingAltitudeChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingAltitudeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingAltitudeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingAltitudeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStatePitchModeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStatePitchModeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStatePitchModeChangedCallback = callback;
    decoder->ARDrone3PilotingSettingsStatePitchModeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStatePitchModeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStatePitchModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStatePitchModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStatePitchModeChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStatePitchModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStatePitchModeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStatePitchModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback = callback;
    decoder->ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxRotationSpeedChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback = callback;
    decoder->ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateHullProtectionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SpeedSettingsStateHullProtectionChangedCallback = callback;
    decoder->ARDrone3SpeedSettingsStateHullProtectionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateHullProtectionChangedCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateOutdoorChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SpeedSettingsStateOutdoorChangedCallback = callback;
    decoder->ARDrone3SpeedSettingsStateOutdoorChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateOutdoorChangedCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback = callback;
    decoder->ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSelectionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3NetworkSettingsStateWifiSelectionChangedCallback = callback;
    decoder->ARDrone3NetworkSettingsStateWifiSelectionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSelectionChangedCallback (ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSecurityChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3NetworkSettingsStateWifiSecurityChangedCallback = callback;
    decoder->ARDrone3NetworkSettingsStateWifiSecurityChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityChangedCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSecurityChangedCallback (ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSecurityCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3NetworkSettingsStateWifiSecurityCallback = callback;
    decoder->ARDrone3NetworkSettingsStateWifiSecurityCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSecurityCallback (ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateProductMotorVersionListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SettingsStateProductMotorVersionListChangedCallback = callback;
    decoder->ARDrone3SettingsStateProductMotorVersionListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateProductMotorVersionListChangedCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateProductGPSVersionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SettingsStateProductGPSVersionChangedCallback = callback;
    decoder->ARDrone3SettingsStateProductGPSVersionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateProductGPSVersionChangedCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorErrorStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SettingsStateMotorErrorStateChangedCallback = callback;
    decoder->ARDrone3SettingsStateMotorErrorStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorErrorStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorSoftwareVersionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SettingsStateMotorSoftwareVersionChangedCallback = callback;
    decoder->ARDrone3SettingsStateMotorSoftwareVersionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorSoftwareVersionChangedCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorFlightsStatusChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SettingsStateMotorFlightsStatusChangedCallback = callback;
    decoder->ARDrone3SettingsStateMotorFlightsStatusChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorFlightsStatusChangedCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorErrorLastErrorChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SettingsStateMotorErrorLastErrorChangedCallback = callback;
    decoder->ARDrone3SettingsStateMotorErrorLastErrorChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorErrorLastErrorChangedCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateP7IDCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SettingsStateP7IDCallback = callback;
    decoder->ARDrone3SettingsStateP7IDCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateP7IDCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateCPUIDCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SettingsStateCPUIDCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SettingsStateCPUIDCallback = callback;
    decoder->ARDrone3SettingsStateCPUIDCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SettingsStateCPUIDCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateCPUIDCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateCPUIDCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateCPUIDCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateCPUIDCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateCPUIDCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateCPUIDCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStatePictureFormatChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsStatePictureFormatChangedCallback = callback;
    decoder->ARDrone3PictureSettingsStatePictureFormatChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStatePictureFormatChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateAutoWhiteBalanceChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback = callback;
    decoder->ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateExpositionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsStateExpositionChangedCallback = callback;
    decoder->ARDrone3PictureSettingsStateExpositionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateExpositionChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateSaturationChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsStateSaturationChangedCallback = callback;
    decoder->ARDrone3PictureSettingsStateSaturationChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateSaturationChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateTimelapseChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsStateTimelapseChangedCallback = callback;
    decoder->ARDrone3PictureSettingsStateTimelapseChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateTimelapseChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoAutorecordChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsStateVideoAutorecordChangedCallback = callback;
    decoder->ARDrone3PictureSettingsStateVideoAutorecordChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoAutorecordChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoStabilizationModeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoStabilizationModeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsStateVideoStabilizationModeChangedCallback = callback;
    decoder->ARDrone3PictureSettingsStateVideoStabilizationModeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoStabilizationModeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoStabilizationModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoStabilizationModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoStabilizationModeChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoStabilizationModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoStabilizationModeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoStabilizationModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoRecordingModeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoRecordingModeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsStateVideoRecordingModeChangedCallback = callback;
    decoder->ARDrone3PictureSettingsStateVideoRecordingModeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoRecordingModeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoRecordingModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoRecordingModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoRecordingModeChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoRecordingModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoRecordingModeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoRecordingModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoFramerateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoFramerateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsStateVideoFramerateChangedCallback = callback;
    decoder->ARDrone3PictureSettingsStateVideoFramerateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoFramerateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoFramerateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoFramerateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoFramerateChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoFramerateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoFramerateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoFramerateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoResolutionsChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoResolutionsChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsStateVideoResolutionsChangedCallback = callback;
    decoder->ARDrone3PictureSettingsStateVideoResolutionsChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoResolutionsChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoResolutionsChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoResolutionsChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoResolutionsChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoResolutionsChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoResolutionsChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoResolutionsChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaStreamingStateVideoEnableChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaStreamingStateVideoEnableChangedCallback = callback;
    decoder->ARDrone3MediaStreamingStateVideoEnableChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCallback_t ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaStreamingStateVideoEnableChangedCallback (ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaStreamingStateVideoStreamModeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoStreamModeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaStreamingStateVideoStreamModeChangedCallback = callback;
    decoder->ARDrone3MediaStreamingStateVideoStreamModeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoStreamModeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoStreamModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoStreamModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaStreamingStateVideoStreamModeChangedCallback (ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoStreamModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoStreamModeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoStreamModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateHomeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSSettingsStateHomeChangedCallback = callback;
    decoder->ARDrone3GPSSettingsStateHomeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateHomeChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateResetHomeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSSettingsStateResetHomeChangedCallback = callback;
    decoder->ARDrone3GPSSettingsStateResetHomeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateResetHomeChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGPSFixStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSSettingsStateGPSFixStateChangedCallback = callback;
    decoder->ARDrone3GPSSettingsStateGPSFixStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGPSFixStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGPSUpdateStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSSettingsStateGPSUpdateStateChangedCallback = callback;
    decoder->ARDrone3GPSSettingsStateGPSUpdateStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGPSUpdateStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateHomeTypeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSSettingsStateHomeTypeChangedCallback = callback;
    decoder->ARDrone3GPSSettingsStateHomeTypeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateHomeTypeChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateReturnHomeDelayChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSSettingsStateReturnHomeDelayChangedCallback = callback;
    decoder->ARDrone3GPSSettingsStateReturnHomeDelayChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateReturnHomeDelayChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3CameraStateOrientationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3CameraStateOrientationCallback = callback;
    decoder->ARDrone3CameraStateOrientationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCallback_t ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3CameraStateOrientationCallback (ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCb = callback;
        ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3CameraStateDefaultCameraOrientationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3CameraStateDefaultCameraOrientationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3CameraStateDefaultCameraOrientationCallback = callback;
    decoder->ARDrone3CameraStateDefaultCameraOrientationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3CameraStateDefaultCameraOrientationCallback_t ARCOMMANDS_Decoder_ARDrone3CameraStateDefaultCameraOrientationCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3CameraStateDefaultCameraOrientationCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3CameraStateDefaultCameraOrientationCallback (ARCOMMANDS_Decoder_ARDrone3CameraStateDefaultCameraOrientationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3CameraStateDefaultCameraOrientationCb = callback;
        ARCOMMANDS_Decoder_ARDrone3CameraStateDefaultCameraOrientationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3AntiflickeringStateElectricFrequencyChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3AntiflickeringStateElectricFrequencyChangedCallback = callback;
    decoder->ARDrone3AntiflickeringStateElectricFrequencyChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCallback_t ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3AntiflickeringStateElectricFrequencyChangedCallback (ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3AntiflickeringStateModeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3AntiflickeringStateModeChangedCallback = callback;
    decoder->ARDrone3AntiflickeringStateModeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3AntiflickeringStateModeChangedCallback (ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSStateNumberOfSatelliteChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSStateNumberOfSatelliteChangedCallback = callback;
    decoder->ARDrone3GPSStateNumberOfSatelliteChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSStateNumberOfSatelliteChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSStateHomeTypeAvailabilityChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSStateHomeTypeAvailabilityChangedCallback = callback;
    decoder->ARDrone3GPSStateHomeTypeAvailabilityChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSStateHomeTypeAvailabilityChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSStateHomeTypeChosenChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSStateHomeTypeChosenChangedCallback = callback;
    decoder->ARDrone3GPSStateHomeTypeChosenChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSStateHomeTypeChosenChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PROStateFeaturesCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PROStateFeaturesCallback = callback;
    decoder->ARDrone3PROStateFeaturesCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCallback_t ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PROStateFeaturesCallback (ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature common

void ARCOMMANDS_Decoder_SetCommonNetworkDisconnectCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonNetworkDisconnectCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonNetworkDisconnectCallback = callback;
    decoder->CommonNetworkDisconnectCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonNetworkDisconnectCallback_t ARCOMMANDS_Decoder_CommonNetworkDisconnectCb = NULL;
static void *ARCOMMANDS_Decoder_CommonNetworkDisconnectCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonNetworkDisconnectCallback (ARCOMMANDS_Decoder_CommonNetworkDisconnectCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonNetworkDisconnectCb = callback;
        ARCOMMANDS_Decoder_CommonNetworkDisconnectCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsAllSettingsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsAllSettingsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsAllSettingsCallback = callback;
    decoder->CommonSettingsAllSettingsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsAllSettingsCallback_t ARCOMMANDS_Decoder_CommonSettingsAllSettingsCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsAllSettingsCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsAllSettingsCallback (ARCOMMANDS_Decoder_CommonSettingsAllSettingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsAllSettingsCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsAllSettingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsResetCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsResetCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsResetCallback = callback;
    decoder->CommonSettingsResetCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsResetCallback_t ARCOMMANDS_Decoder_CommonSettingsResetCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsResetCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsResetCallback (ARCOMMANDS_Decoder_CommonSettingsResetCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsResetCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsResetCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsProductNameCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsProductNameCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsProductNameCallback = callback;
    decoder->CommonSettingsProductNameCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsProductNameCallback_t ARCOMMANDS_Decoder_CommonSettingsProductNameCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsProductNameCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsProductNameCallback (ARCOMMANDS_Decoder_CommonSettingsProductNameCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsProductNameCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsProductNameCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsCountryCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsCountryCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsCountryCallback = callback;
    decoder->CommonSettingsCountryCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsCountryCallback_t ARCOMMANDS_Decoder_CommonSettingsCountryCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsCountryCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsCountryCallback (ARCOMMANDS_Decoder_CommonSettingsCountryCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsCountryCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsCountryCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsAutoCountryCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsAutoCountryCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsAutoCountryCallback = callback;
    decoder->CommonSettingsAutoCountryCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsAutoCountryCallback_t ARCOMMANDS_Decoder_CommonSettingsAutoCountryCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsAutoCountryCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsAutoCountryCallback (ARCOMMANDS_Decoder_CommonSettingsAutoCountryCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsAutoCountryCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsAutoCountryCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonAllStatesCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonAllStatesCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonAllStatesCallback = callback;
    decoder->CommonCommonAllStatesCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonAllStatesCallback_t ARCOMMANDS_Decoder_CommonCommonAllStatesCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonAllStatesCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonAllStatesCallback (ARCOMMANDS_Decoder_CommonCommonAllStatesCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonAllStatesCb = callback;
        ARCOMMANDS_Decoder_CommonCommonAllStatesCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonCurrentDateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonCurrentDateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonCurrentDateCallback = callback;
    decoder->CommonCommonCurrentDateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonCurrentDateCallback_t ARCOMMANDS_Decoder_CommonCommonCurrentDateCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonCurrentDateCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonCurrentDateCallback (ARCOMMANDS_Decoder_CommonCommonCurrentDateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonCurrentDateCb = callback;
        ARCOMMANDS_Decoder_CommonCommonCurrentDateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonCurrentTimeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonCurrentTimeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonCurrentTimeCallback = callback;
    decoder->CommonCommonCurrentTimeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonCurrentTimeCallback_t ARCOMMANDS_Decoder_CommonCommonCurrentTimeCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonCurrentTimeCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonCurrentTimeCallback (ARCOMMANDS_Decoder_CommonCommonCurrentTimeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonCurrentTimeCb = callback;
        ARCOMMANDS_Decoder_CommonCommonCurrentTimeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonRebootCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonRebootCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonRebootCallback = callback;
    decoder->CommonCommonRebootCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonRebootCallback_t ARCOMMANDS_Decoder_CommonCommonRebootCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonRebootCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonRebootCallback (ARCOMMANDS_Decoder_CommonCommonRebootCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonRebootCb = callback;
        ARCOMMANDS_Decoder_CommonCommonRebootCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonOverHeatSwitchOffCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonOverHeatSwitchOffCallback = callback;
    decoder->CommonOverHeatSwitchOffCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCallback_t ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCb = NULL;
static void *ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonOverHeatSwitchOffCallback (ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCb = callback;
        ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonOverHeatVentilateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonOverHeatVentilateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonOverHeatVentilateCallback = callback;
    decoder->CommonOverHeatVentilateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonOverHeatVentilateCallback_t ARCOMMANDS_Decoder_CommonOverHeatVentilateCb = NULL;
static void *ARCOMMANDS_Decoder_CommonOverHeatVentilateCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonOverHeatVentilateCallback (ARCOMMANDS_Decoder_CommonOverHeatVentilateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonOverHeatVentilateCb = callback;
        ARCOMMANDS_Decoder_CommonOverHeatVentilateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonControllerIsPilotingCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonControllerIsPilotingCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonControllerIsPilotingCallback = callback;
    decoder->CommonControllerIsPilotingCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonControllerIsPilotingCallback_t ARCOMMANDS_Decoder_CommonControllerIsPilotingCb = NULL;
static void *ARCOMMANDS_Decoder_CommonControllerIsPilotingCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonControllerIsPilotingCallback (ARCOMMANDS_Decoder_CommonControllerIsPilotingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonControllerIsPilotingCb = callback;
        ARCOMMANDS_Decoder_CommonControllerIsPilotingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonWifiSettingsOutdoorSettingCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonWifiSettingsOutdoorSettingCallback = callback;
    decoder->CommonWifiSettingsOutdoorSettingCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCallback_t ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCb = NULL;
static void *ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonWifiSettingsOutdoorSettingCallback (ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCb = callback;
        ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonMavlinkStartCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonMavlinkStartCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonMavlinkStartCallback = callback;
    decoder->CommonMavlinkStartCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonMavlinkStartCallback_t ARCOMMANDS_Decoder_CommonMavlinkStartCb = NULL;
static void *ARCOMMANDS_Decoder_CommonMavlinkStartCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonMavlinkStartCallback (ARCOMMANDS_Decoder_CommonMavlinkStartCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonMavlinkStartCb = callback;
        ARCOMMANDS_Decoder_CommonMavlinkStartCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonMavlinkPauseCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonMavlinkPauseCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonMavlinkPauseCallback = callback;
    decoder->CommonMavlinkPauseCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonMavlinkPauseCallback_t ARCOMMANDS_Decoder_CommonMavlinkPauseCb = NULL;
static void *ARCOMMANDS_Decoder_CommonMavlinkPauseCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonMavlinkPauseCallback (ARCOMMANDS_Decoder_CommonMavlinkPauseCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonMavlinkPauseCb = callback;
        ARCOMMANDS_Decoder_CommonMavlinkPauseCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonMavlinkStopCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonMavlinkStopCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonMavlinkStopCallback = callback;
    decoder->CommonMavlinkStopCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonMavlinkStopCallback_t ARCOMMANDS_Decoder_CommonMavlinkStopCb = NULL;
static void *ARCOMMANDS_Decoder_CommonMavlinkStopCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonMavlinkStopCallback (ARCOMMANDS_Decoder_CommonMavlinkStopCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonMavlinkStopCb = callback;
        ARCOMMANDS_Decoder_CommonMavlinkStopCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCalibrationMagnetoCalibrationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCalibrationMagnetoCalibrationCallback = callback;
    decoder->CommonCalibrationMagnetoCalibrationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCallback_t ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCalibrationMagnetoCalibrationCallback (ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCb = callback;
        ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCalibrationPitotCalibrationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCalibrationPitotCalibrationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCalibrationPitotCalibrationCallback = callback;
    decoder->CommonCalibrationPitotCalibrationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCalibrationPitotCalibrationCallback_t ARCOMMANDS_Decoder_CommonCalibrationPitotCalibrationCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCalibrationPitotCalibrationCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCalibrationPitotCalibrationCallback (ARCOMMANDS_Decoder_CommonCalibrationPitotCalibrationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCalibrationPitotCalibrationCb = callback;
        ARCOMMANDS_Decoder_CommonCalibrationPitotCalibrationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonGPSControllerPositionForRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonGPSControllerPositionForRunCallback = callback;
    decoder->CommonGPSControllerPositionForRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCallback_t ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCb = NULL;
static void *ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonGPSControllerPositionForRunCallback (ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCb = callback;
        ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonAudioControllerReadyForStreamingCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonAudioControllerReadyForStreamingCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonAudioControllerReadyForStreamingCallback = callback;
    decoder->CommonAudioControllerReadyForStreamingCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonAudioControllerReadyForStreamingCallback_t ARCOMMANDS_Decoder_CommonAudioControllerReadyForStreamingCb = NULL;
static void *ARCOMMANDS_Decoder_CommonAudioControllerReadyForStreamingCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonAudioControllerReadyForStreamingCallback (ARCOMMANDS_Decoder_CommonAudioControllerReadyForStreamingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonAudioControllerReadyForStreamingCb = callback;
        ARCOMMANDS_Decoder_CommonAudioControllerReadyForStreamingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonHeadlightsIntensityCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonHeadlightsIntensityCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonHeadlightsIntensityCallback = callback;
    decoder->CommonHeadlightsIntensityCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonHeadlightsIntensityCallback_t ARCOMMANDS_Decoder_CommonHeadlightsIntensityCb = NULL;
static void *ARCOMMANDS_Decoder_CommonHeadlightsIntensityCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonHeadlightsIntensityCallback (ARCOMMANDS_Decoder_CommonHeadlightsIntensityCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonHeadlightsIntensityCb = callback;
        ARCOMMANDS_Decoder_CommonHeadlightsIntensityCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonAnimationsStartAnimationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonAnimationsStartAnimationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonAnimationsStartAnimationCallback = callback;
    decoder->CommonAnimationsStartAnimationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonAnimationsStartAnimationCallback_t ARCOMMANDS_Decoder_CommonAnimationsStartAnimationCb = NULL;
static void *ARCOMMANDS_Decoder_CommonAnimationsStartAnimationCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonAnimationsStartAnimationCallback (ARCOMMANDS_Decoder_CommonAnimationsStartAnimationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonAnimationsStartAnimationCb = callback;
        ARCOMMANDS_Decoder_CommonAnimationsStartAnimationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonAnimationsStopAnimationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonAnimationsStopAnimationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonAnimationsStopAnimationCallback = callback;
    decoder->CommonAnimationsStopAnimationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonAnimationsStopAnimationCallback_t ARCOMMANDS_Decoder_CommonAnimationsStopAnimationCb = NULL;
static void *ARCOMMANDS_Decoder_CommonAnimationsStopAnimationCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonAnimationsStopAnimationCallback (ARCOMMANDS_Decoder_CommonAnimationsStopAnimationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonAnimationsStopAnimationCb = callback;
        ARCOMMANDS_Decoder_CommonAnimationsStopAnimationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonAnimationsStopAllAnimationsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonAnimationsStopAllAnimationsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonAnimationsStopAllAnimationsCallback = callback;
    decoder->CommonAnimationsStopAllAnimationsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonAnimationsStopAllAnimationsCallback_t ARCOMMANDS_Decoder_CommonAnimationsStopAllAnimationsCb = NULL;
static void *ARCOMMANDS_Decoder_CommonAnimationsStopAllAnimationsCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonAnimationsStopAllAnimationsCallback (ARCOMMANDS_Decoder_CommonAnimationsStopAllAnimationsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonAnimationsStopAllAnimationsCb = callback;
        ARCOMMANDS_Decoder_CommonAnimationsStopAllAnimationsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonAccessoryConfigCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonAccessoryConfigCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonAccessoryConfigCallback = callback;
    decoder->CommonAccessoryConfigCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonAccessoryConfigCallback_t ARCOMMANDS_Decoder_CommonAccessoryConfigCb = NULL;
static void *ARCOMMANDS_Decoder_CommonAccessoryConfigCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonAccessoryConfigCallback (ARCOMMANDS_Decoder_CommonAccessoryConfigCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonAccessoryConfigCb = callback;
        ARCOMMANDS_Decoder_CommonAccessoryConfigCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonChargerSetMaxChargeRateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonChargerSetMaxChargeRateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonChargerSetMaxChargeRateCallback = callback;
    decoder->CommonChargerSetMaxChargeRateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonChargerSetMaxChargeRateCallback_t ARCOMMANDS_Decoder_CommonChargerSetMaxChargeRateCb = NULL;
static void *ARCOMMANDS_Decoder_CommonChargerSetMaxChargeRateCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonChargerSetMaxChargeRateCallback (ARCOMMANDS_Decoder_CommonChargerSetMaxChargeRateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonChargerSetMaxChargeRateCb = callback;
        ARCOMMANDS_Decoder_CommonChargerSetMaxChargeRateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonNetworkEventDisconnectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonNetworkEventDisconnectionCallback = callback;
    decoder->CommonNetworkEventDisconnectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCallback_t ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCb = NULL;
static void *ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonNetworkEventDisconnectionCallback (ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCb = callback;
        ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsStateAllSettingsChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsStateAllSettingsChangedCallback = callback;
    decoder->CommonSettingsStateAllSettingsChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateAllSettingsChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsStateResetChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsStateResetChangedCallback = callback;
    decoder->CommonSettingsStateResetChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateResetChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsStateProductNameChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsStateProductNameChangedCallback = callback;
    decoder->CommonSettingsStateProductNameChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateProductNameChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsStateProductVersionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsStateProductVersionChangedCallback = callback;
    decoder->CommonSettingsStateProductVersionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateProductVersionChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsStateProductSerialHighChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsStateProductSerialHighChangedCallback = callback;
    decoder->CommonSettingsStateProductSerialHighChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateProductSerialHighChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsStateProductSerialLowChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsStateProductSerialLowChangedCallback = callback;
    decoder->CommonSettingsStateProductSerialLowChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateProductSerialLowChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsStateCountryChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsStateCountryChangedCallback = callback;
    decoder->CommonSettingsStateCountryChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateCountryChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsStateAutoCountryChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsStateAutoCountryChangedCallback = callback;
    decoder->CommonSettingsStateAutoCountryChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateAutoCountryChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateAllStatesChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateAllStatesChangedCallback = callback;
    decoder->CommonCommonStateAllStatesChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateAllStatesChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateBatteryStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateBatteryStateChangedCallback = callback;
    decoder->CommonCommonStateBatteryStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateBatteryStateChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageStateListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateMassStorageStateListChangedCallback = callback;
    decoder->CommonCommonStateMassStorageStateListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageStateListChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageInfoStateListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateMassStorageInfoStateListChangedCallback = callback;
    decoder->CommonCommonStateMassStorageInfoStateListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageInfoStateListChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateCurrentDateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateCurrentDateChangedCallback = callback;
    decoder->CommonCommonStateCurrentDateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateCurrentDateChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateCurrentTimeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateCurrentTimeChangedCallback = callback;
    decoder->CommonCommonStateCurrentTimeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateCurrentTimeChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageInfoRemainingListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateMassStorageInfoRemainingListChangedCallback = callback;
    decoder->CommonCommonStateMassStorageInfoRemainingListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageInfoRemainingListChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateWifiSignalChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateWifiSignalChangedCallback = callback;
    decoder->CommonCommonStateWifiSignalChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateWifiSignalChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateSensorsStatesListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateSensorsStatesListChangedCallback = callback;
    decoder->CommonCommonStateSensorsStatesListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateSensorsStatesListChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateProductModelCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateProductModelCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateProductModelCallback = callback;
    decoder->CommonCommonStateProductModelCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateProductModelCallback_t ARCOMMANDS_Decoder_CommonCommonStateProductModelCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateProductModelCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateProductModelCallback (ARCOMMANDS_Decoder_CommonCommonStateProductModelCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateProductModelCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateProductModelCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateCountryListKnownCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateCountryListKnownCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateCountryListKnownCallback = callback;
    decoder->CommonCommonStateCountryListKnownCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateCountryListKnownCallback_t ARCOMMANDS_Decoder_CommonCommonStateCountryListKnownCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateCountryListKnownCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateCountryListKnownCallback (ARCOMMANDS_Decoder_CommonCommonStateCountryListKnownCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateCountryListKnownCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateCountryListKnownCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateDeprecatedMassStorageContentChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateDeprecatedMassStorageContentChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateDeprecatedMassStorageContentChangedCallback = callback;
    decoder->CommonCommonStateDeprecatedMassStorageContentChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateDeprecatedMassStorageContentChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateDeprecatedMassStorageContentChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateDeprecatedMassStorageContentChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateDeprecatedMassStorageContentChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateDeprecatedMassStorageContentChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateDeprecatedMassStorageContentChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateDeprecatedMassStorageContentChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageContentCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateMassStorageContentCallback = callback;
    decoder->CommonCommonStateMassStorageContentCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentCallback_t ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageContentCallback (ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageContentForCurrentRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentForCurrentRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateMassStorageContentForCurrentRunCallback = callback;
    decoder->CommonCommonStateMassStorageContentForCurrentRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentForCurrentRunCallback_t ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentForCurrentRunCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentForCurrentRunCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageContentForCurrentRunCallback (ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentForCurrentRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentForCurrentRunCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentForCurrentRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonOverHeatStateOverHeatChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonOverHeatStateOverHeatChangedCallback = callback;
    decoder->CommonOverHeatStateOverHeatChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCallback_t ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonOverHeatStateOverHeatChangedCallback (ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCb = callback;
        ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonOverHeatStateOverHeatRegulationChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonOverHeatStateOverHeatRegulationChangedCallback = callback;
    decoder->CommonOverHeatStateOverHeatRegulationChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCallback_t ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonOverHeatStateOverHeatRegulationChangedCallback (ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCb = callback;
        ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonWifiSettingsStateOutdoorSettingsChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonWifiSettingsStateOutdoorSettingsChangedCallback = callback;
    decoder->CommonWifiSettingsStateOutdoorSettingsChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCallback_t ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonWifiSettingsStateOutdoorSettingsChangedCallback (ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCb = callback;
        ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonMavlinkStateMavlinkFilePlayingStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonMavlinkStateMavlinkFilePlayingStateChangedCallback = callback;
    decoder->CommonMavlinkStateMavlinkFilePlayingStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCallback_t ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonMavlinkStateMavlinkFilePlayingStateChangedCallback (ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonMavlinkStateMavlinkPlayErrorStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonMavlinkStateMavlinkPlayErrorStateChangedCallback = callback;
    decoder->CommonMavlinkStateMavlinkPlayErrorStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCallback_t ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonMavlinkStateMavlinkPlayErrorStateChangedCallback (ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCalibrationStateMagnetoCalibrationStateChangedCallback = callback;
    decoder->CommonCalibrationStateMagnetoCalibrationStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCallback_t ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationStateChangedCallback (ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationRequiredStateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCalibrationStateMagnetoCalibrationRequiredStateCallback = callback;
    decoder->CommonCalibrationStateMagnetoCalibrationRequiredStateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCallback_t ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationRequiredStateCallback (ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCb = callback;
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback = callback;
    decoder->CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback_t ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback (ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationStartedChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCalibrationStateMagnetoCalibrationStartedChangedCallback = callback;
    decoder->CommonCalibrationStateMagnetoCalibrationStartedChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCallback_t ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationStartedChangedCallback (ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCalibrationStatePitotCalibrationStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCalibrationStatePitotCalibrationStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCalibrationStatePitotCalibrationStateChangedCallback = callback;
    decoder->CommonCalibrationStatePitotCalibrationStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCalibrationStatePitotCalibrationStateChangedCallback_t ARCOMMANDS_Decoder_CommonCalibrationStatePitotCalibrationStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCalibrationStatePitotCalibrationStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCalibrationStatePitotCalibrationStateChangedCallback (ARCOMMANDS_Decoder_CommonCalibrationStatePitotCalibrationStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCalibrationStatePitotCalibrationStateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCalibrationStatePitotCalibrationStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCameraSettingsStateCameraSettingsChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCameraSettingsStateCameraSettingsChangedCallback = callback;
    decoder->CommonCameraSettingsStateCameraSettingsChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCallback_t ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCameraSettingsStateCameraSettingsChangedCallback (ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonFlightPlanStateAvailabilityStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonFlightPlanStateAvailabilityStateChangedCallback = callback;
    decoder->CommonFlightPlanStateAvailabilityStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCallback_t ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonFlightPlanStateAvailabilityStateChangedCallback (ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonFlightPlanStateComponentStateListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonFlightPlanStateComponentStateListChangedCallback = callback;
    decoder->CommonFlightPlanStateComponentStateListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCallback_t ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonFlightPlanStateComponentStateListChangedCallback (ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCb = callback;
        ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonFlightPlanStateLockStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonFlightPlanStateLockStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonFlightPlanStateLockStateChangedCallback = callback;
    decoder->CommonFlightPlanStateLockStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonFlightPlanStateLockStateChangedCallback_t ARCOMMANDS_Decoder_CommonFlightPlanStateLockStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonFlightPlanStateLockStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonFlightPlanStateLockStateChangedCallback (ARCOMMANDS_Decoder_CommonFlightPlanStateLockStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonFlightPlanStateLockStateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonFlightPlanStateLockStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonFlightPlanEventStartingErrorEventCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonFlightPlanEventStartingErrorEventCallback = callback;
    decoder->CommonFlightPlanEventStartingErrorEventCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCallback_t ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCb = NULL;
static void *ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonFlightPlanEventStartingErrorEventCallback (ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCb = callback;
        ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonFlightPlanEventSpeedBridleEventCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonFlightPlanEventSpeedBridleEventCallback = callback;
    decoder->CommonFlightPlanEventSpeedBridleEventCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCallback_t ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCb = NULL;
static void *ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonFlightPlanEventSpeedBridleEventCallback (ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCb = callback;
        ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateControllerLibARCommandsVersionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonARLibsVersionsStateControllerLibARCommandsVersionCallback = callback;
    decoder->CommonARLibsVersionsStateControllerLibARCommandsVersionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCallback_t ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCb = NULL;
static void *ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateControllerLibARCommandsVersionCallback (ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCb = callback;
        ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateSkyControllerLibARCommandsVersionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback = callback;
    decoder->CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback_t ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCb = NULL;
static void *ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback (ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCb = callback;
        ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateDeviceLibARCommandsVersionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonARLibsVersionsStateDeviceLibARCommandsVersionCallback = callback;
    decoder->CommonARLibsVersionsStateDeviceLibARCommandsVersionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCallback_t ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCb = NULL;
static void *ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateDeviceLibARCommandsVersionCallback (ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCb = callback;
        ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonAudioStateAudioStreamingRunningCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonAudioStateAudioStreamingRunningCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonAudioStateAudioStreamingRunningCallback = callback;
    decoder->CommonAudioStateAudioStreamingRunningCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonAudioStateAudioStreamingRunningCallback_t ARCOMMANDS_Decoder_CommonAudioStateAudioStreamingRunningCb = NULL;
static void *ARCOMMANDS_Decoder_CommonAudioStateAudioStreamingRunningCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonAudioStateAudioStreamingRunningCallback (ARCOMMANDS_Decoder_CommonAudioStateAudioStreamingRunningCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonAudioStateAudioStreamingRunningCb = callback;
        ARCOMMANDS_Decoder_CommonAudioStateAudioStreamingRunningCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonHeadlightsStateIntensityChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonHeadlightsStateIntensityChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonHeadlightsStateIntensityChangedCallback = callback;
    decoder->CommonHeadlightsStateIntensityChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonHeadlightsStateIntensityChangedCallback_t ARCOMMANDS_Decoder_CommonHeadlightsStateIntensityChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonHeadlightsStateIntensityChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonHeadlightsStateIntensityChangedCallback (ARCOMMANDS_Decoder_CommonHeadlightsStateIntensityChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonHeadlightsStateIntensityChangedCb = callback;
        ARCOMMANDS_Decoder_CommonHeadlightsStateIntensityChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonAnimationsStateListCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonAnimationsStateListCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonAnimationsStateListCallback = callback;
    decoder->CommonAnimationsStateListCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonAnimationsStateListCallback_t ARCOMMANDS_Decoder_CommonAnimationsStateListCb = NULL;
static void *ARCOMMANDS_Decoder_CommonAnimationsStateListCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonAnimationsStateListCallback (ARCOMMANDS_Decoder_CommonAnimationsStateListCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonAnimationsStateListCb = callback;
        ARCOMMANDS_Decoder_CommonAnimationsStateListCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonAccessoryStateSupportedAccessoriesListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonAccessoryStateSupportedAccessoriesListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonAccessoryStateSupportedAccessoriesListChangedCallback = callback;
    decoder->CommonAccessoryStateSupportedAccessoriesListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonAccessoryStateSupportedAccessoriesListChangedCallback_t ARCOMMANDS_Decoder_CommonAccessoryStateSupportedAccessoriesListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonAccessoryStateSupportedAccessoriesListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonAccessoryStateSupportedAccessoriesListChangedCallback (ARCOMMANDS_Decoder_CommonAccessoryStateSupportedAccessoriesListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonAccessoryStateSupportedAccessoriesListChangedCb = callback;
        ARCOMMANDS_Decoder_CommonAccessoryStateSupportedAccessoriesListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonAccessoryStateAccessoryConfigChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonAccessoryStateAccessoryConfigChangedCallback = callback;
    decoder->CommonAccessoryStateAccessoryConfigChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigChangedCallback_t ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonAccessoryStateAccessoryConfigChangedCallback (ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigChangedCb = callback;
        ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonAccessoryStateAccessoryConfigModificationEnabledCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigModificationEnabledCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonAccessoryStateAccessoryConfigModificationEnabledCallback = callback;
    decoder->CommonAccessoryStateAccessoryConfigModificationEnabledCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigModificationEnabledCallback_t ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigModificationEnabledCb = NULL;
static void *ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigModificationEnabledCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonAccessoryStateAccessoryConfigModificationEnabledCallback (ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigModificationEnabledCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigModificationEnabledCb = callback;
        ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigModificationEnabledCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonChargerStateMaxChargeRateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonChargerStateMaxChargeRateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonChargerStateMaxChargeRateChangedCallback = callback;
    decoder->CommonChargerStateMaxChargeRateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonChargerStateMaxChargeRateChangedCallback_t ARCOMMANDS_Decoder_CommonChargerStateMaxChargeRateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonChargerStateMaxChargeRateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonChargerStateMaxChargeRateChangedCallback (ARCOMMANDS_Decoder_CommonChargerStateMaxChargeRateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonChargerStateMaxChargeRateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonChargerStateMaxChargeRateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonChargerStateCurrentChargeStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonChargerStateCurrentChargeStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonChargerStateCurrentChargeStateChangedCallback = callback;
    decoder->CommonChargerStateCurrentChargeStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonChargerStateCurrentChargeStateChangedCallback_t ARCOMMANDS_Decoder_CommonChargerStateCurrentChargeStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonChargerStateCurrentChargeStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonChargerStateCurrentChargeStateChangedCallback (ARCOMMANDS_Decoder_CommonChargerStateCurrentChargeStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonChargerStateCurrentChargeStateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonChargerStateCurrentChargeStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonChargerStateLastChargeRateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonChargerStateLastChargeRateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonChargerStateLastChargeRateChangedCallback = callback;
    decoder->CommonChargerStateLastChargeRateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonChargerStateLastChargeRateChangedCallback_t ARCOMMANDS_Decoder_CommonChargerStateLastChargeRateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonChargerStateLastChargeRateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonChargerStateLastChargeRateChangedCallback (ARCOMMANDS_Decoder_CommonChargerStateLastChargeRateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonChargerStateLastChargeRateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonChargerStateLastChargeRateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonChargerStateChargingInfoCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonChargerStateChargingInfoCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonChargerStateChargingInfoCallback = callback;
    decoder->CommonChargerStateChargingInfoCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonChargerStateChargingInfoCallback_t ARCOMMANDS_Decoder_CommonChargerStateChargingInfoCb = NULL;
static void *ARCOMMANDS_Decoder_CommonChargerStateChargingInfoCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonChargerStateChargingInfoCallback (ARCOMMANDS_Decoder_CommonChargerStateChargingInfoCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonChargerStateChargingInfoCb = callback;
        ARCOMMANDS_Decoder_CommonChargerStateChargingInfoCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonRunStateRunIdChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonRunStateRunIdChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonRunStateRunIdChangedCallback = callback;
    decoder->CommonRunStateRunIdChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonRunStateRunIdChangedCallback_t ARCOMMANDS_Decoder_CommonRunStateRunIdChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonRunStateRunIdChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonRunStateRunIdChangedCallback (ARCOMMANDS_Decoder_CommonRunStateRunIdChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonRunStateRunIdChangedCb = callback;
        ARCOMMANDS_Decoder_CommonRunStateRunIdChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature controller_info

void ARCOMMANDS_Decoder_SetControllerInfoGpsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ControllerInfoGpsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ControllerInfoGpsCallback = callback;
    decoder->ControllerInfoGpsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ControllerInfoGpsCallback_t ARCOMMANDS_Decoder_ControllerInfoGpsCb = NULL;
static void *ARCOMMANDS_Decoder_ControllerInfoGpsCustom = NULL;
void ARCOMMANDS_Decoder_SetControllerInfoGpsCallback (ARCOMMANDS_Decoder_ControllerInfoGpsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ControllerInfoGpsCb = callback;
        ARCOMMANDS_Decoder_ControllerInfoGpsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetControllerInfoBarometerCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ControllerInfoBarometerCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ControllerInfoBarometerCallback = callback;
    decoder->ControllerInfoBarometerCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ControllerInfoBarometerCallback_t ARCOMMANDS_Decoder_ControllerInfoBarometerCb = NULL;
static void *ARCOMMANDS_Decoder_ControllerInfoBarometerCustom = NULL;
void ARCOMMANDS_Decoder_SetControllerInfoBarometerCallback (ARCOMMANDS_Decoder_ControllerInfoBarometerCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ControllerInfoBarometerCb = callback;
        ARCOMMANDS_Decoder_ControllerInfoBarometerCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature debug

void ARCOMMANDS_Decoder_SetDebugGetAllSettingsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_DebugGetAllSettingsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->DebugGetAllSettingsCallback = callback;
    decoder->DebugGetAllSettingsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_DebugGetAllSettingsCallback_t ARCOMMANDS_Decoder_DebugGetAllSettingsCb = NULL;
static void *ARCOMMANDS_Decoder_DebugGetAllSettingsCustom = NULL;
void ARCOMMANDS_Decoder_SetDebugGetAllSettingsCallback (ARCOMMANDS_Decoder_DebugGetAllSettingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_DebugGetAllSettingsCb = callback;
        ARCOMMANDS_Decoder_DebugGetAllSettingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetDebugSetSettingCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_DebugSetSettingCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->DebugSetSettingCallback = callback;
    decoder->DebugSetSettingCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_DebugSetSettingCallback_t ARCOMMANDS_Decoder_DebugSetSettingCb = NULL;
static void *ARCOMMANDS_Decoder_DebugSetSettingCustom = NULL;
void ARCOMMANDS_Decoder_SetDebugSetSettingCallback (ARCOMMANDS_Decoder_DebugSetSettingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_DebugSetSettingCb = callback;
        ARCOMMANDS_Decoder_DebugSetSettingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetDebugSettingsInfoCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_DebugSettingsInfoCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->DebugSettingsInfoCallback = callback;
    decoder->DebugSettingsInfoCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_DebugSettingsInfoCallback_t ARCOMMANDS_Decoder_DebugSettingsInfoCb = NULL;
static void *ARCOMMANDS_Decoder_DebugSettingsInfoCustom = NULL;
void ARCOMMANDS_Decoder_SetDebugSettingsInfoCallback (ARCOMMANDS_Decoder_DebugSettingsInfoCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_DebugSettingsInfoCb = callback;
        ARCOMMANDS_Decoder_DebugSettingsInfoCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetDebugSettingsListCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_DebugSettingsListCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->DebugSettingsListCallback = callback;
    decoder->DebugSettingsListCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_DebugSettingsListCallback_t ARCOMMANDS_Decoder_DebugSettingsListCb = NULL;
static void *ARCOMMANDS_Decoder_DebugSettingsListCustom = NULL;
void ARCOMMANDS_Decoder_SetDebugSettingsListCallback (ARCOMMANDS_Decoder_DebugSettingsListCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_DebugSettingsListCb = callback;
        ARCOMMANDS_Decoder_DebugSettingsListCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature drone_manager

void ARCOMMANDS_Decoder_SetDroneManagerDiscoverDronesCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_DroneManagerDiscoverDronesCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->DroneManagerDiscoverDronesCallback = callback;
    decoder->DroneManagerDiscoverDronesCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_DroneManagerDiscoverDronesCallback_t ARCOMMANDS_Decoder_DroneManagerDiscoverDronesCb = NULL;
static void *ARCOMMANDS_Decoder_DroneManagerDiscoverDronesCustom = NULL;
void ARCOMMANDS_Decoder_SetDroneManagerDiscoverDronesCallback (ARCOMMANDS_Decoder_DroneManagerDiscoverDronesCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_DroneManagerDiscoverDronesCb = callback;
        ARCOMMANDS_Decoder_DroneManagerDiscoverDronesCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetDroneManagerConnectCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_DroneManagerConnectCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->DroneManagerConnectCallback = callback;
    decoder->DroneManagerConnectCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_DroneManagerConnectCallback_t ARCOMMANDS_Decoder_DroneManagerConnectCb = NULL;
static void *ARCOMMANDS_Decoder_DroneManagerConnectCustom = NULL;
void ARCOMMANDS_Decoder_SetDroneManagerConnectCallback (ARCOMMANDS_Decoder_DroneManagerConnectCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_DroneManagerConnectCb = callback;
        ARCOMMANDS_Decoder_DroneManagerConnectCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetDroneManagerForgetCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_DroneManagerForgetCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->DroneManagerForgetCallback = callback;
    decoder->DroneManagerForgetCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_DroneManagerForgetCallback_t ARCOMMANDS_Decoder_DroneManagerForgetCb = NULL;
static void *ARCOMMANDS_Decoder_DroneManagerForgetCustom = NULL;
void ARCOMMANDS_Decoder_SetDroneManagerForgetCallback (ARCOMMANDS_Decoder_DroneManagerForgetCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_DroneManagerForgetCb = callback;
        ARCOMMANDS_Decoder_DroneManagerForgetCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetDroneManagerDroneListItemCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_DroneManagerDroneListItemCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->DroneManagerDroneListItemCallback = callback;
    decoder->DroneManagerDroneListItemCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_DroneManagerDroneListItemCallback_t ARCOMMANDS_Decoder_DroneManagerDroneListItemCb = NULL;
static void *ARCOMMANDS_Decoder_DroneManagerDroneListItemCustom = NULL;
void ARCOMMANDS_Decoder_SetDroneManagerDroneListItemCallback (ARCOMMANDS_Decoder_DroneManagerDroneListItemCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_DroneManagerDroneListItemCb = callback;
        ARCOMMANDS_Decoder_DroneManagerDroneListItemCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetDroneManagerConnectionStateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_DroneManagerConnectionStateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->DroneManagerConnectionStateCallback = callback;
    decoder->DroneManagerConnectionStateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_DroneManagerConnectionStateCallback_t ARCOMMANDS_Decoder_DroneManagerConnectionStateCb = NULL;
static void *ARCOMMANDS_Decoder_DroneManagerConnectionStateCustom = NULL;
void ARCOMMANDS_Decoder_SetDroneManagerConnectionStateCallback (ARCOMMANDS_Decoder_DroneManagerConnectionStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_DroneManagerConnectionStateCb = callback;
        ARCOMMANDS_Decoder_DroneManagerConnectionStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetDroneManagerAuthenticationFailedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_DroneManagerAuthenticationFailedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->DroneManagerAuthenticationFailedCallback = callback;
    decoder->DroneManagerAuthenticationFailedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_DroneManagerAuthenticationFailedCallback_t ARCOMMANDS_Decoder_DroneManagerAuthenticationFailedCb = NULL;
static void *ARCOMMANDS_Decoder_DroneManagerAuthenticationFailedCustom = NULL;
void ARCOMMANDS_Decoder_SetDroneManagerAuthenticationFailedCallback (ARCOMMANDS_Decoder_DroneManagerAuthenticationFailedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_DroneManagerAuthenticationFailedCb = callback;
        ARCOMMANDS_Decoder_DroneManagerAuthenticationFailedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetDroneManagerConnectionRefusedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_DroneManagerConnectionRefusedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->DroneManagerConnectionRefusedCallback = callback;
    decoder->DroneManagerConnectionRefusedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_DroneManagerConnectionRefusedCallback_t ARCOMMANDS_Decoder_DroneManagerConnectionRefusedCb = NULL;
static void *ARCOMMANDS_Decoder_DroneManagerConnectionRefusedCustom = NULL;
void ARCOMMANDS_Decoder_SetDroneManagerConnectionRefusedCallback (ARCOMMANDS_Decoder_DroneManagerConnectionRefusedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_DroneManagerConnectionRefusedCb = callback;
        ARCOMMANDS_Decoder_DroneManagerConnectionRefusedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature JumpingSumo

void ARCOMMANDS_Decoder_SetJumpingSumoPilotingPCMDCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoPilotingPCMDCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoPilotingPCMDCallback = callback;
    decoder->JumpingSumoPilotingPCMDCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoPilotingPCMDCallback_t ARCOMMANDS_Decoder_JumpingSumoPilotingPCMDCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoPilotingPCMDCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoPilotingPCMDCallback (ARCOMMANDS_Decoder_JumpingSumoPilotingPCMDCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoPilotingPCMDCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoPilotingPCMDCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoPilotingPostureCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoPilotingPostureCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoPilotingPostureCallback = callback;
    decoder->JumpingSumoPilotingPostureCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoPilotingPostureCallback_t ARCOMMANDS_Decoder_JumpingSumoPilotingPostureCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoPilotingPostureCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoPilotingPostureCallback (ARCOMMANDS_Decoder_JumpingSumoPilotingPostureCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoPilotingPostureCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoPilotingPostureCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoPilotingAddCapOffsetCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoPilotingAddCapOffsetCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoPilotingAddCapOffsetCallback = callback;
    decoder->JumpingSumoPilotingAddCapOffsetCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoPilotingAddCapOffsetCallback_t ARCOMMANDS_Decoder_JumpingSumoPilotingAddCapOffsetCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoPilotingAddCapOffsetCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoPilotingAddCapOffsetCallback (ARCOMMANDS_Decoder_JumpingSumoPilotingAddCapOffsetCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoPilotingAddCapOffsetCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoPilotingAddCapOffsetCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsJumpStopCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpStopCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoAnimationsJumpStopCallback = callback;
    decoder->JumpingSumoAnimationsJumpStopCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpStopCallback_t ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpStopCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpStopCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsJumpStopCallback (ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpStopCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpStopCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpStopCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsJumpCancelCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCancelCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoAnimationsJumpCancelCallback = callback;
    decoder->JumpingSumoAnimationsJumpCancelCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCancelCallback_t ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCancelCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCancelCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsJumpCancelCallback (ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCancelCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCancelCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCancelCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsJumpLoadCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpLoadCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoAnimationsJumpLoadCallback = callback;
    decoder->JumpingSumoAnimationsJumpLoadCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpLoadCallback_t ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpLoadCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpLoadCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsJumpLoadCallback (ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpLoadCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpLoadCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpLoadCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsJumpCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoAnimationsJumpCallback = callback;
    decoder->JumpingSumoAnimationsJumpCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCallback_t ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsJumpCallback (ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsSimpleAnimationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoAnimationsSimpleAnimationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoAnimationsSimpleAnimationCallback = callback;
    decoder->JumpingSumoAnimationsSimpleAnimationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoAnimationsSimpleAnimationCallback_t ARCOMMANDS_Decoder_JumpingSumoAnimationsSimpleAnimationCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAnimationsSimpleAnimationCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsSimpleAnimationCallback (ARCOMMANDS_Decoder_JumpingSumoAnimationsSimpleAnimationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAnimationsSimpleAnimationCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAnimationsSimpleAnimationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordPictureCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoMediaRecordPictureCallback = callback;
    decoder->JumpingSumoMediaRecordPictureCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureCallback_t ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordPictureCallback (ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordVideoCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoMediaRecordVideoCallback = callback;
    decoder->JumpingSumoMediaRecordVideoCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoCallback_t ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordVideoCallback (ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordPictureV2Cb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureV2Callback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoMediaRecordPictureV2Callback = callback;
    decoder->JumpingSumoMediaRecordPictureV2Custom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureV2Callback_t ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureV2Cb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureV2Custom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordPictureV2Callback (ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureV2Cb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordVideoV2Cb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoV2Callback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoMediaRecordVideoV2Callback = callback;
    decoder->JumpingSumoMediaRecordVideoV2Custom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoV2Callback_t ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoV2Cb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoV2Custom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordVideoV2Callback (ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoV2Cb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkSettingsWifiSelectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsWifiSelectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoNetworkSettingsWifiSelectionCallback = callback;
    decoder->JumpingSumoNetworkSettingsWifiSelectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsWifiSelectionCallback_t ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsWifiSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsWifiSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkSettingsWifiSelectionCallback (ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsWifiSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsWifiSelectionCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsWifiSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkWifiScanCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoNetworkWifiScanCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoNetworkWifiScanCallback = callback;
    decoder->JumpingSumoNetworkWifiScanCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoNetworkWifiScanCallback_t ARCOMMANDS_Decoder_JumpingSumoNetworkWifiScanCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoNetworkWifiScanCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkWifiScanCallback (ARCOMMANDS_Decoder_JumpingSumoNetworkWifiScanCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoNetworkWifiScanCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoNetworkWifiScanCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkWifiAuthChannelCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoNetworkWifiAuthChannelCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoNetworkWifiAuthChannelCallback = callback;
    decoder->JumpingSumoNetworkWifiAuthChannelCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoNetworkWifiAuthChannelCallback_t ARCOMMANDS_Decoder_JumpingSumoNetworkWifiAuthChannelCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoNetworkWifiAuthChannelCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkWifiAuthChannelCallback (ARCOMMANDS_Decoder_JumpingSumoNetworkWifiAuthChannelCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoNetworkWifiAuthChannelCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoNetworkWifiAuthChannelCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsMasterVolumeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoAudioSettingsMasterVolumeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoAudioSettingsMasterVolumeCallback = callback;
    decoder->JumpingSumoAudioSettingsMasterVolumeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoAudioSettingsMasterVolumeCallback_t ARCOMMANDS_Decoder_JumpingSumoAudioSettingsMasterVolumeCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAudioSettingsMasterVolumeCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsMasterVolumeCallback (ARCOMMANDS_Decoder_JumpingSumoAudioSettingsMasterVolumeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAudioSettingsMasterVolumeCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAudioSettingsMasterVolumeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsThemeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoAudioSettingsThemeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoAudioSettingsThemeCallback = callback;
    decoder->JumpingSumoAudioSettingsThemeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoAudioSettingsThemeCallback_t ARCOMMANDS_Decoder_JumpingSumoAudioSettingsThemeCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAudioSettingsThemeCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsThemeCallback (ARCOMMANDS_Decoder_JumpingSumoAudioSettingsThemeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAudioSettingsThemeCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAudioSettingsThemeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanAllScriptsMetadataCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoRoadPlanAllScriptsMetadataCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoRoadPlanAllScriptsMetadataCallback = callback;
    decoder->JumpingSumoRoadPlanAllScriptsMetadataCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoRoadPlanAllScriptsMetadataCallback_t ARCOMMANDS_Decoder_JumpingSumoRoadPlanAllScriptsMetadataCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoRoadPlanAllScriptsMetadataCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanAllScriptsMetadataCallback (ARCOMMANDS_Decoder_JumpingSumoRoadPlanAllScriptsMetadataCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanAllScriptsMetadataCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanAllScriptsMetadataCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanScriptUploadedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptUploadedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoRoadPlanScriptUploadedCallback = callback;
    decoder->JumpingSumoRoadPlanScriptUploadedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptUploadedCallback_t ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptUploadedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptUploadedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanScriptUploadedCallback (ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptUploadedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptUploadedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptUploadedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanScriptDeleteCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptDeleteCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoRoadPlanScriptDeleteCallback = callback;
    decoder->JumpingSumoRoadPlanScriptDeleteCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptDeleteCallback_t ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptDeleteCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptDeleteCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanScriptDeleteCallback (ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptDeleteCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptDeleteCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptDeleteCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanPlayScriptCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoRoadPlanPlayScriptCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoRoadPlanPlayScriptCallback = callback;
    decoder->JumpingSumoRoadPlanPlayScriptCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoRoadPlanPlayScriptCallback_t ARCOMMANDS_Decoder_JumpingSumoRoadPlanPlayScriptCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoRoadPlanPlayScriptCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanPlayScriptCallback (ARCOMMANDS_Decoder_JumpingSumoRoadPlanPlayScriptCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanPlayScriptCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanPlayScriptCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoSpeedSettingsOutdoorCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsOutdoorCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoSpeedSettingsOutdoorCallback = callback;
    decoder->JumpingSumoSpeedSettingsOutdoorCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsOutdoorCallback_t ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsOutdoorCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsOutdoorCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoSpeedSettingsOutdoorCallback (ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsOutdoorCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsOutdoorCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsOutdoorCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoMediaStreamingVideoEnableCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoMediaStreamingVideoEnableCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoMediaStreamingVideoEnableCallback = callback;
    decoder->JumpingSumoMediaStreamingVideoEnableCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoMediaStreamingVideoEnableCallback_t ARCOMMANDS_Decoder_JumpingSumoMediaStreamingVideoEnableCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaStreamingVideoEnableCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaStreamingVideoEnableCallback (ARCOMMANDS_Decoder_JumpingSumoMediaStreamingVideoEnableCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaStreamingVideoEnableCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaStreamingVideoEnableCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoVideoSettingsAutorecordCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoVideoSettingsAutorecordCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoVideoSettingsAutorecordCallback = callback;
    decoder->JumpingSumoVideoSettingsAutorecordCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoVideoSettingsAutorecordCallback_t ARCOMMANDS_Decoder_JumpingSumoVideoSettingsAutorecordCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoVideoSettingsAutorecordCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoVideoSettingsAutorecordCallback (ARCOMMANDS_Decoder_JumpingSumoVideoSettingsAutorecordCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoVideoSettingsAutorecordCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoVideoSettingsAutorecordCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoPilotingStatePostureChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoPilotingStatePostureChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoPilotingStatePostureChangedCallback = callback;
    decoder->JumpingSumoPilotingStatePostureChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoPilotingStatePostureChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoPilotingStatePostureChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoPilotingStatePostureChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoPilotingStatePostureChangedCallback (ARCOMMANDS_Decoder_JumpingSumoPilotingStatePostureChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoPilotingStatePostureChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoPilotingStatePostureChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoPilotingStateAlertStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoPilotingStateAlertStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoPilotingStateAlertStateChangedCallback = callback;
    decoder->JumpingSumoPilotingStateAlertStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoPilotingStateAlertStateChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoPilotingStateAlertStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoPilotingStateAlertStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoPilotingStateAlertStateChangedCallback (ARCOMMANDS_Decoder_JumpingSumoPilotingStateAlertStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoPilotingStateAlertStateChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoPilotingStateAlertStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoPilotingStateSpeedChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoPilotingStateSpeedChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoPilotingStateSpeedChangedCallback = callback;
    decoder->JumpingSumoPilotingStateSpeedChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoPilotingStateSpeedChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoPilotingStateSpeedChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoPilotingStateSpeedChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoPilotingStateSpeedChangedCallback (ARCOMMANDS_Decoder_JumpingSumoPilotingStateSpeedChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoPilotingStateSpeedChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoPilotingStateSpeedChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpLoadChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpLoadChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoAnimationsStateJumpLoadChangedCallback = callback;
    decoder->JumpingSumoAnimationsStateJumpLoadChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpLoadChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpLoadChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpLoadChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpLoadChangedCallback (ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpLoadChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpLoadChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpLoadChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpTypeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpTypeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoAnimationsStateJumpTypeChangedCallback = callback;
    decoder->JumpingSumoAnimationsStateJumpTypeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpTypeChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpTypeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpTypeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpTypeChangedCallback (ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpTypeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpTypeChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpTypeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpMotorProblemChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpMotorProblemChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoAnimationsStateJumpMotorProblemChangedCallback = callback;
    decoder->JumpingSumoAnimationsStateJumpMotorProblemChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpMotorProblemChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpMotorProblemChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpMotorProblemChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpMotorProblemChangedCallback (ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpMotorProblemChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpMotorProblemChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpMotorProblemChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoSettingsStateProductGPSVersionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoSettingsStateProductGPSVersionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoSettingsStateProductGPSVersionChangedCallback = callback;
    decoder->JumpingSumoSettingsStateProductGPSVersionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoSettingsStateProductGPSVersionChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoSettingsStateProductGPSVersionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoSettingsStateProductGPSVersionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoSettingsStateProductGPSVersionChangedCallback (ARCOMMANDS_Decoder_JumpingSumoSettingsStateProductGPSVersionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoSettingsStateProductGPSVersionChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoSettingsStateProductGPSVersionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStatePictureStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoMediaRecordStatePictureStateChangedCallback = callback;
    decoder->JumpingSumoMediaRecordStatePictureStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStatePictureStateChangedCallback (ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStateVideoStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoMediaRecordStateVideoStateChangedCallback = callback;
    decoder->JumpingSumoMediaRecordStateVideoStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStateVideoStateChangedCallback (ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStatePictureStateChangedV2Cb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedV2Callback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoMediaRecordStatePictureStateChangedV2Callback = callback;
    decoder->JumpingSumoMediaRecordStatePictureStateChangedV2Custom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedV2Callback_t ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedV2Cb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedV2Custom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStatePictureStateChangedV2Callback (ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedV2Cb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStateVideoStateChangedV2Cb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedV2Callback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoMediaRecordStateVideoStateChangedV2Callback = callback;
    decoder->JumpingSumoMediaRecordStateVideoStateChangedV2Custom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedV2Callback_t ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedV2Cb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedV2Custom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStateVideoStateChangedV2Callback (ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedV2Cb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordEventPictureEventChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventPictureEventChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoMediaRecordEventPictureEventChangedCallback = callback;
    decoder->JumpingSumoMediaRecordEventPictureEventChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventPictureEventChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventPictureEventChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventPictureEventChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordEventPictureEventChangedCallback (ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventPictureEventChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventPictureEventChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventPictureEventChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordEventVideoEventChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventVideoEventChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoMediaRecordEventVideoEventChangedCallback = callback;
    decoder->JumpingSumoMediaRecordEventVideoEventChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventVideoEventChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventVideoEventChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventVideoEventChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordEventVideoEventChangedCallback (ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventVideoEventChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventVideoEventChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventVideoEventChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkSettingsStateWifiSelectionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsStateWifiSelectionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoNetworkSettingsStateWifiSelectionChangedCallback = callback;
    decoder->JumpingSumoNetworkSettingsStateWifiSelectionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsStateWifiSelectionChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsStateWifiSelectionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsStateWifiSelectionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkSettingsStateWifiSelectionChangedCallback (ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsStateWifiSelectionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsStateWifiSelectionChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsStateWifiSelectionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateWifiScanListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiScanListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoNetworkStateWifiScanListChangedCallback = callback;
    decoder->JumpingSumoNetworkStateWifiScanListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiScanListChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiScanListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiScanListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateWifiScanListChangedCallback (ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiScanListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiScanListChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiScanListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateAllWifiScanChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiScanChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoNetworkStateAllWifiScanChangedCallback = callback;
    decoder->JumpingSumoNetworkStateAllWifiScanChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiScanChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiScanChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiScanChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateAllWifiScanChangedCallback (ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiScanChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiScanChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiScanChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateWifiAuthChannelListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiAuthChannelListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoNetworkStateWifiAuthChannelListChangedCallback = callback;
    decoder->JumpingSumoNetworkStateWifiAuthChannelListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiAuthChannelListChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiAuthChannelListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiAuthChannelListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateWifiAuthChannelListChangedCallback (ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiAuthChannelListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiAuthChannelListChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiAuthChannelListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateAllWifiAuthChannelChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiAuthChannelChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoNetworkStateAllWifiAuthChannelChangedCallback = callback;
    decoder->JumpingSumoNetworkStateAllWifiAuthChannelChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiAuthChannelChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiAuthChannelChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiAuthChannelChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateAllWifiAuthChannelChangedCallback (ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiAuthChannelChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiAuthChannelChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiAuthChannelChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateLinkQualityChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoNetworkStateLinkQualityChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoNetworkStateLinkQualityChangedCallback = callback;
    decoder->JumpingSumoNetworkStateLinkQualityChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoNetworkStateLinkQualityChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoNetworkStateLinkQualityChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoNetworkStateLinkQualityChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateLinkQualityChangedCallback (ARCOMMANDS_Decoder_JumpingSumoNetworkStateLinkQualityChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoNetworkStateLinkQualityChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoNetworkStateLinkQualityChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsStateMasterVolumeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateMasterVolumeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoAudioSettingsStateMasterVolumeChangedCallback = callback;
    decoder->JumpingSumoAudioSettingsStateMasterVolumeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateMasterVolumeChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateMasterVolumeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateMasterVolumeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsStateMasterVolumeChangedCallback (ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateMasterVolumeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateMasterVolumeChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateMasterVolumeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsStateThemeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateThemeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoAudioSettingsStateThemeChangedCallback = callback;
    decoder->JumpingSumoAudioSettingsStateThemeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateThemeChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateThemeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateThemeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsStateThemeChangedCallback (ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateThemeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateThemeChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateThemeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptMetadataListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptMetadataListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoRoadPlanStateScriptMetadataListChangedCallback = callback;
    decoder->JumpingSumoRoadPlanStateScriptMetadataListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptMetadataListChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptMetadataListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptMetadataListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptMetadataListChangedCallback (ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptMetadataListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptMetadataListChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptMetadataListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateAllScriptsMetadataChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateAllScriptsMetadataChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoRoadPlanStateAllScriptsMetadataChangedCallback = callback;
    decoder->JumpingSumoRoadPlanStateAllScriptsMetadataChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateAllScriptsMetadataChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateAllScriptsMetadataChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateAllScriptsMetadataChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateAllScriptsMetadataChangedCallback (ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateAllScriptsMetadataChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateAllScriptsMetadataChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateAllScriptsMetadataChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptUploadChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptUploadChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoRoadPlanStateScriptUploadChangedCallback = callback;
    decoder->JumpingSumoRoadPlanStateScriptUploadChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptUploadChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptUploadChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptUploadChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptUploadChangedCallback (ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptUploadChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptUploadChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptUploadChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptDeleteChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptDeleteChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoRoadPlanStateScriptDeleteChangedCallback = callback;
    decoder->JumpingSumoRoadPlanStateScriptDeleteChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptDeleteChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptDeleteChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptDeleteChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptDeleteChangedCallback (ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptDeleteChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptDeleteChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptDeleteChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStatePlayScriptChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoRoadPlanStatePlayScriptChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoRoadPlanStatePlayScriptChangedCallback = callback;
    decoder->JumpingSumoRoadPlanStatePlayScriptChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoRoadPlanStatePlayScriptChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoRoadPlanStatePlayScriptChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoRoadPlanStatePlayScriptChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStatePlayScriptChangedCallback (ARCOMMANDS_Decoder_JumpingSumoRoadPlanStatePlayScriptChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanStatePlayScriptChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoRoadPlanStatePlayScriptChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoSpeedSettingsStateOutdoorChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsStateOutdoorChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoSpeedSettingsStateOutdoorChangedCallback = callback;
    decoder->JumpingSumoSpeedSettingsStateOutdoorChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsStateOutdoorChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsStateOutdoorChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsStateOutdoorChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoSpeedSettingsStateOutdoorChangedCallback (ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsStateOutdoorChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsStateOutdoorChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsStateOutdoorChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoMediaStreamingStateVideoEnableChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoMediaStreamingStateVideoEnableChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoMediaStreamingStateVideoEnableChangedCallback = callback;
    decoder->JumpingSumoMediaStreamingStateVideoEnableChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoMediaStreamingStateVideoEnableChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoMediaStreamingStateVideoEnableChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoMediaStreamingStateVideoEnableChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoMediaStreamingStateVideoEnableChangedCallback (ARCOMMANDS_Decoder_JumpingSumoMediaStreamingStateVideoEnableChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoMediaStreamingStateVideoEnableChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoMediaStreamingStateVideoEnableChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetJumpingSumoVideoSettingsStateAutorecordChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_JumpingSumoVideoSettingsStateAutorecordChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->JumpingSumoVideoSettingsStateAutorecordChangedCallback = callback;
    decoder->JumpingSumoVideoSettingsStateAutorecordChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_JumpingSumoVideoSettingsStateAutorecordChangedCallback_t ARCOMMANDS_Decoder_JumpingSumoVideoSettingsStateAutorecordChangedCb = NULL;
static void *ARCOMMANDS_Decoder_JumpingSumoVideoSettingsStateAutorecordChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetJumpingSumoVideoSettingsStateAutorecordChangedCallback (ARCOMMANDS_Decoder_JumpingSumoVideoSettingsStateAutorecordChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_JumpingSumoVideoSettingsStateAutorecordChangedCb = callback;
        ARCOMMANDS_Decoder_JumpingSumoVideoSettingsStateAutorecordChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature mapper

void ARCOMMANDS_Decoder_SetMapperGrabCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperGrabCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperGrabCallback = callback;
    decoder->MapperGrabCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperGrabCallback_t ARCOMMANDS_Decoder_MapperGrabCb = NULL;
static void *ARCOMMANDS_Decoder_MapperGrabCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperGrabCallback (ARCOMMANDS_Decoder_MapperGrabCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperGrabCb = callback;
        ARCOMMANDS_Decoder_MapperGrabCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperMapButtonActionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperMapButtonActionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperMapButtonActionCallback = callback;
    decoder->MapperMapButtonActionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperMapButtonActionCallback_t ARCOMMANDS_Decoder_MapperMapButtonActionCb = NULL;
static void *ARCOMMANDS_Decoder_MapperMapButtonActionCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperMapButtonActionCallback (ARCOMMANDS_Decoder_MapperMapButtonActionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperMapButtonActionCb = callback;
        ARCOMMANDS_Decoder_MapperMapButtonActionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperMapAxisActionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperMapAxisActionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperMapAxisActionCallback = callback;
    decoder->MapperMapAxisActionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperMapAxisActionCallback_t ARCOMMANDS_Decoder_MapperMapAxisActionCb = NULL;
static void *ARCOMMANDS_Decoder_MapperMapAxisActionCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperMapAxisActionCallback (ARCOMMANDS_Decoder_MapperMapAxisActionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperMapAxisActionCb = callback;
        ARCOMMANDS_Decoder_MapperMapAxisActionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperResetMappingCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperResetMappingCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperResetMappingCallback = callback;
    decoder->MapperResetMappingCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperResetMappingCallback_t ARCOMMANDS_Decoder_MapperResetMappingCb = NULL;
static void *ARCOMMANDS_Decoder_MapperResetMappingCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperResetMappingCallback (ARCOMMANDS_Decoder_MapperResetMappingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperResetMappingCb = callback;
        ARCOMMANDS_Decoder_MapperResetMappingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperSetExpoCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperSetExpoCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperSetExpoCallback = callback;
    decoder->MapperSetExpoCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperSetExpoCallback_t ARCOMMANDS_Decoder_MapperSetExpoCb = NULL;
static void *ARCOMMANDS_Decoder_MapperSetExpoCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperSetExpoCallback (ARCOMMANDS_Decoder_MapperSetExpoCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperSetExpoCb = callback;
        ARCOMMANDS_Decoder_MapperSetExpoCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperSetInvertedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperSetInvertedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperSetInvertedCallback = callback;
    decoder->MapperSetInvertedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperSetInvertedCallback_t ARCOMMANDS_Decoder_MapperSetInvertedCb = NULL;
static void *ARCOMMANDS_Decoder_MapperSetInvertedCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperSetInvertedCallback (ARCOMMANDS_Decoder_MapperSetInvertedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperSetInvertedCb = callback;
        ARCOMMANDS_Decoder_MapperSetInvertedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperGrabStateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperGrabStateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperGrabStateCallback = callback;
    decoder->MapperGrabStateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperGrabStateCallback_t ARCOMMANDS_Decoder_MapperGrabStateCb = NULL;
static void *ARCOMMANDS_Decoder_MapperGrabStateCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperGrabStateCallback (ARCOMMANDS_Decoder_MapperGrabStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperGrabStateCb = callback;
        ARCOMMANDS_Decoder_MapperGrabStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperGrabButtonEventCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperGrabButtonEventCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperGrabButtonEventCallback = callback;
    decoder->MapperGrabButtonEventCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperGrabButtonEventCallback_t ARCOMMANDS_Decoder_MapperGrabButtonEventCb = NULL;
static void *ARCOMMANDS_Decoder_MapperGrabButtonEventCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperGrabButtonEventCallback (ARCOMMANDS_Decoder_MapperGrabButtonEventCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperGrabButtonEventCb = callback;
        ARCOMMANDS_Decoder_MapperGrabButtonEventCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperGrabAxisEventCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperGrabAxisEventCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperGrabAxisEventCallback = callback;
    decoder->MapperGrabAxisEventCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperGrabAxisEventCallback_t ARCOMMANDS_Decoder_MapperGrabAxisEventCb = NULL;
static void *ARCOMMANDS_Decoder_MapperGrabAxisEventCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperGrabAxisEventCallback (ARCOMMANDS_Decoder_MapperGrabAxisEventCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperGrabAxisEventCb = callback;
        ARCOMMANDS_Decoder_MapperGrabAxisEventCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperButtonMappingItemCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperButtonMappingItemCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperButtonMappingItemCallback = callback;
    decoder->MapperButtonMappingItemCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperButtonMappingItemCallback_t ARCOMMANDS_Decoder_MapperButtonMappingItemCb = NULL;
static void *ARCOMMANDS_Decoder_MapperButtonMappingItemCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperButtonMappingItemCallback (ARCOMMANDS_Decoder_MapperButtonMappingItemCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperButtonMappingItemCb = callback;
        ARCOMMANDS_Decoder_MapperButtonMappingItemCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperAxisMappingItemCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperAxisMappingItemCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperAxisMappingItemCallback = callback;
    decoder->MapperAxisMappingItemCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperAxisMappingItemCallback_t ARCOMMANDS_Decoder_MapperAxisMappingItemCb = NULL;
static void *ARCOMMANDS_Decoder_MapperAxisMappingItemCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperAxisMappingItemCallback (ARCOMMANDS_Decoder_MapperAxisMappingItemCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperAxisMappingItemCb = callback;
        ARCOMMANDS_Decoder_MapperAxisMappingItemCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperApplicationAxisEventCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperApplicationAxisEventCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperApplicationAxisEventCallback = callback;
    decoder->MapperApplicationAxisEventCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperApplicationAxisEventCallback_t ARCOMMANDS_Decoder_MapperApplicationAxisEventCb = NULL;
static void *ARCOMMANDS_Decoder_MapperApplicationAxisEventCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperApplicationAxisEventCallback (ARCOMMANDS_Decoder_MapperApplicationAxisEventCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperApplicationAxisEventCb = callback;
        ARCOMMANDS_Decoder_MapperApplicationAxisEventCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperApplicationButtonEventCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperApplicationButtonEventCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperApplicationButtonEventCallback = callback;
    decoder->MapperApplicationButtonEventCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperApplicationButtonEventCallback_t ARCOMMANDS_Decoder_MapperApplicationButtonEventCb = NULL;
static void *ARCOMMANDS_Decoder_MapperApplicationButtonEventCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperApplicationButtonEventCallback (ARCOMMANDS_Decoder_MapperApplicationButtonEventCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperApplicationButtonEventCb = callback;
        ARCOMMANDS_Decoder_MapperApplicationButtonEventCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperExpoMapItemCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperExpoMapItemCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperExpoMapItemCallback = callback;
    decoder->MapperExpoMapItemCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperExpoMapItemCallback_t ARCOMMANDS_Decoder_MapperExpoMapItemCb = NULL;
static void *ARCOMMANDS_Decoder_MapperExpoMapItemCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperExpoMapItemCallback (ARCOMMANDS_Decoder_MapperExpoMapItemCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperExpoMapItemCb = callback;
        ARCOMMANDS_Decoder_MapperExpoMapItemCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperInvertedMapItemCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperInvertedMapItemCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperInvertedMapItemCallback = callback;
    decoder->MapperInvertedMapItemCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperInvertedMapItemCallback_t ARCOMMANDS_Decoder_MapperInvertedMapItemCb = NULL;
static void *ARCOMMANDS_Decoder_MapperInvertedMapItemCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperInvertedMapItemCallback (ARCOMMANDS_Decoder_MapperInvertedMapItemCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperInvertedMapItemCb = callback;
        ARCOMMANDS_Decoder_MapperInvertedMapItemCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature MiniDrone

void ARCOMMANDS_Decoder_SetMiniDronePilotingFlatTrimCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDronePilotingFlatTrimCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDronePilotingFlatTrimCallback = callback;
    decoder->MiniDronePilotingFlatTrimCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDronePilotingFlatTrimCallback_t ARCOMMANDS_Decoder_MiniDronePilotingFlatTrimCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingFlatTrimCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingFlatTrimCallback (ARCOMMANDS_Decoder_MiniDronePilotingFlatTrimCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingFlatTrimCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingFlatTrimCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDronePilotingTakeOffCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDronePilotingTakeOffCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDronePilotingTakeOffCallback = callback;
    decoder->MiniDronePilotingTakeOffCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDronePilotingTakeOffCallback_t ARCOMMANDS_Decoder_MiniDronePilotingTakeOffCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingTakeOffCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingTakeOffCallback (ARCOMMANDS_Decoder_MiniDronePilotingTakeOffCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingTakeOffCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingTakeOffCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDronePilotingPCMDCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDronePilotingPCMDCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDronePilotingPCMDCallback = callback;
    decoder->MiniDronePilotingPCMDCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDronePilotingPCMDCallback_t ARCOMMANDS_Decoder_MiniDronePilotingPCMDCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingPCMDCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingPCMDCallback (ARCOMMANDS_Decoder_MiniDronePilotingPCMDCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingPCMDCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingPCMDCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDronePilotingLandingCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDronePilotingLandingCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDronePilotingLandingCallback = callback;
    decoder->MiniDronePilotingLandingCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDronePilotingLandingCallback_t ARCOMMANDS_Decoder_MiniDronePilotingLandingCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingLandingCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingLandingCallback (ARCOMMANDS_Decoder_MiniDronePilotingLandingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingLandingCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingLandingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDronePilotingEmergencyCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDronePilotingEmergencyCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDronePilotingEmergencyCallback = callback;
    decoder->MiniDronePilotingEmergencyCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDronePilotingEmergencyCallback_t ARCOMMANDS_Decoder_MiniDronePilotingEmergencyCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingEmergencyCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingEmergencyCallback (ARCOMMANDS_Decoder_MiniDronePilotingEmergencyCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingEmergencyCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingEmergencyCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDronePilotingAutoTakeOffModeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDronePilotingAutoTakeOffModeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDronePilotingAutoTakeOffModeCallback = callback;
    decoder->MiniDronePilotingAutoTakeOffModeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDronePilotingAutoTakeOffModeCallback_t ARCOMMANDS_Decoder_MiniDronePilotingAutoTakeOffModeCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingAutoTakeOffModeCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingAutoTakeOffModeCallback (ARCOMMANDS_Decoder_MiniDronePilotingAutoTakeOffModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingAutoTakeOffModeCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingAutoTakeOffModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDronePilotingFlyingModeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDronePilotingFlyingModeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDronePilotingFlyingModeCallback = callback;
    decoder->MiniDronePilotingFlyingModeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDronePilotingFlyingModeCallback_t ARCOMMANDS_Decoder_MiniDronePilotingFlyingModeCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingFlyingModeCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingFlyingModeCallback (ARCOMMANDS_Decoder_MiniDronePilotingFlyingModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingFlyingModeCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingFlyingModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDronePilotingPlaneGearBoxCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDronePilotingPlaneGearBoxCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDronePilotingPlaneGearBoxCallback = callback;
    decoder->MiniDronePilotingPlaneGearBoxCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDronePilotingPlaneGearBoxCallback_t ARCOMMANDS_Decoder_MiniDronePilotingPlaneGearBoxCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingPlaneGearBoxCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingPlaneGearBoxCallback (ARCOMMANDS_Decoder_MiniDronePilotingPlaneGearBoxCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingPlaneGearBoxCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingPlaneGearBoxCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneAnimationsFlipCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneAnimationsFlipCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneAnimationsFlipCallback = callback;
    decoder->MiniDroneAnimationsFlipCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneAnimationsFlipCallback_t ARCOMMANDS_Decoder_MiniDroneAnimationsFlipCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneAnimationsFlipCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneAnimationsFlipCallback (ARCOMMANDS_Decoder_MiniDroneAnimationsFlipCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneAnimationsFlipCb = callback;
        ARCOMMANDS_Decoder_MiniDroneAnimationsFlipCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneAnimationsCapCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneAnimationsCapCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneAnimationsCapCallback = callback;
    decoder->MiniDroneAnimationsCapCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneAnimationsCapCallback_t ARCOMMANDS_Decoder_MiniDroneAnimationsCapCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneAnimationsCapCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneAnimationsCapCallback (ARCOMMANDS_Decoder_MiniDroneAnimationsCapCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneAnimationsCapCb = callback;
        ARCOMMANDS_Decoder_MiniDroneAnimationsCapCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneMediaRecordPictureCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneMediaRecordPictureCallback = callback;
    decoder->MiniDroneMediaRecordPictureCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureCallback_t ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneMediaRecordPictureCallback (ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureCb = callback;
        ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneMediaRecordPictureV2Cb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureV2Callback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneMediaRecordPictureV2Callback = callback;
    decoder->MiniDroneMediaRecordPictureV2Custom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureV2Callback_t ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureV2Cb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureV2Custom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneMediaRecordPictureV2Callback (ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureV2Cb = callback;
        ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsMaxAltitudeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxAltitudeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDronePilotingSettingsMaxAltitudeCallback = callback;
    decoder->MiniDronePilotingSettingsMaxAltitudeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxAltitudeCallback_t ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxAltitudeCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxAltitudeCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsMaxAltitudeCallback (ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxAltitudeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxAltitudeCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxAltitudeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsMaxTiltCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxTiltCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDronePilotingSettingsMaxTiltCallback = callback;
    decoder->MiniDronePilotingSettingsMaxTiltCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxTiltCallback_t ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxTiltCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxTiltCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsMaxTiltCallback (ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxTiltCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxTiltCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxTiltCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsPlaneModePitchCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDronePilotingSettingsPlaneModePitchCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDronePilotingSettingsPlaneModePitchCallback = callback;
    decoder->MiniDronePilotingSettingsPlaneModePitchCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDronePilotingSettingsPlaneModePitchCallback_t ARCOMMANDS_Decoder_MiniDronePilotingSettingsPlaneModePitchCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingSettingsPlaneModePitchCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsPlaneModePitchCallback (ARCOMMANDS_Decoder_MiniDronePilotingSettingsPlaneModePitchCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingSettingsPlaneModePitchCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingSettingsPlaneModePitchCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsMaxVerticalSpeedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxVerticalSpeedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneSpeedSettingsMaxVerticalSpeedCallback = callback;
    decoder->MiniDroneSpeedSettingsMaxVerticalSpeedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxVerticalSpeedCallback_t ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxVerticalSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxVerticalSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsMaxVerticalSpeedCallback (ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxVerticalSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxVerticalSpeedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxVerticalSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsMaxRotationSpeedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxRotationSpeedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneSpeedSettingsMaxRotationSpeedCallback = callback;
    decoder->MiniDroneSpeedSettingsMaxRotationSpeedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxRotationSpeedCallback_t ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxRotationSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxRotationSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsMaxRotationSpeedCallback (ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxRotationSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxRotationSpeedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxRotationSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsWheelsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsWheelsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneSpeedSettingsWheelsCallback = callback;
    decoder->MiniDroneSpeedSettingsWheelsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneSpeedSettingsWheelsCallback_t ARCOMMANDS_Decoder_MiniDroneSpeedSettingsWheelsCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSpeedSettingsWheelsCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsWheelsCallback (ARCOMMANDS_Decoder_MiniDroneSpeedSettingsWheelsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsWheelsCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsWheelsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsMaxHorizontalSpeedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxHorizontalSpeedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneSpeedSettingsMaxHorizontalSpeedCallback = callback;
    decoder->MiniDroneSpeedSettingsMaxHorizontalSpeedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxHorizontalSpeedCallback_t ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxHorizontalSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxHorizontalSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsMaxHorizontalSpeedCallback (ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxHorizontalSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxHorizontalSpeedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxHorizontalSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsMaxPlaneModeRotationSpeedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxPlaneModeRotationSpeedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneSpeedSettingsMaxPlaneModeRotationSpeedCallback = callback;
    decoder->MiniDroneSpeedSettingsMaxPlaneModeRotationSpeedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxPlaneModeRotationSpeedCallback_t ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxPlaneModeRotationSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxPlaneModeRotationSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsMaxPlaneModeRotationSpeedCallback (ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxPlaneModeRotationSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxPlaneModeRotationSpeedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxPlaneModeRotationSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneSettingsCutOutModeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneSettingsCutOutModeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneSettingsCutOutModeCallback = callback;
    decoder->MiniDroneSettingsCutOutModeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneSettingsCutOutModeCallback_t ARCOMMANDS_Decoder_MiniDroneSettingsCutOutModeCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSettingsCutOutModeCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSettingsCutOutModeCallback (ARCOMMANDS_Decoder_MiniDroneSettingsCutOutModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSettingsCutOutModeCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSettingsCutOutModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneGPSControllerLatitudeForRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneGPSControllerLatitudeForRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneGPSControllerLatitudeForRunCallback = callback;
    decoder->MiniDroneGPSControllerLatitudeForRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneGPSControllerLatitudeForRunCallback_t ARCOMMANDS_Decoder_MiniDroneGPSControllerLatitudeForRunCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneGPSControllerLatitudeForRunCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneGPSControllerLatitudeForRunCallback (ARCOMMANDS_Decoder_MiniDroneGPSControllerLatitudeForRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneGPSControllerLatitudeForRunCb = callback;
        ARCOMMANDS_Decoder_MiniDroneGPSControllerLatitudeForRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneGPSControllerLongitudeForRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneGPSControllerLongitudeForRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneGPSControllerLongitudeForRunCallback = callback;
    decoder->MiniDroneGPSControllerLongitudeForRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneGPSControllerLongitudeForRunCallback_t ARCOMMANDS_Decoder_MiniDroneGPSControllerLongitudeForRunCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneGPSControllerLongitudeForRunCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneGPSControllerLongitudeForRunCallback (ARCOMMANDS_Decoder_MiniDroneGPSControllerLongitudeForRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneGPSControllerLongitudeForRunCb = callback;
        ARCOMMANDS_Decoder_MiniDroneGPSControllerLongitudeForRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneConfigurationControllerTypeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneConfigurationControllerTypeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneConfigurationControllerTypeCallback = callback;
    decoder->MiniDroneConfigurationControllerTypeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneConfigurationControllerTypeCallback_t ARCOMMANDS_Decoder_MiniDroneConfigurationControllerTypeCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneConfigurationControllerTypeCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneConfigurationControllerTypeCallback (ARCOMMANDS_Decoder_MiniDroneConfigurationControllerTypeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneConfigurationControllerTypeCb = callback;
        ARCOMMANDS_Decoder_MiniDroneConfigurationControllerTypeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneConfigurationControllerNameCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneConfigurationControllerNameCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneConfigurationControllerNameCallback = callback;
    decoder->MiniDroneConfigurationControllerNameCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneConfigurationControllerNameCallback_t ARCOMMANDS_Decoder_MiniDroneConfigurationControllerNameCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneConfigurationControllerNameCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneConfigurationControllerNameCallback (ARCOMMANDS_Decoder_MiniDroneConfigurationControllerNameCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneConfigurationControllerNameCb = callback;
        ARCOMMANDS_Decoder_MiniDroneConfigurationControllerNameCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryLightControlCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneUsbAccessoryLightControlCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneUsbAccessoryLightControlCallback = callback;
    decoder->MiniDroneUsbAccessoryLightControlCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneUsbAccessoryLightControlCallback_t ARCOMMANDS_Decoder_MiniDroneUsbAccessoryLightControlCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneUsbAccessoryLightControlCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryLightControlCallback (ARCOMMANDS_Decoder_MiniDroneUsbAccessoryLightControlCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneUsbAccessoryLightControlCb = callback;
        ARCOMMANDS_Decoder_MiniDroneUsbAccessoryLightControlCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryClawControlCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneUsbAccessoryClawControlCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneUsbAccessoryClawControlCallback = callback;
    decoder->MiniDroneUsbAccessoryClawControlCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneUsbAccessoryClawControlCallback_t ARCOMMANDS_Decoder_MiniDroneUsbAccessoryClawControlCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneUsbAccessoryClawControlCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryClawControlCallback (ARCOMMANDS_Decoder_MiniDroneUsbAccessoryClawControlCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneUsbAccessoryClawControlCb = callback;
        ARCOMMANDS_Decoder_MiniDroneUsbAccessoryClawControlCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryGunControlCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneUsbAccessoryGunControlCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneUsbAccessoryGunControlCallback = callback;
    decoder->MiniDroneUsbAccessoryGunControlCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneUsbAccessoryGunControlCallback_t ARCOMMANDS_Decoder_MiniDroneUsbAccessoryGunControlCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneUsbAccessoryGunControlCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryGunControlCallback (ARCOMMANDS_Decoder_MiniDroneUsbAccessoryGunControlCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneUsbAccessoryGunControlCb = callback;
        ARCOMMANDS_Decoder_MiniDroneUsbAccessoryGunControlCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneRemoteControllerSetPairedRemoteCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneRemoteControllerSetPairedRemoteCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneRemoteControllerSetPairedRemoteCallback = callback;
    decoder->MiniDroneRemoteControllerSetPairedRemoteCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneRemoteControllerSetPairedRemoteCallback_t ARCOMMANDS_Decoder_MiniDroneRemoteControllerSetPairedRemoteCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneRemoteControllerSetPairedRemoteCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneRemoteControllerSetPairedRemoteCallback (ARCOMMANDS_Decoder_MiniDroneRemoteControllerSetPairedRemoteCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneRemoteControllerSetPairedRemoteCb = callback;
        ARCOMMANDS_Decoder_MiniDroneRemoteControllerSetPairedRemoteCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlatTrimChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDronePilotingStateFlatTrimChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDronePilotingStateFlatTrimChangedCallback = callback;
    decoder->MiniDronePilotingStateFlatTrimChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDronePilotingStateFlatTrimChangedCallback_t ARCOMMANDS_Decoder_MiniDronePilotingStateFlatTrimChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingStateFlatTrimChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlatTrimChangedCallback (ARCOMMANDS_Decoder_MiniDronePilotingStateFlatTrimChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingStateFlatTrimChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingStateFlatTrimChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlyingStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDronePilotingStateFlyingStateChangedCallback = callback;
    decoder->MiniDronePilotingStateFlyingStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingStateChangedCallback_t ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlyingStateChangedCallback (ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingStateChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDronePilotingStateAlertStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDronePilotingStateAlertStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDronePilotingStateAlertStateChangedCallback = callback;
    decoder->MiniDronePilotingStateAlertStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDronePilotingStateAlertStateChangedCallback_t ARCOMMANDS_Decoder_MiniDronePilotingStateAlertStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingStateAlertStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingStateAlertStateChangedCallback (ARCOMMANDS_Decoder_MiniDronePilotingStateAlertStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingStateAlertStateChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingStateAlertStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDronePilotingStateAutoTakeOffModeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDronePilotingStateAutoTakeOffModeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDronePilotingStateAutoTakeOffModeChangedCallback = callback;
    decoder->MiniDronePilotingStateAutoTakeOffModeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDronePilotingStateAutoTakeOffModeChangedCallback_t ARCOMMANDS_Decoder_MiniDronePilotingStateAutoTakeOffModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingStateAutoTakeOffModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingStateAutoTakeOffModeChangedCallback (ARCOMMANDS_Decoder_MiniDronePilotingStateAutoTakeOffModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingStateAutoTakeOffModeChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingStateAutoTakeOffModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlyingModeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingModeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDronePilotingStateFlyingModeChangedCallback = callback;
    decoder->MiniDronePilotingStateFlyingModeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingModeChangedCallback_t ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlyingModeChangedCallback (ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingModeChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDronePilotingStatePlaneGearBoxChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDronePilotingStatePlaneGearBoxChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDronePilotingStatePlaneGearBoxChangedCallback = callback;
    decoder->MiniDronePilotingStatePlaneGearBoxChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDronePilotingStatePlaneGearBoxChangedCallback_t ARCOMMANDS_Decoder_MiniDronePilotingStatePlaneGearBoxChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingStatePlaneGearBoxChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingStatePlaneGearBoxChangedCallback (ARCOMMANDS_Decoder_MiniDronePilotingStatePlaneGearBoxChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingStatePlaneGearBoxChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingStatePlaneGearBoxChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneMediaRecordStatePictureStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneMediaRecordStatePictureStateChangedCallback = callback;
    decoder->MiniDroneMediaRecordStatePictureStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedCallback_t ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneMediaRecordStatePictureStateChangedCallback (ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneMediaRecordStatePictureStateChangedV2Cb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedV2Callback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneMediaRecordStatePictureStateChangedV2Callback = callback;
    decoder->MiniDroneMediaRecordStatePictureStateChangedV2Custom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedV2Callback_t ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedV2Cb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedV2Custom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneMediaRecordStatePictureStateChangedV2Callback (ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedV2Cb = callback;
        ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneMediaRecordEventPictureEventChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneMediaRecordEventPictureEventChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneMediaRecordEventPictureEventChangedCallback = callback;
    decoder->MiniDroneMediaRecordEventPictureEventChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneMediaRecordEventPictureEventChangedCallback_t ARCOMMANDS_Decoder_MiniDroneMediaRecordEventPictureEventChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneMediaRecordEventPictureEventChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneMediaRecordEventPictureEventChangedCallback (ARCOMMANDS_Decoder_MiniDroneMediaRecordEventPictureEventChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneMediaRecordEventPictureEventChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneMediaRecordEventPictureEventChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStateMaxAltitudeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxAltitudeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDronePilotingSettingsStateMaxAltitudeChangedCallback = callback;
    decoder->MiniDronePilotingSettingsStateMaxAltitudeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxAltitudeChangedCallback_t ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxAltitudeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxAltitudeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStateMaxAltitudeChangedCallback (ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxAltitudeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxAltitudeChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxAltitudeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStateMaxTiltChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxTiltChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDronePilotingSettingsStateMaxTiltChangedCallback = callback;
    decoder->MiniDronePilotingSettingsStateMaxTiltChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxTiltChangedCallback_t ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxTiltChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxTiltChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStateMaxTiltChangedCallback (ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxTiltChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxTiltChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxTiltChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStatePlaneModePitchChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDronePilotingSettingsStatePlaneModePitchChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDronePilotingSettingsStatePlaneModePitchChangedCallback = callback;
    decoder->MiniDronePilotingSettingsStatePlaneModePitchChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDronePilotingSettingsStatePlaneModePitchChangedCallback_t ARCOMMANDS_Decoder_MiniDronePilotingSettingsStatePlaneModePitchChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDronePilotingSettingsStatePlaneModePitchChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStatePlaneModePitchChangedCallback (ARCOMMANDS_Decoder_MiniDronePilotingSettingsStatePlaneModePitchChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDronePilotingSettingsStatePlaneModePitchChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDronePilotingSettingsStatePlaneModePitchChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCallback = callback;
    decoder->MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCallback_t ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCallback (ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxRotationSpeedChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCallback = callback;
    decoder->MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCallback_t ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxRotationSpeedChangedCallback (ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateWheelsChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateWheelsChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneSpeedSettingsStateWheelsChangedCallback = callback;
    decoder->MiniDroneSpeedSettingsStateWheelsChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateWheelsChangedCallback_t ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateWheelsChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateWheelsChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateWheelsChangedCallback (ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateWheelsChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateWheelsChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateWheelsChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCallback = callback;
    decoder->MiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCallback_t ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCallback (ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCallback = callback;
    decoder->MiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCallback_t ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCallback (ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneSettingsStateProductMotorsVersionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneSettingsStateProductMotorsVersionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneSettingsStateProductMotorsVersionChangedCallback = callback;
    decoder->MiniDroneSettingsStateProductMotorsVersionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneSettingsStateProductMotorsVersionChangedCallback_t ARCOMMANDS_Decoder_MiniDroneSettingsStateProductMotorsVersionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSettingsStateProductMotorsVersionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSettingsStateProductMotorsVersionChangedCallback (ARCOMMANDS_Decoder_MiniDroneSettingsStateProductMotorsVersionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSettingsStateProductMotorsVersionChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSettingsStateProductMotorsVersionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneSettingsStateProductInertialVersionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneSettingsStateProductInertialVersionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneSettingsStateProductInertialVersionChangedCallback = callback;
    decoder->MiniDroneSettingsStateProductInertialVersionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneSettingsStateProductInertialVersionChangedCallback_t ARCOMMANDS_Decoder_MiniDroneSettingsStateProductInertialVersionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSettingsStateProductInertialVersionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSettingsStateProductInertialVersionChangedCallback (ARCOMMANDS_Decoder_MiniDroneSettingsStateProductInertialVersionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSettingsStateProductInertialVersionChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSettingsStateProductInertialVersionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneSettingsStateCutOutModeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneSettingsStateCutOutModeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneSettingsStateCutOutModeChangedCallback = callback;
    decoder->MiniDroneSettingsStateCutOutModeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneSettingsStateCutOutModeChangedCallback_t ARCOMMANDS_Decoder_MiniDroneSettingsStateCutOutModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneSettingsStateCutOutModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneSettingsStateCutOutModeChangedCallback (ARCOMMANDS_Decoder_MiniDroneSettingsStateCutOutModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneSettingsStateCutOutModeChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneSettingsStateCutOutModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneFloodControlStateFloodControlChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneFloodControlStateFloodControlChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneFloodControlStateFloodControlChangedCallback = callback;
    decoder->MiniDroneFloodControlStateFloodControlChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneFloodControlStateFloodControlChangedCallback_t ARCOMMANDS_Decoder_MiniDroneFloodControlStateFloodControlChangedCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneFloodControlStateFloodControlChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneFloodControlStateFloodControlChangedCallback (ARCOMMANDS_Decoder_MiniDroneFloodControlStateFloodControlChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneFloodControlStateFloodControlChangedCb = callback;
        ARCOMMANDS_Decoder_MiniDroneFloodControlStateFloodControlChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryStateLightStateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateLightStateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneUsbAccessoryStateLightStateCallback = callback;
    decoder->MiniDroneUsbAccessoryStateLightStateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateLightStateCallback_t ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateLightStateCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateLightStateCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryStateLightStateCallback (ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateLightStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateLightStateCb = callback;
        ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateLightStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryStateClawStateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateClawStateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneUsbAccessoryStateClawStateCallback = callback;
    decoder->MiniDroneUsbAccessoryStateClawStateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateClawStateCallback_t ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateClawStateCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateClawStateCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryStateClawStateCallback (ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateClawStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateClawStateCb = callback;
        ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateClawStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryStateGunStateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateGunStateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneUsbAccessoryStateGunStateCallback = callback;
    decoder->MiniDroneUsbAccessoryStateGunStateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateGunStateCallback_t ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateGunStateCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateGunStateCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryStateGunStateCallback (ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateGunStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateGunStateCb = callback;
        ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateGunStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMiniDroneNavigationDataStateDronePositionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MiniDroneNavigationDataStateDronePositionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MiniDroneNavigationDataStateDronePositionCallback = callback;
    decoder->MiniDroneNavigationDataStateDronePositionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MiniDroneNavigationDataStateDronePositionCallback_t ARCOMMANDS_Decoder_MiniDroneNavigationDataStateDronePositionCb = NULL;
static void *ARCOMMANDS_Decoder_MiniDroneNavigationDataStateDronePositionCustom = NULL;
void ARCOMMANDS_Decoder_SetMiniDroneNavigationDataStateDronePositionCallback (ARCOMMANDS_Decoder_MiniDroneNavigationDataStateDronePositionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MiniDroneNavigationDataStateDronePositionCb = callback;
        ARCOMMANDS_Decoder_MiniDroneNavigationDataStateDronePositionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature powerup

void ARCOMMANDS_Decoder_SetPowerupPilotingPCMDCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupPilotingPCMDCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupPilotingPCMDCallback = callback;
    decoder->PowerupPilotingPCMDCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupPilotingPCMDCallback_t ARCOMMANDS_Decoder_PowerupPilotingPCMDCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupPilotingPCMDCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupPilotingPCMDCallback (ARCOMMANDS_Decoder_PowerupPilotingPCMDCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupPilotingPCMDCb = callback;
        ARCOMMANDS_Decoder_PowerupPilotingPCMDCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupPilotingUserTakeOffCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupPilotingUserTakeOffCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupPilotingUserTakeOffCallback = callback;
    decoder->PowerupPilotingUserTakeOffCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupPilotingUserTakeOffCallback_t ARCOMMANDS_Decoder_PowerupPilotingUserTakeOffCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupPilotingUserTakeOffCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupPilotingUserTakeOffCallback (ARCOMMANDS_Decoder_PowerupPilotingUserTakeOffCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupPilotingUserTakeOffCb = callback;
        ARCOMMANDS_Decoder_PowerupPilotingUserTakeOffCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupPilotingMotorModeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupPilotingMotorModeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupPilotingMotorModeCallback = callback;
    decoder->PowerupPilotingMotorModeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupPilotingMotorModeCallback_t ARCOMMANDS_Decoder_PowerupPilotingMotorModeCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupPilotingMotorModeCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupPilotingMotorModeCallback (ARCOMMANDS_Decoder_PowerupPilotingMotorModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupPilotingMotorModeCb = callback;
        ARCOMMANDS_Decoder_PowerupPilotingMotorModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupPilotingSettingsSetCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupPilotingSettingsSetCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupPilotingSettingsSetCallback = callback;
    decoder->PowerupPilotingSettingsSetCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupPilotingSettingsSetCallback_t ARCOMMANDS_Decoder_PowerupPilotingSettingsSetCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupPilotingSettingsSetCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupPilotingSettingsSetCallback (ARCOMMANDS_Decoder_PowerupPilotingSettingsSetCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupPilotingSettingsSetCb = callback;
        ARCOMMANDS_Decoder_PowerupPilotingSettingsSetCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupMediaRecordPictureV2Cb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupMediaRecordPictureV2Callback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupMediaRecordPictureV2Callback = callback;
    decoder->PowerupMediaRecordPictureV2Custom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupMediaRecordPictureV2Callback_t ARCOMMANDS_Decoder_PowerupMediaRecordPictureV2Cb = NULL;
static void *ARCOMMANDS_Decoder_PowerupMediaRecordPictureV2Custom = NULL;
void ARCOMMANDS_Decoder_SetPowerupMediaRecordPictureV2Callback (ARCOMMANDS_Decoder_PowerupMediaRecordPictureV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupMediaRecordPictureV2Cb = callback;
        ARCOMMANDS_Decoder_PowerupMediaRecordPictureV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupMediaRecordVideoV2Cb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupMediaRecordVideoV2Callback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupMediaRecordVideoV2Callback = callback;
    decoder->PowerupMediaRecordVideoV2Custom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupMediaRecordVideoV2Callback_t ARCOMMANDS_Decoder_PowerupMediaRecordVideoV2Cb = NULL;
static void *ARCOMMANDS_Decoder_PowerupMediaRecordVideoV2Custom = NULL;
void ARCOMMANDS_Decoder_SetPowerupMediaRecordVideoV2Callback (ARCOMMANDS_Decoder_PowerupMediaRecordVideoV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupMediaRecordVideoV2Cb = callback;
        ARCOMMANDS_Decoder_PowerupMediaRecordVideoV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupNetworkSettingsWifiSelectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupNetworkSettingsWifiSelectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupNetworkSettingsWifiSelectionCallback = callback;
    decoder->PowerupNetworkSettingsWifiSelectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupNetworkSettingsWifiSelectionCallback_t ARCOMMANDS_Decoder_PowerupNetworkSettingsWifiSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupNetworkSettingsWifiSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupNetworkSettingsWifiSelectionCallback (ARCOMMANDS_Decoder_PowerupNetworkSettingsWifiSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupNetworkSettingsWifiSelectionCb = callback;
        ARCOMMANDS_Decoder_PowerupNetworkSettingsWifiSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupNetworkWifiScanCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupNetworkWifiScanCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupNetworkWifiScanCallback = callback;
    decoder->PowerupNetworkWifiScanCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupNetworkWifiScanCallback_t ARCOMMANDS_Decoder_PowerupNetworkWifiScanCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupNetworkWifiScanCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupNetworkWifiScanCallback (ARCOMMANDS_Decoder_PowerupNetworkWifiScanCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupNetworkWifiScanCb = callback;
        ARCOMMANDS_Decoder_PowerupNetworkWifiScanCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupNetworkWifiAuthChannelCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupNetworkWifiAuthChannelCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupNetworkWifiAuthChannelCallback = callback;
    decoder->PowerupNetworkWifiAuthChannelCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupNetworkWifiAuthChannelCallback_t ARCOMMANDS_Decoder_PowerupNetworkWifiAuthChannelCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupNetworkWifiAuthChannelCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupNetworkWifiAuthChannelCallback (ARCOMMANDS_Decoder_PowerupNetworkWifiAuthChannelCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupNetworkWifiAuthChannelCb = callback;
        ARCOMMANDS_Decoder_PowerupNetworkWifiAuthChannelCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupMediaStreamingVideoEnableCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupMediaStreamingVideoEnableCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupMediaStreamingVideoEnableCallback = callback;
    decoder->PowerupMediaStreamingVideoEnableCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupMediaStreamingVideoEnableCallback_t ARCOMMANDS_Decoder_PowerupMediaStreamingVideoEnableCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupMediaStreamingVideoEnableCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupMediaStreamingVideoEnableCallback (ARCOMMANDS_Decoder_PowerupMediaStreamingVideoEnableCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupMediaStreamingVideoEnableCb = callback;
        ARCOMMANDS_Decoder_PowerupMediaStreamingVideoEnableCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupVideoSettingsAutorecordCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupVideoSettingsAutorecordCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupVideoSettingsAutorecordCallback = callback;
    decoder->PowerupVideoSettingsAutorecordCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupVideoSettingsAutorecordCallback_t ARCOMMANDS_Decoder_PowerupVideoSettingsAutorecordCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupVideoSettingsAutorecordCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupVideoSettingsAutorecordCallback (ARCOMMANDS_Decoder_PowerupVideoSettingsAutorecordCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupVideoSettingsAutorecordCb = callback;
        ARCOMMANDS_Decoder_PowerupVideoSettingsAutorecordCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupVideoSettingsVideoModeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupVideoSettingsVideoModeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupVideoSettingsVideoModeCallback = callback;
    decoder->PowerupVideoSettingsVideoModeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupVideoSettingsVideoModeCallback_t ARCOMMANDS_Decoder_PowerupVideoSettingsVideoModeCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupVideoSettingsVideoModeCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupVideoSettingsVideoModeCallback (ARCOMMANDS_Decoder_PowerupVideoSettingsVideoModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupVideoSettingsVideoModeCb = callback;
        ARCOMMANDS_Decoder_PowerupVideoSettingsVideoModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupSoundsBuzzCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupSoundsBuzzCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupSoundsBuzzCallback = callback;
    decoder->PowerupSoundsBuzzCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupSoundsBuzzCallback_t ARCOMMANDS_Decoder_PowerupSoundsBuzzCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupSoundsBuzzCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupSoundsBuzzCallback (ARCOMMANDS_Decoder_PowerupSoundsBuzzCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupSoundsBuzzCb = callback;
        ARCOMMANDS_Decoder_PowerupSoundsBuzzCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupPilotingStateAlertStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupPilotingStateAlertStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupPilotingStateAlertStateChangedCallback = callback;
    decoder->PowerupPilotingStateAlertStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupPilotingStateAlertStateChangedCallback_t ARCOMMANDS_Decoder_PowerupPilotingStateAlertStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupPilotingStateAlertStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupPilotingStateAlertStateChangedCallback (ARCOMMANDS_Decoder_PowerupPilotingStateAlertStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupPilotingStateAlertStateChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupPilotingStateAlertStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupPilotingStateFlyingStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupPilotingStateFlyingStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupPilotingStateFlyingStateChangedCallback = callback;
    decoder->PowerupPilotingStateFlyingStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupPilotingStateFlyingStateChangedCallback_t ARCOMMANDS_Decoder_PowerupPilotingStateFlyingStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupPilotingStateFlyingStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupPilotingStateFlyingStateChangedCallback (ARCOMMANDS_Decoder_PowerupPilotingStateFlyingStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupPilotingStateFlyingStateChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupPilotingStateFlyingStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupPilotingStateMotorModeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupPilotingStateMotorModeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupPilotingStateMotorModeChangedCallback = callback;
    decoder->PowerupPilotingStateMotorModeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupPilotingStateMotorModeChangedCallback_t ARCOMMANDS_Decoder_PowerupPilotingStateMotorModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupPilotingStateMotorModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupPilotingStateMotorModeChangedCallback (ARCOMMANDS_Decoder_PowerupPilotingStateMotorModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupPilotingStateMotorModeChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupPilotingStateMotorModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupPilotingStateAttitudeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupPilotingStateAttitudeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupPilotingStateAttitudeChangedCallback = callback;
    decoder->PowerupPilotingStateAttitudeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupPilotingStateAttitudeChangedCallback_t ARCOMMANDS_Decoder_PowerupPilotingStateAttitudeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupPilotingStateAttitudeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupPilotingStateAttitudeChangedCallback (ARCOMMANDS_Decoder_PowerupPilotingStateAttitudeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupPilotingStateAttitudeChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupPilotingStateAttitudeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupPilotingStateAltitudeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupPilotingStateAltitudeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupPilotingStateAltitudeChangedCallback = callback;
    decoder->PowerupPilotingStateAltitudeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupPilotingStateAltitudeChangedCallback_t ARCOMMANDS_Decoder_PowerupPilotingStateAltitudeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupPilotingStateAltitudeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupPilotingStateAltitudeChangedCallback (ARCOMMANDS_Decoder_PowerupPilotingStateAltitudeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupPilotingStateAltitudeChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupPilotingStateAltitudeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupPilotingSettingsStateSettingChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupPilotingSettingsStateSettingChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupPilotingSettingsStateSettingChangedCallback = callback;
    decoder->PowerupPilotingSettingsStateSettingChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupPilotingSettingsStateSettingChangedCallback_t ARCOMMANDS_Decoder_PowerupPilotingSettingsStateSettingChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupPilotingSettingsStateSettingChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupPilotingSettingsStateSettingChangedCallback (ARCOMMANDS_Decoder_PowerupPilotingSettingsStateSettingChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupPilotingSettingsStateSettingChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupPilotingSettingsStateSettingChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupMediaRecordStatePictureStateChangedV2Cb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupMediaRecordStatePictureStateChangedV2Callback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupMediaRecordStatePictureStateChangedV2Callback = callback;
    decoder->PowerupMediaRecordStatePictureStateChangedV2Custom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupMediaRecordStatePictureStateChangedV2Callback_t ARCOMMANDS_Decoder_PowerupMediaRecordStatePictureStateChangedV2Cb = NULL;
static void *ARCOMMANDS_Decoder_PowerupMediaRecordStatePictureStateChangedV2Custom = NULL;
void ARCOMMANDS_Decoder_SetPowerupMediaRecordStatePictureStateChangedV2Callback (ARCOMMANDS_Decoder_PowerupMediaRecordStatePictureStateChangedV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupMediaRecordStatePictureStateChangedV2Cb = callback;
        ARCOMMANDS_Decoder_PowerupMediaRecordStatePictureStateChangedV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupMediaRecordStateVideoStateChangedV2Cb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupMediaRecordStateVideoStateChangedV2Callback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupMediaRecordStateVideoStateChangedV2Callback = callback;
    decoder->PowerupMediaRecordStateVideoStateChangedV2Custom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupMediaRecordStateVideoStateChangedV2Callback_t ARCOMMANDS_Decoder_PowerupMediaRecordStateVideoStateChangedV2Cb = NULL;
static void *ARCOMMANDS_Decoder_PowerupMediaRecordStateVideoStateChangedV2Custom = NULL;
void ARCOMMANDS_Decoder_SetPowerupMediaRecordStateVideoStateChangedV2Callback (ARCOMMANDS_Decoder_PowerupMediaRecordStateVideoStateChangedV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupMediaRecordStateVideoStateChangedV2Cb = callback;
        ARCOMMANDS_Decoder_PowerupMediaRecordStateVideoStateChangedV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupMediaRecordEventPictureEventChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupMediaRecordEventPictureEventChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupMediaRecordEventPictureEventChangedCallback = callback;
    decoder->PowerupMediaRecordEventPictureEventChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupMediaRecordEventPictureEventChangedCallback_t ARCOMMANDS_Decoder_PowerupMediaRecordEventPictureEventChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupMediaRecordEventPictureEventChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupMediaRecordEventPictureEventChangedCallback (ARCOMMANDS_Decoder_PowerupMediaRecordEventPictureEventChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupMediaRecordEventPictureEventChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupMediaRecordEventPictureEventChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupMediaRecordEventVideoEventChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupMediaRecordEventVideoEventChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupMediaRecordEventVideoEventChangedCallback = callback;
    decoder->PowerupMediaRecordEventVideoEventChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupMediaRecordEventVideoEventChangedCallback_t ARCOMMANDS_Decoder_PowerupMediaRecordEventVideoEventChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupMediaRecordEventVideoEventChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupMediaRecordEventVideoEventChangedCallback (ARCOMMANDS_Decoder_PowerupMediaRecordEventVideoEventChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupMediaRecordEventVideoEventChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupMediaRecordEventVideoEventChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupNetworkSettingsStateWifiSelectionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupNetworkSettingsStateWifiSelectionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupNetworkSettingsStateWifiSelectionChangedCallback = callback;
    decoder->PowerupNetworkSettingsStateWifiSelectionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupNetworkSettingsStateWifiSelectionChangedCallback_t ARCOMMANDS_Decoder_PowerupNetworkSettingsStateWifiSelectionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupNetworkSettingsStateWifiSelectionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupNetworkSettingsStateWifiSelectionChangedCallback (ARCOMMANDS_Decoder_PowerupNetworkSettingsStateWifiSelectionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupNetworkSettingsStateWifiSelectionChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupNetworkSettingsStateWifiSelectionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupNetworkStateWifiScanListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupNetworkStateWifiScanListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupNetworkStateWifiScanListChangedCallback = callback;
    decoder->PowerupNetworkStateWifiScanListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupNetworkStateWifiScanListChangedCallback_t ARCOMMANDS_Decoder_PowerupNetworkStateWifiScanListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupNetworkStateWifiScanListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupNetworkStateWifiScanListChangedCallback (ARCOMMANDS_Decoder_PowerupNetworkStateWifiScanListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupNetworkStateWifiScanListChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupNetworkStateWifiScanListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupNetworkStateAllWifiScanChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiScanChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupNetworkStateAllWifiScanChangedCallback = callback;
    decoder->PowerupNetworkStateAllWifiScanChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiScanChangedCallback_t ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiScanChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiScanChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupNetworkStateAllWifiScanChangedCallback (ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiScanChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiScanChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiScanChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupNetworkStateWifiAuthChannelListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupNetworkStateWifiAuthChannelListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupNetworkStateWifiAuthChannelListChangedCallback = callback;
    decoder->PowerupNetworkStateWifiAuthChannelListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupNetworkStateWifiAuthChannelListChangedCallback_t ARCOMMANDS_Decoder_PowerupNetworkStateWifiAuthChannelListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupNetworkStateWifiAuthChannelListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupNetworkStateWifiAuthChannelListChangedCallback (ARCOMMANDS_Decoder_PowerupNetworkStateWifiAuthChannelListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupNetworkStateWifiAuthChannelListChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupNetworkStateWifiAuthChannelListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupNetworkStateAllWifiAuthChannelChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiAuthChannelChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupNetworkStateAllWifiAuthChannelChangedCallback = callback;
    decoder->PowerupNetworkStateAllWifiAuthChannelChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiAuthChannelChangedCallback_t ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiAuthChannelChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiAuthChannelChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupNetworkStateAllWifiAuthChannelChangedCallback (ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiAuthChannelChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiAuthChannelChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiAuthChannelChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupNetworkStateLinkQualityChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupNetworkStateLinkQualityChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupNetworkStateLinkQualityChangedCallback = callback;
    decoder->PowerupNetworkStateLinkQualityChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupNetworkStateLinkQualityChangedCallback_t ARCOMMANDS_Decoder_PowerupNetworkStateLinkQualityChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupNetworkStateLinkQualityChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupNetworkStateLinkQualityChangedCallback (ARCOMMANDS_Decoder_PowerupNetworkStateLinkQualityChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupNetworkStateLinkQualityChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupNetworkStateLinkQualityChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupMediaStreamingStateVideoEnableChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupMediaStreamingStateVideoEnableChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupMediaStreamingStateVideoEnableChangedCallback = callback;
    decoder->PowerupMediaStreamingStateVideoEnableChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupMediaStreamingStateVideoEnableChangedCallback_t ARCOMMANDS_Decoder_PowerupMediaStreamingStateVideoEnableChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupMediaStreamingStateVideoEnableChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupMediaStreamingStateVideoEnableChangedCallback (ARCOMMANDS_Decoder_PowerupMediaStreamingStateVideoEnableChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupMediaStreamingStateVideoEnableChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupMediaStreamingStateVideoEnableChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupVideoSettingsStateAutorecordChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupVideoSettingsStateAutorecordChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupVideoSettingsStateAutorecordChangedCallback = callback;
    decoder->PowerupVideoSettingsStateAutorecordChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupVideoSettingsStateAutorecordChangedCallback_t ARCOMMANDS_Decoder_PowerupVideoSettingsStateAutorecordChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupVideoSettingsStateAutorecordChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupVideoSettingsStateAutorecordChangedCallback (ARCOMMANDS_Decoder_PowerupVideoSettingsStateAutorecordChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupVideoSettingsStateAutorecordChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupVideoSettingsStateAutorecordChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupVideoSettingsStateVideoModeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupVideoSettingsStateVideoModeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupVideoSettingsStateVideoModeChangedCallback = callback;
    decoder->PowerupVideoSettingsStateVideoModeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupVideoSettingsStateVideoModeChangedCallback_t ARCOMMANDS_Decoder_PowerupVideoSettingsStateVideoModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupVideoSettingsStateVideoModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupVideoSettingsStateVideoModeChangedCallback (ARCOMMANDS_Decoder_PowerupVideoSettingsStateVideoModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupVideoSettingsStateVideoModeChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupVideoSettingsStateVideoModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupSoundsStateBuzzChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupSoundsStateBuzzChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupSoundsStateBuzzChangedCallback = callback;
    decoder->PowerupSoundsStateBuzzChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupSoundsStateBuzzChangedCallback_t ARCOMMANDS_Decoder_PowerupSoundsStateBuzzChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupSoundsStateBuzzChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupSoundsStateBuzzChangedCallback (ARCOMMANDS_Decoder_PowerupSoundsStateBuzzChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupSoundsStateBuzzChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupSoundsStateBuzzChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature pro

void ARCOMMANDS_Decoder_SetProProBoughtFeaturesCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ProProBoughtFeaturesCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ProProBoughtFeaturesCallback = callback;
    decoder->ProProBoughtFeaturesCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ProProBoughtFeaturesCallback_t ARCOMMANDS_Decoder_ProProBoughtFeaturesCb = NULL;
static void *ARCOMMANDS_Decoder_ProProBoughtFeaturesCustom = NULL;
void ARCOMMANDS_Decoder_SetProProBoughtFeaturesCallback (ARCOMMANDS_Decoder_ProProBoughtFeaturesCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ProProBoughtFeaturesCb = callback;
        ARCOMMANDS_Decoder_ProProBoughtFeaturesCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetProProResponseCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ProProResponseCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ProProResponseCallback = callback;
    decoder->ProProResponseCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ProProResponseCallback_t ARCOMMANDS_Decoder_ProProResponseCb = NULL;
static void *ARCOMMANDS_Decoder_ProProResponseCustom = NULL;
void ARCOMMANDS_Decoder_SetProProResponseCallback (ARCOMMANDS_Decoder_ProProResponseCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ProProResponseCb = callback;
        ARCOMMANDS_Decoder_ProProResponseCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetProProActivateFeaturesCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ProProActivateFeaturesCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ProProActivateFeaturesCallback = callback;
    decoder->ProProActivateFeaturesCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ProProActivateFeaturesCallback_t ARCOMMANDS_Decoder_ProProActivateFeaturesCb = NULL;
static void *ARCOMMANDS_Decoder_ProProActivateFeaturesCustom = NULL;
void ARCOMMANDS_Decoder_SetProProActivateFeaturesCallback (ARCOMMANDS_Decoder_ProProActivateFeaturesCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ProProActivateFeaturesCb = callback;
        ARCOMMANDS_Decoder_ProProActivateFeaturesCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetProProStateSupportedFeaturesCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ProProStateSupportedFeaturesCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ProProStateSupportedFeaturesCallback = callback;
    decoder->ProProStateSupportedFeaturesCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ProProStateSupportedFeaturesCallback_t ARCOMMANDS_Decoder_ProProStateSupportedFeaturesCb = NULL;
static void *ARCOMMANDS_Decoder_ProProStateSupportedFeaturesCustom = NULL;
void ARCOMMANDS_Decoder_SetProProStateSupportedFeaturesCallback (ARCOMMANDS_Decoder_ProProStateSupportedFeaturesCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ProProStateSupportedFeaturesCb = callback;
        ARCOMMANDS_Decoder_ProProStateSupportedFeaturesCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetProProStateFeaturesActivatedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ProProStateFeaturesActivatedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ProProStateFeaturesActivatedCallback = callback;
    decoder->ProProStateFeaturesActivatedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ProProStateFeaturesActivatedCallback_t ARCOMMANDS_Decoder_ProProStateFeaturesActivatedCb = NULL;
static void *ARCOMMANDS_Decoder_ProProStateFeaturesActivatedCustom = NULL;
void ARCOMMANDS_Decoder_SetProProStateFeaturesActivatedCallback (ARCOMMANDS_Decoder_ProProStateFeaturesActivatedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ProProStateFeaturesActivatedCb = callback;
        ARCOMMANDS_Decoder_ProProStateFeaturesActivatedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetProProEventChallengeEventCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ProProEventChallengeEventCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ProProEventChallengeEventCallback = callback;
    decoder->ProProEventChallengeEventCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ProProEventChallengeEventCallback_t ARCOMMANDS_Decoder_ProProEventChallengeEventCb = NULL;
static void *ARCOMMANDS_Decoder_ProProEventChallengeEventCustom = NULL;
void ARCOMMANDS_Decoder_SetProProEventChallengeEventCallback (ARCOMMANDS_Decoder_ProProEventChallengeEventCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ProProEventChallengeEventCb = callback;
        ARCOMMANDS_Decoder_ProProEventChallengeEventCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature rc

void ARCOMMANDS_Decoder_SetRcMonitorChannelsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_RcMonitorChannelsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->RcMonitorChannelsCallback = callback;
    decoder->RcMonitorChannelsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_RcMonitorChannelsCallback_t ARCOMMANDS_Decoder_RcMonitorChannelsCb = NULL;
static void *ARCOMMANDS_Decoder_RcMonitorChannelsCustom = NULL;
void ARCOMMANDS_Decoder_SetRcMonitorChannelsCallback (ARCOMMANDS_Decoder_RcMonitorChannelsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_RcMonitorChannelsCb = callback;
        ARCOMMANDS_Decoder_RcMonitorChannelsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetRcStartCalibrationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_RcStartCalibrationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->RcStartCalibrationCallback = callback;
    decoder->RcStartCalibrationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_RcStartCalibrationCallback_t ARCOMMANDS_Decoder_RcStartCalibrationCb = NULL;
static void *ARCOMMANDS_Decoder_RcStartCalibrationCustom = NULL;
void ARCOMMANDS_Decoder_SetRcStartCalibrationCallback (ARCOMMANDS_Decoder_RcStartCalibrationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_RcStartCalibrationCb = callback;
        ARCOMMANDS_Decoder_RcStartCalibrationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetRcInvertChannelCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_RcInvertChannelCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->RcInvertChannelCallback = callback;
    decoder->RcInvertChannelCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_RcInvertChannelCallback_t ARCOMMANDS_Decoder_RcInvertChannelCb = NULL;
static void *ARCOMMANDS_Decoder_RcInvertChannelCustom = NULL;
void ARCOMMANDS_Decoder_SetRcInvertChannelCallback (ARCOMMANDS_Decoder_RcInvertChannelCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_RcInvertChannelCb = callback;
        ARCOMMANDS_Decoder_RcInvertChannelCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetRcAbortCalibrationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_RcAbortCalibrationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->RcAbortCalibrationCallback = callback;
    decoder->RcAbortCalibrationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_RcAbortCalibrationCallback_t ARCOMMANDS_Decoder_RcAbortCalibrationCb = NULL;
static void *ARCOMMANDS_Decoder_RcAbortCalibrationCustom = NULL;
void ARCOMMANDS_Decoder_SetRcAbortCalibrationCallback (ARCOMMANDS_Decoder_RcAbortCalibrationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_RcAbortCalibrationCb = callback;
        ARCOMMANDS_Decoder_RcAbortCalibrationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetRcResetCalibrationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_RcResetCalibrationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->RcResetCalibrationCallback = callback;
    decoder->RcResetCalibrationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_RcResetCalibrationCallback_t ARCOMMANDS_Decoder_RcResetCalibrationCb = NULL;
static void *ARCOMMANDS_Decoder_RcResetCalibrationCustom = NULL;
void ARCOMMANDS_Decoder_SetRcResetCalibrationCallback (ARCOMMANDS_Decoder_RcResetCalibrationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_RcResetCalibrationCb = callback;
        ARCOMMANDS_Decoder_RcResetCalibrationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetRcReceiverStateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_RcReceiverStateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->RcReceiverStateCallback = callback;
    decoder->RcReceiverStateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_RcReceiverStateCallback_t ARCOMMANDS_Decoder_RcReceiverStateCb = NULL;
static void *ARCOMMANDS_Decoder_RcReceiverStateCustom = NULL;
void ARCOMMANDS_Decoder_SetRcReceiverStateCallback (ARCOMMANDS_Decoder_RcReceiverStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_RcReceiverStateCb = callback;
        ARCOMMANDS_Decoder_RcReceiverStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetRcChannelsMonitorStateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_RcChannelsMonitorStateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->RcChannelsMonitorStateCallback = callback;
    decoder->RcChannelsMonitorStateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_RcChannelsMonitorStateCallback_t ARCOMMANDS_Decoder_RcChannelsMonitorStateCb = NULL;
static void *ARCOMMANDS_Decoder_RcChannelsMonitorStateCustom = NULL;
void ARCOMMANDS_Decoder_SetRcChannelsMonitorStateCallback (ARCOMMANDS_Decoder_RcChannelsMonitorStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_RcChannelsMonitorStateCb = callback;
        ARCOMMANDS_Decoder_RcChannelsMonitorStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetRcChannelValueCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_RcChannelValueCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->RcChannelValueCallback = callback;
    decoder->RcChannelValueCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_RcChannelValueCallback_t ARCOMMANDS_Decoder_RcChannelValueCb = NULL;
static void *ARCOMMANDS_Decoder_RcChannelValueCustom = NULL;
void ARCOMMANDS_Decoder_SetRcChannelValueCallback (ARCOMMANDS_Decoder_RcChannelValueCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_RcChannelValueCb = callback;
        ARCOMMANDS_Decoder_RcChannelValueCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetRcCalibrationStateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_RcCalibrationStateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->RcCalibrationStateCallback = callback;
    decoder->RcCalibrationStateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_RcCalibrationStateCallback_t ARCOMMANDS_Decoder_RcCalibrationStateCb = NULL;
static void *ARCOMMANDS_Decoder_RcCalibrationStateCustom = NULL;
void ARCOMMANDS_Decoder_SetRcCalibrationStateCallback (ARCOMMANDS_Decoder_RcCalibrationStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_RcCalibrationStateCb = callback;
        ARCOMMANDS_Decoder_RcCalibrationStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetRcReceiverQualityCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_RcReceiverQualityCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->RcReceiverQualityCallback = callback;
    decoder->RcReceiverQualityCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_RcReceiverQualityCallback_t ARCOMMANDS_Decoder_RcReceiverQualityCb = NULL;
static void *ARCOMMANDS_Decoder_RcReceiverQualityCustom = NULL;
void ARCOMMANDS_Decoder_SetRcReceiverQualityCallback (ARCOMMANDS_Decoder_RcReceiverQualityCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_RcReceiverQualityCb = callback;
        ARCOMMANDS_Decoder_RcReceiverQualityCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature SkyController

void ARCOMMANDS_Decoder_SetSkyControllerWifiRequestWifiListCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerWifiRequestWifiListCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerWifiRequestWifiListCallback = callback;
    decoder->SkyControllerWifiRequestWifiListCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerWifiRequestWifiListCallback_t ARCOMMANDS_Decoder_SkyControllerWifiRequestWifiListCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerWifiRequestWifiListCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerWifiRequestWifiListCallback (ARCOMMANDS_Decoder_SkyControllerWifiRequestWifiListCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerWifiRequestWifiListCb = callback;
        ARCOMMANDS_Decoder_SkyControllerWifiRequestWifiListCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerWifiRequestCurrentWifiCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerWifiRequestCurrentWifiCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerWifiRequestCurrentWifiCallback = callback;
    decoder->SkyControllerWifiRequestCurrentWifiCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerWifiRequestCurrentWifiCallback_t ARCOMMANDS_Decoder_SkyControllerWifiRequestCurrentWifiCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerWifiRequestCurrentWifiCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerWifiRequestCurrentWifiCallback (ARCOMMANDS_Decoder_SkyControllerWifiRequestCurrentWifiCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerWifiRequestCurrentWifiCb = callback;
        ARCOMMANDS_Decoder_SkyControllerWifiRequestCurrentWifiCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerWifiConnectToWifiCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerWifiConnectToWifiCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerWifiConnectToWifiCallback = callback;
    decoder->SkyControllerWifiConnectToWifiCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerWifiConnectToWifiCallback_t ARCOMMANDS_Decoder_SkyControllerWifiConnectToWifiCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerWifiConnectToWifiCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerWifiConnectToWifiCallback (ARCOMMANDS_Decoder_SkyControllerWifiConnectToWifiCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerWifiConnectToWifiCb = callback;
        ARCOMMANDS_Decoder_SkyControllerWifiConnectToWifiCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerWifiForgetWifiCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerWifiForgetWifiCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerWifiForgetWifiCallback = callback;
    decoder->SkyControllerWifiForgetWifiCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerWifiForgetWifiCallback_t ARCOMMANDS_Decoder_SkyControllerWifiForgetWifiCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerWifiForgetWifiCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerWifiForgetWifiCallback (ARCOMMANDS_Decoder_SkyControllerWifiForgetWifiCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerWifiForgetWifiCb = callback;
        ARCOMMANDS_Decoder_SkyControllerWifiForgetWifiCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerWifiWifiAuthChannelCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerWifiWifiAuthChannelCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerWifiWifiAuthChannelCallback = callback;
    decoder->SkyControllerWifiWifiAuthChannelCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerWifiWifiAuthChannelCallback_t ARCOMMANDS_Decoder_SkyControllerWifiWifiAuthChannelCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerWifiWifiAuthChannelCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerWifiWifiAuthChannelCallback (ARCOMMANDS_Decoder_SkyControllerWifiWifiAuthChannelCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerWifiWifiAuthChannelCb = callback;
        ARCOMMANDS_Decoder_SkyControllerWifiWifiAuthChannelCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerDeviceRequestDeviceListCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerDeviceRequestDeviceListCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerDeviceRequestDeviceListCallback = callback;
    decoder->SkyControllerDeviceRequestDeviceListCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerDeviceRequestDeviceListCallback_t ARCOMMANDS_Decoder_SkyControllerDeviceRequestDeviceListCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerDeviceRequestDeviceListCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerDeviceRequestDeviceListCallback (ARCOMMANDS_Decoder_SkyControllerDeviceRequestDeviceListCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerDeviceRequestDeviceListCb = callback;
        ARCOMMANDS_Decoder_SkyControllerDeviceRequestDeviceListCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerDeviceRequestCurrentDeviceCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerDeviceRequestCurrentDeviceCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerDeviceRequestCurrentDeviceCallback = callback;
    decoder->SkyControllerDeviceRequestCurrentDeviceCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerDeviceRequestCurrentDeviceCallback_t ARCOMMANDS_Decoder_SkyControllerDeviceRequestCurrentDeviceCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerDeviceRequestCurrentDeviceCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerDeviceRequestCurrentDeviceCallback (ARCOMMANDS_Decoder_SkyControllerDeviceRequestCurrentDeviceCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerDeviceRequestCurrentDeviceCb = callback;
        ARCOMMANDS_Decoder_SkyControllerDeviceRequestCurrentDeviceCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerDeviceConnectToDeviceCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerDeviceConnectToDeviceCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerDeviceConnectToDeviceCallback = callback;
    decoder->SkyControllerDeviceConnectToDeviceCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerDeviceConnectToDeviceCallback_t ARCOMMANDS_Decoder_SkyControllerDeviceConnectToDeviceCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerDeviceConnectToDeviceCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerDeviceConnectToDeviceCallback (ARCOMMANDS_Decoder_SkyControllerDeviceConnectToDeviceCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerDeviceConnectToDeviceCb = callback;
        ARCOMMANDS_Decoder_SkyControllerDeviceConnectToDeviceCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerSettingsAllSettingsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerSettingsAllSettingsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerSettingsAllSettingsCallback = callback;
    decoder->SkyControllerSettingsAllSettingsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerSettingsAllSettingsCallback_t ARCOMMANDS_Decoder_SkyControllerSettingsAllSettingsCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerSettingsAllSettingsCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerSettingsAllSettingsCallback (ARCOMMANDS_Decoder_SkyControllerSettingsAllSettingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerSettingsAllSettingsCb = callback;
        ARCOMMANDS_Decoder_SkyControllerSettingsAllSettingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerSettingsResetCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerSettingsResetCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerSettingsResetCallback = callback;
    decoder->SkyControllerSettingsResetCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerSettingsResetCallback_t ARCOMMANDS_Decoder_SkyControllerSettingsResetCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerSettingsResetCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerSettingsResetCallback (ARCOMMANDS_Decoder_SkyControllerSettingsResetCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerSettingsResetCb = callback;
        ARCOMMANDS_Decoder_SkyControllerSettingsResetCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerCommonAllStatesCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerCommonAllStatesCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerCommonAllStatesCallback = callback;
    decoder->SkyControllerCommonAllStatesCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerCommonAllStatesCallback_t ARCOMMANDS_Decoder_SkyControllerCommonAllStatesCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerCommonAllStatesCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerCommonAllStatesCallback (ARCOMMANDS_Decoder_SkyControllerCommonAllStatesCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerCommonAllStatesCb = callback;
        ARCOMMANDS_Decoder_SkyControllerCommonAllStatesCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsAccessPointSSIDCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointSSIDCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerAccessPointSettingsAccessPointSSIDCallback = callback;
    decoder->SkyControllerAccessPointSettingsAccessPointSSIDCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointSSIDCallback_t ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointSSIDCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointSSIDCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsAccessPointSSIDCallback (ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointSSIDCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointSSIDCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointSSIDCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsAccessPointChannelCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointChannelCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerAccessPointSettingsAccessPointChannelCallback = callback;
    decoder->SkyControllerAccessPointSettingsAccessPointChannelCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointChannelCallback_t ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointChannelCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointChannelCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsAccessPointChannelCallback (ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointChannelCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointChannelCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointChannelCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsWifiSelectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsWifiSelectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerAccessPointSettingsWifiSelectionCallback = callback;
    decoder->SkyControllerAccessPointSettingsWifiSelectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsWifiSelectionCallback_t ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsWifiSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsWifiSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsWifiSelectionCallback (ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsWifiSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsWifiSelectionCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsWifiSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerCameraResetOrientationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerCameraResetOrientationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerCameraResetOrientationCallback = callback;
    decoder->SkyControllerCameraResetOrientationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerCameraResetOrientationCallback_t ARCOMMANDS_Decoder_SkyControllerCameraResetOrientationCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerCameraResetOrientationCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerCameraResetOrientationCallback (ARCOMMANDS_Decoder_SkyControllerCameraResetOrientationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerCameraResetOrientationCb = callback;
        ARCOMMANDS_Decoder_SkyControllerCameraResetOrientationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerGamepadInfosGetGamepadControlsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerGamepadInfosGetGamepadControlsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerGamepadInfosGetGamepadControlsCallback = callback;
    decoder->SkyControllerGamepadInfosGetGamepadControlsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerGamepadInfosGetGamepadControlsCallback_t ARCOMMANDS_Decoder_SkyControllerGamepadInfosGetGamepadControlsCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerGamepadInfosGetGamepadControlsCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerGamepadInfosGetGamepadControlsCallback (ARCOMMANDS_Decoder_SkyControllerGamepadInfosGetGamepadControlsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerGamepadInfosGetGamepadControlsCb = callback;
        ARCOMMANDS_Decoder_SkyControllerGamepadInfosGetGamepadControlsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsGetCurrentButtonMappingsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetCurrentButtonMappingsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerButtonMappingsGetCurrentButtonMappingsCallback = callback;
    decoder->SkyControllerButtonMappingsGetCurrentButtonMappingsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetCurrentButtonMappingsCallback_t ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetCurrentButtonMappingsCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetCurrentButtonMappingsCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsGetCurrentButtonMappingsCallback (ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetCurrentButtonMappingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetCurrentButtonMappingsCb = callback;
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetCurrentButtonMappingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsGetAvailableButtonMappingsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetAvailableButtonMappingsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerButtonMappingsGetAvailableButtonMappingsCallback = callback;
    decoder->SkyControllerButtonMappingsGetAvailableButtonMappingsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetAvailableButtonMappingsCallback_t ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetAvailableButtonMappingsCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetAvailableButtonMappingsCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsGetAvailableButtonMappingsCallback (ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetAvailableButtonMappingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetAvailableButtonMappingsCb = callback;
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetAvailableButtonMappingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsSetButtonMappingCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerButtonMappingsSetButtonMappingCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerButtonMappingsSetButtonMappingCallback = callback;
    decoder->SkyControllerButtonMappingsSetButtonMappingCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerButtonMappingsSetButtonMappingCallback_t ARCOMMANDS_Decoder_SkyControllerButtonMappingsSetButtonMappingCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerButtonMappingsSetButtonMappingCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsSetButtonMappingCallback (ARCOMMANDS_Decoder_SkyControllerButtonMappingsSetButtonMappingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsSetButtonMappingCb = callback;
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsSetButtonMappingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsDefaultButtonMappingCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerButtonMappingsDefaultButtonMappingCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerButtonMappingsDefaultButtonMappingCallback = callback;
    decoder->SkyControllerButtonMappingsDefaultButtonMappingCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerButtonMappingsDefaultButtonMappingCallback_t ARCOMMANDS_Decoder_SkyControllerButtonMappingsDefaultButtonMappingCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerButtonMappingsDefaultButtonMappingCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsDefaultButtonMappingCallback (ARCOMMANDS_Decoder_SkyControllerButtonMappingsDefaultButtonMappingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsDefaultButtonMappingCb = callback;
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsDefaultButtonMappingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsGetCurrentAxisMappingsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetCurrentAxisMappingsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerAxisMappingsGetCurrentAxisMappingsCallback = callback;
    decoder->SkyControllerAxisMappingsGetCurrentAxisMappingsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetCurrentAxisMappingsCallback_t ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetCurrentAxisMappingsCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetCurrentAxisMappingsCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsGetCurrentAxisMappingsCallback (ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetCurrentAxisMappingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetCurrentAxisMappingsCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetCurrentAxisMappingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsGetAvailableAxisMappingsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetAvailableAxisMappingsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerAxisMappingsGetAvailableAxisMappingsCallback = callback;
    decoder->SkyControllerAxisMappingsGetAvailableAxisMappingsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetAvailableAxisMappingsCallback_t ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetAvailableAxisMappingsCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetAvailableAxisMappingsCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsGetAvailableAxisMappingsCallback (ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetAvailableAxisMappingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetAvailableAxisMappingsCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetAvailableAxisMappingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsSetAxisMappingCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerAxisMappingsSetAxisMappingCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerAxisMappingsSetAxisMappingCallback = callback;
    decoder->SkyControllerAxisMappingsSetAxisMappingCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerAxisMappingsSetAxisMappingCallback_t ARCOMMANDS_Decoder_SkyControllerAxisMappingsSetAxisMappingCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisMappingsSetAxisMappingCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsSetAxisMappingCallback (ARCOMMANDS_Decoder_SkyControllerAxisMappingsSetAxisMappingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsSetAxisMappingCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsSetAxisMappingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsDefaultAxisMappingCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerAxisMappingsDefaultAxisMappingCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerAxisMappingsDefaultAxisMappingCallback = callback;
    decoder->SkyControllerAxisMappingsDefaultAxisMappingCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerAxisMappingsDefaultAxisMappingCallback_t ARCOMMANDS_Decoder_SkyControllerAxisMappingsDefaultAxisMappingCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisMappingsDefaultAxisMappingCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsDefaultAxisMappingCallback (ARCOMMANDS_Decoder_SkyControllerAxisMappingsDefaultAxisMappingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsDefaultAxisMappingCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsDefaultAxisMappingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersGetCurrentAxisFiltersCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetCurrentAxisFiltersCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerAxisFiltersGetCurrentAxisFiltersCallback = callback;
    decoder->SkyControllerAxisFiltersGetCurrentAxisFiltersCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetCurrentAxisFiltersCallback_t ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetCurrentAxisFiltersCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetCurrentAxisFiltersCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersGetCurrentAxisFiltersCallback (ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetCurrentAxisFiltersCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetCurrentAxisFiltersCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetCurrentAxisFiltersCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersGetPresetAxisFiltersCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetPresetAxisFiltersCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerAxisFiltersGetPresetAxisFiltersCallback = callback;
    decoder->SkyControllerAxisFiltersGetPresetAxisFiltersCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetPresetAxisFiltersCallback_t ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetPresetAxisFiltersCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetPresetAxisFiltersCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersGetPresetAxisFiltersCallback (ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetPresetAxisFiltersCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetPresetAxisFiltersCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetPresetAxisFiltersCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersSetAxisFilterCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerAxisFiltersSetAxisFilterCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerAxisFiltersSetAxisFilterCallback = callback;
    decoder->SkyControllerAxisFiltersSetAxisFilterCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerAxisFiltersSetAxisFilterCallback_t ARCOMMANDS_Decoder_SkyControllerAxisFiltersSetAxisFilterCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisFiltersSetAxisFilterCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersSetAxisFilterCallback (ARCOMMANDS_Decoder_SkyControllerAxisFiltersSetAxisFilterCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersSetAxisFilterCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersSetAxisFilterCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersDefaultAxisFiltersCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerAxisFiltersDefaultAxisFiltersCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerAxisFiltersDefaultAxisFiltersCallback = callback;
    decoder->SkyControllerAxisFiltersDefaultAxisFiltersCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerAxisFiltersDefaultAxisFiltersCallback_t ARCOMMANDS_Decoder_SkyControllerAxisFiltersDefaultAxisFiltersCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisFiltersDefaultAxisFiltersCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersDefaultAxisFiltersCallback (ARCOMMANDS_Decoder_SkyControllerAxisFiltersDefaultAxisFiltersCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersDefaultAxisFiltersCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersDefaultAxisFiltersCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerCoPilotingSetPilotingSourceCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerCoPilotingSetPilotingSourceCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerCoPilotingSetPilotingSourceCallback = callback;
    decoder->SkyControllerCoPilotingSetPilotingSourceCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerCoPilotingSetPilotingSourceCallback_t ARCOMMANDS_Decoder_SkyControllerCoPilotingSetPilotingSourceCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerCoPilotingSetPilotingSourceCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerCoPilotingSetPilotingSourceCallback (ARCOMMANDS_Decoder_SkyControllerCoPilotingSetPilotingSourceCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerCoPilotingSetPilotingSourceCb = callback;
        ARCOMMANDS_Decoder_SkyControllerCoPilotingSetPilotingSourceCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCallback = callback;
    decoder->SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCallback_t ARCOMMANDS_Decoder_SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCallback (ARCOMMANDS_Decoder_SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCb = callback;
        ARCOMMANDS_Decoder_SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerFactoryResetCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerFactoryResetCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerFactoryResetCallback = callback;
    decoder->SkyControllerFactoryResetCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerFactoryResetCallback_t ARCOMMANDS_Decoder_SkyControllerFactoryResetCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerFactoryResetCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerFactoryResetCallback (ARCOMMANDS_Decoder_SkyControllerFactoryResetCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerFactoryResetCb = callback;
        ARCOMMANDS_Decoder_SkyControllerFactoryResetCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiListCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerWifiStateWifiListCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerWifiStateWifiListCallback = callback;
    decoder->SkyControllerWifiStateWifiListCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerWifiStateWifiListCallback_t ARCOMMANDS_Decoder_SkyControllerWifiStateWifiListCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerWifiStateWifiListCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiListCallback (ARCOMMANDS_Decoder_SkyControllerWifiStateWifiListCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerWifiStateWifiListCb = callback;
        ARCOMMANDS_Decoder_SkyControllerWifiStateWifiListCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerWifiStateConnexionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerWifiStateConnexionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerWifiStateConnexionChangedCallback = callback;
    decoder->SkyControllerWifiStateConnexionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerWifiStateConnexionChangedCallback_t ARCOMMANDS_Decoder_SkyControllerWifiStateConnexionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerWifiStateConnexionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerWifiStateConnexionChangedCallback (ARCOMMANDS_Decoder_SkyControllerWifiStateConnexionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerWifiStateConnexionChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerWifiStateConnexionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiAuthChannelListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerWifiStateWifiAuthChannelListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerWifiStateWifiAuthChannelListChangedCallback = callback;
    decoder->SkyControllerWifiStateWifiAuthChannelListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerWifiStateWifiAuthChannelListChangedCallback_t ARCOMMANDS_Decoder_SkyControllerWifiStateWifiAuthChannelListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerWifiStateWifiAuthChannelListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiAuthChannelListChangedCallback (ARCOMMANDS_Decoder_SkyControllerWifiStateWifiAuthChannelListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerWifiStateWifiAuthChannelListChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerWifiStateWifiAuthChannelListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerWifiStateAllWifiAuthChannelChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerWifiStateAllWifiAuthChannelChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerWifiStateAllWifiAuthChannelChangedCallback = callback;
    decoder->SkyControllerWifiStateAllWifiAuthChannelChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerWifiStateAllWifiAuthChannelChangedCallback_t ARCOMMANDS_Decoder_SkyControllerWifiStateAllWifiAuthChannelChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerWifiStateAllWifiAuthChannelChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerWifiStateAllWifiAuthChannelChangedCallback (ARCOMMANDS_Decoder_SkyControllerWifiStateAllWifiAuthChannelChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerWifiStateAllWifiAuthChannelChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerWifiStateAllWifiAuthChannelChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiSignalChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerWifiStateWifiSignalChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerWifiStateWifiSignalChangedCallback = callback;
    decoder->SkyControllerWifiStateWifiSignalChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerWifiStateWifiSignalChangedCallback_t ARCOMMANDS_Decoder_SkyControllerWifiStateWifiSignalChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerWifiStateWifiSignalChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiSignalChangedCallback (ARCOMMANDS_Decoder_SkyControllerWifiStateWifiSignalChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerWifiStateWifiSignalChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerWifiStateWifiSignalChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerDeviceStateDeviceListCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerDeviceStateDeviceListCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerDeviceStateDeviceListCallback = callback;
    decoder->SkyControllerDeviceStateDeviceListCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerDeviceStateDeviceListCallback_t ARCOMMANDS_Decoder_SkyControllerDeviceStateDeviceListCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerDeviceStateDeviceListCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerDeviceStateDeviceListCallback (ARCOMMANDS_Decoder_SkyControllerDeviceStateDeviceListCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerDeviceStateDeviceListCb = callback;
        ARCOMMANDS_Decoder_SkyControllerDeviceStateDeviceListCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerDeviceStateConnexionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerDeviceStateConnexionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerDeviceStateConnexionChangedCallback = callback;
    decoder->SkyControllerDeviceStateConnexionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerDeviceStateConnexionChangedCallback_t ARCOMMANDS_Decoder_SkyControllerDeviceStateConnexionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerDeviceStateConnexionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerDeviceStateConnexionChangedCallback (ARCOMMANDS_Decoder_SkyControllerDeviceStateConnexionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerDeviceStateConnexionChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerDeviceStateConnexionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerSettingsStateAllSettingsChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerSettingsStateAllSettingsChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerSettingsStateAllSettingsChangedCallback = callback;
    decoder->SkyControllerSettingsStateAllSettingsChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerSettingsStateAllSettingsChangedCallback_t ARCOMMANDS_Decoder_SkyControllerSettingsStateAllSettingsChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerSettingsStateAllSettingsChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerSettingsStateAllSettingsChangedCallback (ARCOMMANDS_Decoder_SkyControllerSettingsStateAllSettingsChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerSettingsStateAllSettingsChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerSettingsStateAllSettingsChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerSettingsStateResetChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerSettingsStateResetChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerSettingsStateResetChangedCallback = callback;
    decoder->SkyControllerSettingsStateResetChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerSettingsStateResetChangedCallback_t ARCOMMANDS_Decoder_SkyControllerSettingsStateResetChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerSettingsStateResetChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerSettingsStateResetChangedCallback (ARCOMMANDS_Decoder_SkyControllerSettingsStateResetChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerSettingsStateResetChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerSettingsStateResetChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerSettingsStateProductSerialChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerSettingsStateProductSerialChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerSettingsStateProductSerialChangedCallback = callback;
    decoder->SkyControllerSettingsStateProductSerialChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerSettingsStateProductSerialChangedCallback_t ARCOMMANDS_Decoder_SkyControllerSettingsStateProductSerialChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerSettingsStateProductSerialChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerSettingsStateProductSerialChangedCallback (ARCOMMANDS_Decoder_SkyControllerSettingsStateProductSerialChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerSettingsStateProductSerialChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerSettingsStateProductSerialChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerSettingsStateProductVariantChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerSettingsStateProductVariantChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerSettingsStateProductVariantChangedCallback = callback;
    decoder->SkyControllerSettingsStateProductVariantChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerSettingsStateProductVariantChangedCallback_t ARCOMMANDS_Decoder_SkyControllerSettingsStateProductVariantChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerSettingsStateProductVariantChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerSettingsStateProductVariantChangedCallback (ARCOMMANDS_Decoder_SkyControllerSettingsStateProductVariantChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerSettingsStateProductVariantChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerSettingsStateProductVariantChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerSettingsStateProductVersionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerSettingsStateProductVersionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerSettingsStateProductVersionChangedCallback = callback;
    decoder->SkyControllerSettingsStateProductVersionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerSettingsStateProductVersionChangedCallback_t ARCOMMANDS_Decoder_SkyControllerSettingsStateProductVersionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerSettingsStateProductVersionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerSettingsStateProductVersionChangedCallback (ARCOMMANDS_Decoder_SkyControllerSettingsStateProductVersionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerSettingsStateProductVersionChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerSettingsStateProductVersionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerCommonStateAllStatesChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerCommonStateAllStatesChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerCommonStateAllStatesChangedCallback = callback;
    decoder->SkyControllerCommonStateAllStatesChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerCommonStateAllStatesChangedCallback_t ARCOMMANDS_Decoder_SkyControllerCommonStateAllStatesChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerCommonStateAllStatesChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerCommonStateAllStatesChangedCallback (ARCOMMANDS_Decoder_SkyControllerCommonStateAllStatesChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerCommonStateAllStatesChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerCommonStateAllStatesChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateBatteryChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerSkyControllerStateBatteryChangedCallback = callback;
    decoder->SkyControllerSkyControllerStateBatteryChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryChangedCallback_t ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateBatteryChangedCallback (ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateGpsFixChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsFixChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerSkyControllerStateGpsFixChangedCallback = callback;
    decoder->SkyControllerSkyControllerStateGpsFixChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsFixChangedCallback_t ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsFixChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsFixChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateGpsFixChangedCallback (ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsFixChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsFixChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsFixChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateGpsPositionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsPositionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerSkyControllerStateGpsPositionChangedCallback = callback;
    decoder->SkyControllerSkyControllerStateGpsPositionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsPositionChangedCallback_t ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsPositionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsPositionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateGpsPositionChangedCallback (ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsPositionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsPositionChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsPositionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateBatteryStateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryStateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerSkyControllerStateBatteryStateCallback = callback;
    decoder->SkyControllerSkyControllerStateBatteryStateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryStateCallback_t ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryStateCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryStateCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateBatteryStateCallback (ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryStateCb = callback;
        ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateAttitudeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerSkyControllerStateAttitudeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerSkyControllerStateAttitudeChangedCallback = callback;
    decoder->SkyControllerSkyControllerStateAttitudeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerSkyControllerStateAttitudeChangedCallback_t ARCOMMANDS_Decoder_SkyControllerSkyControllerStateAttitudeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerSkyControllerStateAttitudeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateAttitudeChangedCallback (ARCOMMANDS_Decoder_SkyControllerSkyControllerStateAttitudeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerSkyControllerStateAttitudeChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerSkyControllerStateAttitudeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateAccessPointSSIDChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCallback = callback;
    decoder->SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCallback_t ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateAccessPointSSIDChangedCallback (ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateAccessPointChannelChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointChannelChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerAccessPointSettingsStateAccessPointChannelChangedCallback = callback;
    decoder->SkyControllerAccessPointSettingsStateAccessPointChannelChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointChannelChangedCallback_t ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointChannelChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointChannelChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateAccessPointChannelChangedCallback (ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointChannelChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointChannelChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointChannelChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateWifiSelectionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateWifiSelectionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerAccessPointSettingsStateWifiSelectionChangedCallback = callback;
    decoder->SkyControllerAccessPointSettingsStateWifiSelectionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateWifiSelectionChangedCallback_t ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateWifiSelectionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateWifiSelectionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateWifiSelectionChangedCallback (ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateWifiSelectionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateWifiSelectionChangedCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateWifiSelectionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerGamepadInfosStateGamepadControlCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateGamepadControlCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerGamepadInfosStateGamepadControlCallback = callback;
    decoder->SkyControllerGamepadInfosStateGamepadControlCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateGamepadControlCallback_t ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateGamepadControlCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateGamepadControlCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerGamepadInfosStateGamepadControlCallback (ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateGamepadControlCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateGamepadControlCb = callback;
        ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateGamepadControlCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerGamepadInfosStateAllGamepadControlsSentCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateAllGamepadControlsSentCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerGamepadInfosStateAllGamepadControlsSentCallback = callback;
    decoder->SkyControllerGamepadInfosStateAllGamepadControlsSentCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateAllGamepadControlsSentCallback_t ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateAllGamepadControlsSentCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateAllGamepadControlsSentCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerGamepadInfosStateAllGamepadControlsSentCallback (ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateAllGamepadControlsSentCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateAllGamepadControlsSentCb = callback;
        ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateAllGamepadControlsSentCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateCurrentButtonMappingsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateCurrentButtonMappingsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerButtonMappingsStateCurrentButtonMappingsCallback = callback;
    decoder->SkyControllerButtonMappingsStateCurrentButtonMappingsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateCurrentButtonMappingsCallback_t ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateCurrentButtonMappingsCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateCurrentButtonMappingsCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateCurrentButtonMappingsCallback (ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateCurrentButtonMappingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateCurrentButtonMappingsCb = callback;
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateCurrentButtonMappingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCallback = callback;
    decoder->SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCallback_t ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCallback (ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCb = callback;
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAvailableButtonMappingsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAvailableButtonMappingsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerButtonMappingsStateAvailableButtonMappingsCallback = callback;
    decoder->SkyControllerButtonMappingsStateAvailableButtonMappingsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAvailableButtonMappingsCallback_t ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAvailableButtonMappingsCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAvailableButtonMappingsCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAvailableButtonMappingsCallback (ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAvailableButtonMappingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAvailableButtonMappingsCb = callback;
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAvailableButtonMappingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCallback = callback;
    decoder->SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCallback_t ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCallback (ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCb = callback;
        ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateCurrentAxisMappingsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateCurrentAxisMappingsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerAxisMappingsStateCurrentAxisMappingsCallback = callback;
    decoder->SkyControllerAxisMappingsStateCurrentAxisMappingsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateCurrentAxisMappingsCallback_t ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateCurrentAxisMappingsCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateCurrentAxisMappingsCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateCurrentAxisMappingsCallback (ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateCurrentAxisMappingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateCurrentAxisMappingsCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateCurrentAxisMappingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCallback = callback;
    decoder->SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCallback_t ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCallback (ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAvailableAxisMappingsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAvailableAxisMappingsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerAxisMappingsStateAvailableAxisMappingsCallback = callback;
    decoder->SkyControllerAxisMappingsStateAvailableAxisMappingsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAvailableAxisMappingsCallback_t ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAvailableAxisMappingsCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAvailableAxisMappingsCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAvailableAxisMappingsCallback (ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAvailableAxisMappingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAvailableAxisMappingsCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAvailableAxisMappingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCallback = callback;
    decoder->SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCallback_t ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCallback (ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateCurrentAxisFiltersCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateCurrentAxisFiltersCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerAxisFiltersStateCurrentAxisFiltersCallback = callback;
    decoder->SkyControllerAxisFiltersStateCurrentAxisFiltersCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateCurrentAxisFiltersCallback_t ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateCurrentAxisFiltersCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateCurrentAxisFiltersCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateCurrentAxisFiltersCallback (ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateCurrentAxisFiltersCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateCurrentAxisFiltersCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateCurrentAxisFiltersCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateAllCurrentFiltersSentCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllCurrentFiltersSentCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerAxisFiltersStateAllCurrentFiltersSentCallback = callback;
    decoder->SkyControllerAxisFiltersStateAllCurrentFiltersSentCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllCurrentFiltersSentCallback_t ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllCurrentFiltersSentCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllCurrentFiltersSentCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateAllCurrentFiltersSentCallback (ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllCurrentFiltersSentCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllCurrentFiltersSentCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllCurrentFiltersSentCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStatePresetAxisFiltersCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerAxisFiltersStatePresetAxisFiltersCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerAxisFiltersStatePresetAxisFiltersCallback = callback;
    decoder->SkyControllerAxisFiltersStatePresetAxisFiltersCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerAxisFiltersStatePresetAxisFiltersCallback_t ARCOMMANDS_Decoder_SkyControllerAxisFiltersStatePresetAxisFiltersCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisFiltersStatePresetAxisFiltersCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStatePresetAxisFiltersCallback (ARCOMMANDS_Decoder_SkyControllerAxisFiltersStatePresetAxisFiltersCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersStatePresetAxisFiltersCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersStatePresetAxisFiltersCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateAllPresetFiltersSentCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllPresetFiltersSentCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerAxisFiltersStateAllPresetFiltersSentCallback = callback;
    decoder->SkyControllerAxisFiltersStateAllPresetFiltersSentCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllPresetFiltersSentCallback_t ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllPresetFiltersSentCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllPresetFiltersSentCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateAllPresetFiltersSentCallback (ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllPresetFiltersSentCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllPresetFiltersSentCb = callback;
        ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllPresetFiltersSentCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerCoPilotingStatePilotingSourceCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerCoPilotingStatePilotingSourceCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerCoPilotingStatePilotingSourceCallback = callback;
    decoder->SkyControllerCoPilotingStatePilotingSourceCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerCoPilotingStatePilotingSourceCallback_t ARCOMMANDS_Decoder_SkyControllerCoPilotingStatePilotingSourceCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerCoPilotingStatePilotingSourceCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerCoPilotingStatePilotingSourceCallback (ARCOMMANDS_Decoder_SkyControllerCoPilotingStatePilotingSourceCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerCoPilotingStatePilotingSourceCb = callback;
        ARCOMMANDS_Decoder_SkyControllerCoPilotingStatePilotingSourceCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerCalibrationStateMagnetoCalibrationStateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationStateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerCalibrationStateMagnetoCalibrationStateCallback = callback;
    decoder->SkyControllerCalibrationStateMagnetoCalibrationStateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationStateCallback_t ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationStateCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationStateCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerCalibrationStateMagnetoCalibrationStateCallback (ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationStateCb = callback;
        ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCallback = callback;
    decoder->SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCallback_t ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCallback (ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCb = callback;
        ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetSkyControllerButtonEventsSettingsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_SkyControllerButtonEventsSettingsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->SkyControllerButtonEventsSettingsCallback = callback;
    decoder->SkyControllerButtonEventsSettingsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_SkyControllerButtonEventsSettingsCallback_t ARCOMMANDS_Decoder_SkyControllerButtonEventsSettingsCb = NULL;
static void *ARCOMMANDS_Decoder_SkyControllerButtonEventsSettingsCustom = NULL;
void ARCOMMANDS_Decoder_SetSkyControllerButtonEventsSettingsCallback (ARCOMMANDS_Decoder_SkyControllerButtonEventsSettingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_SkyControllerButtonEventsSettingsCb = callback;
        ARCOMMANDS_Decoder_SkyControllerButtonEventsSettingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature unknown_feature_1

void ARCOMMANDS_Decoder_SetUnknownFeature1GeographicRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1GeographicRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1GeographicRunCallback = callback;
    decoder->UnknownFeature1GeographicRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1GeographicRunCallback_t ARCOMMANDS_Decoder_UnknownFeature1GeographicRunCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1GeographicRunCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1GeographicRunCallback (ARCOMMANDS_Decoder_UnknownFeature1GeographicRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1GeographicRunCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1GeographicRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1RelativeRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1RelativeRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1RelativeRunCallback = callback;
    decoder->UnknownFeature1RelativeRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1RelativeRunCallback_t ARCOMMANDS_Decoder_UnknownFeature1RelativeRunCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1RelativeRunCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1RelativeRunCallback (ARCOMMANDS_Decoder_UnknownFeature1RelativeRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1RelativeRunCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1RelativeRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1LookAtRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1LookAtRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1LookAtRunCallback = callback;
    decoder->UnknownFeature1LookAtRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1LookAtRunCallback_t ARCOMMANDS_Decoder_UnknownFeature1LookAtRunCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1LookAtRunCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1LookAtRunCallback (ARCOMMANDS_Decoder_UnknownFeature1LookAtRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1LookAtRunCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1LookAtRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1SpiralAnimRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1SpiralAnimRunCallback = callback;
    decoder->UnknownFeature1SpiralAnimRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimRunCallback_t ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimRunCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimRunCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1SpiralAnimRunCallback (ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimRunCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1SwingAnimRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1SwingAnimRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1SwingAnimRunCallback = callback;
    decoder->UnknownFeature1SwingAnimRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1SwingAnimRunCallback_t ARCOMMANDS_Decoder_UnknownFeature1SwingAnimRunCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1SwingAnimRunCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1SwingAnimRunCallback (ARCOMMANDS_Decoder_UnknownFeature1SwingAnimRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1SwingAnimRunCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1SwingAnimRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1BoomerangAnimRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1BoomerangAnimRunCallback = callback;
    decoder->UnknownFeature1BoomerangAnimRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimRunCallback_t ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimRunCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimRunCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1BoomerangAnimRunCallback (ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimRunCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1CandleAnimRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1CandleAnimRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1CandleAnimRunCallback = callback;
    decoder->UnknownFeature1CandleAnimRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1CandleAnimRunCallback_t ARCOMMANDS_Decoder_UnknownFeature1CandleAnimRunCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1CandleAnimRunCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1CandleAnimRunCallback (ARCOMMANDS_Decoder_UnknownFeature1CandleAnimRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1CandleAnimRunCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1CandleAnimRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1DollySlideAnimRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1DollySlideAnimRunCallback = callback;
    decoder->UnknownFeature1DollySlideAnimRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimRunCallback_t ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimRunCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimRunCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1DollySlideAnimRunCallback (ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimRunCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1UserFramingPositionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1UserFramingPositionCallback = callback;
    decoder->UnknownFeature1UserFramingPositionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionCallback_t ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1UserFramingPositionCallback (ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1UserGPSDataCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1UserGPSDataCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1UserGPSDataCallback = callback;
    decoder->UnknownFeature1UserGPSDataCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1UserGPSDataCallback_t ARCOMMANDS_Decoder_UnknownFeature1UserGPSDataCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1UserGPSDataCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1UserGPSDataCallback (ARCOMMANDS_Decoder_UnknownFeature1UserGPSDataCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1UserGPSDataCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1UserGPSDataCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1UserBaroDataCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1UserBaroDataCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1UserBaroDataCallback = callback;
    decoder->UnknownFeature1UserBaroDataCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1UserBaroDataCallback_t ARCOMMANDS_Decoder_UnknownFeature1UserBaroDataCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1UserBaroDataCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1UserBaroDataCallback (ARCOMMANDS_Decoder_UnknownFeature1UserBaroDataCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1UserBaroDataCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1UserBaroDataCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1LynxDetectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1LynxDetectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1LynxDetectionCallback = callback;
    decoder->UnknownFeature1LynxDetectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1LynxDetectionCallback_t ARCOMMANDS_Decoder_UnknownFeature1LynxDetectionCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1LynxDetectionCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1LynxDetectionCallback (ARCOMMANDS_Decoder_UnknownFeature1LynxDetectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1LynxDetectionCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1LynxDetectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1AvailabilityCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1AvailabilityCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1AvailabilityCallback = callback;
    decoder->UnknownFeature1AvailabilityCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1AvailabilityCallback_t ARCOMMANDS_Decoder_UnknownFeature1AvailabilityCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1AvailabilityCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1AvailabilityCallback (ARCOMMANDS_Decoder_UnknownFeature1AvailabilityCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1AvailabilityCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1AvailabilityCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1RunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1RunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1RunCallback = callback;
    decoder->UnknownFeature1RunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1RunCallback_t ARCOMMANDS_Decoder_UnknownFeature1RunCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1RunCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1RunCallback (ARCOMMANDS_Decoder_UnknownFeature1RunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1RunCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1RunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1GeographicConfigChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1GeographicConfigChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1GeographicConfigChangedCallback = callback;
    decoder->UnknownFeature1GeographicConfigChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1GeographicConfigChangedCallback_t ARCOMMANDS_Decoder_UnknownFeature1GeographicConfigChangedCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1GeographicConfigChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1GeographicConfigChangedCallback (ARCOMMANDS_Decoder_UnknownFeature1GeographicConfigChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1GeographicConfigChangedCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1GeographicConfigChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1RelativeConfigChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1RelativeConfigChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1RelativeConfigChangedCallback = callback;
    decoder->UnknownFeature1RelativeConfigChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1RelativeConfigChangedCallback_t ARCOMMANDS_Decoder_UnknownFeature1RelativeConfigChangedCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1RelativeConfigChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1RelativeConfigChangedCallback (ARCOMMANDS_Decoder_UnknownFeature1RelativeConfigChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1RelativeConfigChangedCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1RelativeConfigChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1AnimRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1AnimRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1AnimRunCallback = callback;
    decoder->UnknownFeature1AnimRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1AnimRunCallback_t ARCOMMANDS_Decoder_UnknownFeature1AnimRunCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1AnimRunCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1AnimRunCallback (ARCOMMANDS_Decoder_UnknownFeature1AnimRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1AnimRunCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1AnimRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1SpiralAnimConfigChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimConfigChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1SpiralAnimConfigChangedCallback = callback;
    decoder->UnknownFeature1SpiralAnimConfigChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimConfigChangedCallback_t ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimConfigChangedCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimConfigChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1SpiralAnimConfigChangedCallback (ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimConfigChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimConfigChangedCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimConfigChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1SwingAnimConfigChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1SwingAnimConfigChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1SwingAnimConfigChangedCallback = callback;
    decoder->UnknownFeature1SwingAnimConfigChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1SwingAnimConfigChangedCallback_t ARCOMMANDS_Decoder_UnknownFeature1SwingAnimConfigChangedCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1SwingAnimConfigChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1SwingAnimConfigChangedCallback (ARCOMMANDS_Decoder_UnknownFeature1SwingAnimConfigChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1SwingAnimConfigChangedCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1SwingAnimConfigChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1BoomerangAnimConfigChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimConfigChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1BoomerangAnimConfigChangedCallback = callback;
    decoder->UnknownFeature1BoomerangAnimConfigChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimConfigChangedCallback_t ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimConfigChangedCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimConfigChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1BoomerangAnimConfigChangedCallback (ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimConfigChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimConfigChangedCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimConfigChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1CandleAnimConfigChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1CandleAnimConfigChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1CandleAnimConfigChangedCallback = callback;
    decoder->UnknownFeature1CandleAnimConfigChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1CandleAnimConfigChangedCallback_t ARCOMMANDS_Decoder_UnknownFeature1CandleAnimConfigChangedCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1CandleAnimConfigChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1CandleAnimConfigChangedCallback (ARCOMMANDS_Decoder_UnknownFeature1CandleAnimConfigChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1CandleAnimConfigChangedCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1CandleAnimConfigChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1DollySlideAnimConfigChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimConfigChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1DollySlideAnimConfigChangedCallback = callback;
    decoder->UnknownFeature1DollySlideAnimConfigChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimConfigChangedCallback_t ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimConfigChangedCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimConfigChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1DollySlideAnimConfigChangedCallback (ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimConfigChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimConfigChangedCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimConfigChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1UserFramingPositionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1UserFramingPositionChangedCallback = callback;
    decoder->UnknownFeature1UserFramingPositionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionChangedCallback_t ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1UserFramingPositionChangedCallback (ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionChangedCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature wifi

void ARCOMMANDS_Decoder_SetWifiScanCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiScanCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiScanCallback = callback;
    decoder->WifiScanCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiScanCallback_t ARCOMMANDS_Decoder_WifiScanCb = NULL;
static void *ARCOMMANDS_Decoder_WifiScanCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiScanCallback (ARCOMMANDS_Decoder_WifiScanCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiScanCb = callback;
        ARCOMMANDS_Decoder_WifiScanCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiUpdateAuthorizedChannelsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiUpdateAuthorizedChannelsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiUpdateAuthorizedChannelsCallback = callback;
    decoder->WifiUpdateAuthorizedChannelsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiUpdateAuthorizedChannelsCallback_t ARCOMMANDS_Decoder_WifiUpdateAuthorizedChannelsCb = NULL;
static void *ARCOMMANDS_Decoder_WifiUpdateAuthorizedChannelsCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiUpdateAuthorizedChannelsCallback (ARCOMMANDS_Decoder_WifiUpdateAuthorizedChannelsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiUpdateAuthorizedChannelsCb = callback;
        ARCOMMANDS_Decoder_WifiUpdateAuthorizedChannelsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiSetApChannelCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiSetApChannelCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiSetApChannelCallback = callback;
    decoder->WifiSetApChannelCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiSetApChannelCallback_t ARCOMMANDS_Decoder_WifiSetApChannelCb = NULL;
static void *ARCOMMANDS_Decoder_WifiSetApChannelCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiSetApChannelCallback (ARCOMMANDS_Decoder_WifiSetApChannelCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiSetApChannelCb = callback;
        ARCOMMANDS_Decoder_WifiSetApChannelCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiSetSecurityCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiSetSecurityCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiSetSecurityCallback = callback;
    decoder->WifiSetSecurityCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiSetSecurityCallback_t ARCOMMANDS_Decoder_WifiSetSecurityCb = NULL;
static void *ARCOMMANDS_Decoder_WifiSetSecurityCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiSetSecurityCallback (ARCOMMANDS_Decoder_WifiSetSecurityCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiSetSecurityCb = callback;
        ARCOMMANDS_Decoder_WifiSetSecurityCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiSetCountryCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiSetCountryCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiSetCountryCallback = callback;
    decoder->WifiSetCountryCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiSetCountryCallback_t ARCOMMANDS_Decoder_WifiSetCountryCb = NULL;
static void *ARCOMMANDS_Decoder_WifiSetCountryCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiSetCountryCallback (ARCOMMANDS_Decoder_WifiSetCountryCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiSetCountryCb = callback;
        ARCOMMANDS_Decoder_WifiSetCountryCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiSetEnvironmentCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiSetEnvironmentCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiSetEnvironmentCallback = callback;
    decoder->WifiSetEnvironmentCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiSetEnvironmentCallback_t ARCOMMANDS_Decoder_WifiSetEnvironmentCb = NULL;
static void *ARCOMMANDS_Decoder_WifiSetEnvironmentCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiSetEnvironmentCallback (ARCOMMANDS_Decoder_WifiSetEnvironmentCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiSetEnvironmentCb = callback;
        ARCOMMANDS_Decoder_WifiSetEnvironmentCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiScannedItemCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiScannedItemCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiScannedItemCallback = callback;
    decoder->WifiScannedItemCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiScannedItemCallback_t ARCOMMANDS_Decoder_WifiScannedItemCb = NULL;
static void *ARCOMMANDS_Decoder_WifiScannedItemCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiScannedItemCallback (ARCOMMANDS_Decoder_WifiScannedItemCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiScannedItemCb = callback;
        ARCOMMANDS_Decoder_WifiScannedItemCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiAuthorizedChannelCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiAuthorizedChannelCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiAuthorizedChannelCallback = callback;
    decoder->WifiAuthorizedChannelCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiAuthorizedChannelCallback_t ARCOMMANDS_Decoder_WifiAuthorizedChannelCb = NULL;
static void *ARCOMMANDS_Decoder_WifiAuthorizedChannelCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiAuthorizedChannelCallback (ARCOMMANDS_Decoder_WifiAuthorizedChannelCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiAuthorizedChannelCb = callback;
        ARCOMMANDS_Decoder_WifiAuthorizedChannelCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiApChannelChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiApChannelChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiApChannelChangedCallback = callback;
    decoder->WifiApChannelChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiApChannelChangedCallback_t ARCOMMANDS_Decoder_WifiApChannelChangedCb = NULL;
static void *ARCOMMANDS_Decoder_WifiApChannelChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiApChannelChangedCallback (ARCOMMANDS_Decoder_WifiApChannelChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiApChannelChangedCb = callback;
        ARCOMMANDS_Decoder_WifiApChannelChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiSecurityChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiSecurityChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiSecurityChangedCallback = callback;
    decoder->WifiSecurityChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiSecurityChangedCallback_t ARCOMMANDS_Decoder_WifiSecurityChangedCb = NULL;
static void *ARCOMMANDS_Decoder_WifiSecurityChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiSecurityChangedCallback (ARCOMMANDS_Decoder_WifiSecurityChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiSecurityChangedCb = callback;
        ARCOMMANDS_Decoder_WifiSecurityChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiCountryChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiCountryChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiCountryChangedCallback = callback;
    decoder->WifiCountryChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiCountryChangedCallback_t ARCOMMANDS_Decoder_WifiCountryChangedCb = NULL;
static void *ARCOMMANDS_Decoder_WifiCountryChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiCountryChangedCallback (ARCOMMANDS_Decoder_WifiCountryChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiCountryChangedCb = callback;
        ARCOMMANDS_Decoder_WifiCountryChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiEnvironmentChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiEnvironmentChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiEnvironmentChangedCallback = callback;
    decoder->WifiEnvironmentChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiEnvironmentChangedCallback_t ARCOMMANDS_Decoder_WifiEnvironmentChangedCb = NULL;
static void *ARCOMMANDS_Decoder_WifiEnvironmentChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiEnvironmentChangedCallback (ARCOMMANDS_Decoder_WifiEnvironmentChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiEnvironmentChangedCb = callback;
        ARCOMMANDS_Decoder_WifiEnvironmentChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiRssiChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiRssiChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiRssiChangedCallback = callback;
    decoder->WifiRssiChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiRssiChangedCallback_t ARCOMMANDS_Decoder_WifiRssiChangedCb = NULL;
static void *ARCOMMANDS_Decoder_WifiRssiChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiRssiChangedCallback (ARCOMMANDS_Decoder_WifiRssiChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiRssiChangedCb = callback;
        ARCOMMANDS_Decoder_WifiRssiChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// DECODER ENTRY POINT
eARCOMMANDS_DECODER_ERROR
ARCOMMANDS_Decoder_DecodeBuffer (uint8_t *buffer, int32_t buffLen)
{
    return ARCOMMANDS_Decoder_DecodeCommand (NULL, buffer, buffLen);
}

eARCOMMANDS_DECODER_ERROR
ARCOMMANDS_Decoder_DecodeCommand (ARCOMMANDS_Decoder_t *decoder, uint8_t *buffer, int32_t buffLen)
{
    eARCOMMANDS_ID_FEATURE commandFetaure = -1;
    int commandClass = -1;
    int commandId = -1;
    int32_t error = 0;
    int32_t offset = 0;
    eARCOMMANDS_DECODER_ERROR retVal = ARCOMMANDS_DECODER_OK;
    if (NULL == buffer)
    {
        retVal = ARCOMMANDS_DECODER_ERROR;
    } // No else --> Arg check

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        if (ARCOMMANDS_Decoder_Init () == 0)
        {
            retVal = ARCOMMANDS_DECODER_ERROR;
        } // No else --> keep retVal to OK if init went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        commandFetaure = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
        if (error == 1)
        {
            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
        } // No else --> Do not modify retVal if read went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        commandClass = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
        if (error == 1)
        {
            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
        } // No else --> Do not modify retVal if read went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        commandId = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
        if (error == 1)
        {
            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
        } // No else --> Do not modify retVal if read went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        switch (commandFetaure)
        {
        case ARCOMMANDS_ID_FEATURE_GENERIC:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_GENERIC_CMD_DEFAULT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->GenericDefaultCallback) || (!decoder && ARCOMMANDS_Decoder_GenericDefaultCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->GenericDefaultCallback) {
                                decoder->GenericDefaultCallback (decoder->GenericDefaultCustom);
                            } else {
                                ARCOMMANDS_Decoder_GenericDefaultCb (ARCOMMANDS_Decoder_GenericDefaultCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_GENERIC_FACTORY_CMD_DEFAULT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_GENERIC */
        case ARCOMMANDS_ID_FEATURE_ARDRONE3:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_FLATTRIM:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingFlatTrimCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingFlatTrimCallback) {
                                decoder->ARDrone3PilotingFlatTrimCallback (decoder->ARDrone3PilotingFlatTrimCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCb (ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_FLATTRIM */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_TAKEOFF:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingTakeOffCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingTakeOffCallback) {
                                decoder->ARDrone3PilotingTakeOffCallback (decoder->ARDrone3PilotingTakeOffCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCb (ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_TAKEOFF */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_PCMD:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingPCMDCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCb))
                    {
                        uint8_t _flag;
                        int8_t _roll;
                        int8_t _pitch;
                        int8_t _yaw;
                        int8_t _gaz;
                        uint32_t _timestampAndSeqNum;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _flag = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _roll =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _pitch =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _yaw =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _gaz =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _timestampAndSeqNum = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingPCMDCallback) {
                                decoder->ARDrone3PilotingPCMDCallback (_flag, _roll, _pitch, _yaw, _gaz, _timestampAndSeqNum, decoder->ARDrone3PilotingPCMDCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCb (_flag, _roll, _pitch, _yaw, _gaz, _timestampAndSeqNum, ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_PCMD */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_LANDING:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingLandingCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingLandingCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingLandingCallback) {
                                decoder->ARDrone3PilotingLandingCallback (decoder->ARDrone3PilotingLandingCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingLandingCb (ARCOMMANDS_Decoder_ARDrone3PilotingLandingCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_LANDING */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_EMERGENCY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingEmergencyCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingEmergencyCallback) {
                                decoder->ARDrone3PilotingEmergencyCallback (decoder->ARDrone3PilotingEmergencyCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCb (ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_EMERGENCY */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_NAVIGATEHOME:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingNavigateHomeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCb))
                    {
                        uint8_t _start;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _start = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingNavigateHomeCallback) {
                                decoder->ARDrone3PilotingNavigateHomeCallback (_start, decoder->ARDrone3PilotingNavigateHomeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCb (_start, ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_NAVIGATEHOME */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_AUTOTAKEOFFMODE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingAutoTakeOffModeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCb))
                    {
                        uint8_t _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingAutoTakeOffModeCallback) {
                                decoder->ARDrone3PilotingAutoTakeOffModeCallback (_state, decoder->ARDrone3PilotingAutoTakeOffModeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCb (_state, ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_AUTOTAKEOFFMODE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_MOVEBY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingMoveByCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingMoveByCb))
                    {
                        float _dX;
                        float _dY;
                        float _dZ;
                        float _dPsi;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _dX = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _dY = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _dZ = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _dPsi = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingMoveByCallback) {
                                decoder->ARDrone3PilotingMoveByCallback (_dX, _dY, _dZ, _dPsi, decoder->ARDrone3PilotingMoveByCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingMoveByCb (_dX, _dY, _dZ, _dPsi, ARCOMMANDS_Decoder_ARDrone3PilotingMoveByCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_MOVEBY */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_USERTAKEOFF:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingUserTakeOffCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingUserTakeOffCb))
                    {
                        uint8_t _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingUserTakeOffCallback) {
                                decoder->ARDrone3PilotingUserTakeOffCallback (_state, decoder->ARDrone3PilotingUserTakeOffCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingUserTakeOffCb (_state, ARCOMMANDS_Decoder_ARDrone3PilotingUserTakeOffCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_USERTAKEOFF */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_CIRCLE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingCircleCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingCircleCb))
                    {
                        eARCOMMANDS_ARDRONE3_PILOTING_CIRCLE_DIRECTION _direction;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _direction = (eARCOMMANDS_ARDRONE3_PILOTING_CIRCLE_DIRECTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingCircleCallback) {
                                decoder->ARDrone3PilotingCircleCallback (_direction, decoder->ARDrone3PilotingCircleCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingCircleCb (_direction, ARCOMMANDS_Decoder_ARDrone3PilotingCircleCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_CIRCLE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTING */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_ANIMATIONS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_ANIMATIONS_CMD_FLIP:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3AnimationsFlipCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCb))
                    {
                        eARCOMMANDS_ARDRONE3_ANIMATIONS_FLIP_DIRECTION _direction;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _direction = (eARCOMMANDS_ARDRONE3_ANIMATIONS_FLIP_DIRECTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3AnimationsFlipCallback) {
                                decoder->ARDrone3AnimationsFlipCallback (_direction, decoder->ARDrone3AnimationsFlipCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCb (_direction, ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANIMATIONS_CMD_FLIP */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_ANIMATIONS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERA:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_CAMERA_CMD_ORIENTATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3CameraOrientationCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3CameraOrientationCb))
                    {
                        int8_t _tilt;
                        int8_t _pan;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _tilt =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _pan =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3CameraOrientationCallback) {
                                decoder->ARDrone3CameraOrientationCallback (_tilt, _pan, decoder->ARDrone3CameraOrientationCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3CameraOrientationCb (_tilt, _pan, ARCOMMANDS_Decoder_ARDrone3CameraOrientationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_CAMERA_CMD_ORIENTATION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERA */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORD:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTURE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaRecordPictureCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCb))
                    {
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaRecordPictureCallback) {
                                decoder->ARDrone3MediaRecordPictureCallback (_mass_storage_id, decoder->ARDrone3MediaRecordPictureCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCb (_mass_storage_id, ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTURE */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEO:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaRecordVideoCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCb))
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEO_RECORD _record;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _record = (eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEO_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaRecordVideoCallback) {
                                decoder->ARDrone3MediaRecordVideoCallback (_record, _mass_storage_id, decoder->ARDrone3MediaRecordVideoCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCb (_record, _mass_storage_id, ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEO */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTUREV2:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaRecordPictureV2Callback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Cb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaRecordPictureV2Callback) {
                                decoder->ARDrone3MediaRecordPictureV2Callback (decoder->ARDrone3MediaRecordPictureV2Custom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Cb (ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Custom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTUREV2 */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEOV2:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaRecordVideoV2Callback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Cb))
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEOV2_RECORD _record;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _record = (eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEOV2_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaRecordVideoV2Callback) {
                                decoder->ARDrone3MediaRecordVideoV2Callback (_record, decoder->ARDrone3MediaRecordVideoV2Custom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Cb (_record, ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Custom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEOV2 */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORD */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaRecordStatePictureStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCb))
                    {
                        uint8_t _state;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaRecordStatePictureStateChangedCallback) {
                                decoder->ARDrone3MediaRecordStatePictureStateChangedCallback (_state, _mass_storage_id, decoder->ARDrone3MediaRecordStatePictureStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCb (_state, _mass_storage_id, ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaRecordStateVideoStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE _state;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaRecordStateVideoStateChangedCallback) {
                                decoder->ARDrone3MediaRecordStateVideoStateChangedCallback (_state, _mass_storage_id, decoder->ARDrone3MediaRecordStateVideoStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCb (_state, _mass_storage_id, ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaRecordStatePictureStateChangedV2Callback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Cb))
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state;
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaRecordStatePictureStateChangedV2Callback) {
                                decoder->ARDrone3MediaRecordStatePictureStateChangedV2Callback (_state, _error, decoder->ARDrone3MediaRecordStatePictureStateChangedV2Custom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Cb (_state, _error, ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Custom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2 */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaRecordStateVideoStateChangedV2Callback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Cb))
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE _state;
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaRecordStateVideoStateChangedV2Callback) {
                                decoder->ARDrone3MediaRecordStateVideoStateChangedV2Callback (_state, _error, decoder->ARDrone3MediaRecordStateVideoStateChangedV2Custom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Cb (_state, _error, ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Custom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2 */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEORESOLUTIONSTATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaRecordStateVideoResolutionStateCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoResolutionStateCb))
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_STREAMING _streaming;
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_RECORDING _recording;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _streaming = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_STREAMING)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _recording = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_RECORDING)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaRecordStateVideoResolutionStateCallback) {
                                decoder->ARDrone3MediaRecordStateVideoResolutionStateCallback (_streaming, _recording, decoder->ARDrone3MediaRecordStateVideoResolutionStateCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoResolutionStateCb (_streaming, _recording, ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoResolutionStateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEORESOLUTIONSTATE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaRecordEventPictureEventChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event;
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _event = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaRecordEventPictureEventChangedCallback) {
                                decoder->ARDrone3MediaRecordEventPictureEventChangedCallback (_event, _error, decoder->ARDrone3MediaRecordEventPictureEventChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCb (_event, _error, ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaRecordEventVideoEventChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT _event;
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _event = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaRecordEventVideoEventChangedCallback) {
                                decoder->ARDrone3MediaRecordEventVideoEventChangedCallback (_event, _error, decoder->ARDrone3MediaRecordEventVideoEventChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCb (_event, _error, ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDEVENT */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLATTRIMCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingStateFlatTrimChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingStateFlatTrimChangedCallback) {
                                decoder->ARDrone3PilotingStateFlatTrimChangedCallback (decoder->ARDrone3PilotingStateFlatTrimChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCb (ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLATTRIMCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLYINGSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingStateFlyingStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingStateFlyingStateChangedCallback) {
                                decoder->ARDrone3PilotingStateFlyingStateChangedCallback (_state, decoder->ARDrone3PilotingStateFlyingStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCb (_state, ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLYINGSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALERTSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingStateAlertStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingStateAlertStateChangedCallback) {
                                decoder->ARDrone3PilotingStateAlertStateChangedCallback (_state, decoder->ARDrone3PilotingStateAlertStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCb (_state, ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALERTSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_NAVIGATEHOMESTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingStateNavigateHomeStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE _state;
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON _reason;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _reason = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingStateNavigateHomeStateChangedCallback) {
                                decoder->ARDrone3PilotingStateNavigateHomeStateChangedCallback (_state, _reason, decoder->ARDrone3PilotingStateNavigateHomeStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCb (_state, _reason, ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_NAVIGATEHOMESTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_POSITIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingStatePositionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCb))
                    {
                        double _latitude;
                        double _longitude;
                        double _altitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingStatePositionChangedCallback) {
                                decoder->ARDrone3PilotingStatePositionChangedCallback (_latitude, _longitude, _altitude, decoder->ARDrone3PilotingStatePositionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCb (_latitude, _longitude, _altitude, ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_POSITIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_SPEEDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingStateSpeedChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCb))
                    {
                        float _speedX;
                        float _speedY;
                        float _speedZ;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speedX = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speedY = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speedZ = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingStateSpeedChangedCallback) {
                                decoder->ARDrone3PilotingStateSpeedChangedCallback (_speedX, _speedY, _speedZ, decoder->ARDrone3PilotingStateSpeedChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCb (_speedX, _speedY, _speedZ, ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_SPEEDCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ATTITUDECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingStateAttitudeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCb))
                    {
                        float _roll;
                        float _pitch;
                        float _yaw;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _roll = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _pitch = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _yaw = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingStateAttitudeChangedCallback) {
                                decoder->ARDrone3PilotingStateAttitudeChangedCallback (_roll, _pitch, _yaw, decoder->ARDrone3PilotingStateAttitudeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCb (_roll, _pitch, _yaw, ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ATTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_AUTOTAKEOFFMODECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingStateAutoTakeOffModeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCb))
                    {
                        uint8_t _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingStateAutoTakeOffModeChangedCallback) {
                                decoder->ARDrone3PilotingStateAutoTakeOffModeChangedCallback (_state, decoder->ARDrone3PilotingStateAutoTakeOffModeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCb (_state, ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_AUTOTAKEOFFMODECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALTITUDECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingStateAltitudeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCb))
                    {
                        double _altitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingStateAltitudeChangedCallback) {
                                decoder->ARDrone3PilotingStateAltitudeChangedCallback (_altitude, decoder->ARDrone3PilotingStateAltitudeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCb (_altitude, ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_GPSLOCATIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingStateGpsLocationChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingStateGpsLocationChangedCb))
                    {
                        double _latitude;
                        double _longitude;
                        double _altitude;
                        int8_t _latitude_accuracy;
                        int8_t _longitude_accuracy;
                        int8_t _altitude_accuracy;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude_accuracy =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude_accuracy =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude_accuracy =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingStateGpsLocationChangedCallback) {
                                decoder->ARDrone3PilotingStateGpsLocationChangedCallback (_latitude, _longitude, _altitude, _latitude_accuracy, _longitude_accuracy, _altitude_accuracy, decoder->ARDrone3PilotingStateGpsLocationChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingStateGpsLocationChangedCb (_latitude, _longitude, _altitude, _latitude_accuracy, _longitude_accuracy, _altitude_accuracy, ARCOMMANDS_Decoder_ARDrone3PilotingStateGpsLocationChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_GPSLOCATIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_LANDINGSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingStateLandingStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingStateLandingStateChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_LANDINGSTATECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_LANDINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingStateLandingStateChangedCallback) {
                                decoder->ARDrone3PilotingStateLandingStateChangedCallback (_state, decoder->ARDrone3PilotingStateLandingStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingStateLandingStateChangedCb (_state, ARCOMMANDS_Decoder_ARDrone3PilotingStateLandingStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_LANDINGSTATECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGEVENT_CMD_MOVEBYEND:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingEventMoveByEndCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingEventMoveByEndCb))
                    {
                        float _dX;
                        float _dY;
                        float _dZ;
                        float _dPsi;
                        eARCOMMANDS_ARDRONE3_PILOTINGEVENT_MOVEBYEND_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _dX = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _dY = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _dZ = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _dPsi = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_ARDRONE3_PILOTINGEVENT_MOVEBYEND_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingEventMoveByEndCallback) {
                                decoder->ARDrone3PilotingEventMoveByEndCallback (_dX, _dY, _dZ, _dPsi, _error, decoder->ARDrone3PilotingEventMoveByEndCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingEventMoveByEndCb (_dX, _dY, _dZ, _dPsi, _error, ARCOMMANDS_Decoder_ARDrone3PilotingEventMoveByEndCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGEVENT_CMD_MOVEBYEND */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGEVENT */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFISCAN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3NetworkWifiScanCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCb))
                    {
                        eARCOMMANDS_ARDRONE3_NETWORK_WIFISCAN_BAND _band;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_ARDRONE3_NETWORK_WIFISCAN_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3NetworkWifiScanCallback) {
                                decoder->ARDrone3NetworkWifiScanCallback (_band, decoder->ARDrone3NetworkWifiScanCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCb (_band, ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFISCAN */
                case ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFIAUTHCHANNEL:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3NetworkWifiAuthChannelCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3NetworkWifiAuthChannelCallback) {
                                decoder->ARDrone3NetworkWifiAuthChannelCallback (decoder->ARDrone3NetworkWifiAuthChannelCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCb (ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFIAUTHCHANNEL */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORK */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFISCANLISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3NetworkStateWifiScanListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCb))
                    {
                        char * _ssid = NULL;
                        int16_t _rssi;
                        eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rssi =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3NetworkStateWifiScanListChangedCallback) {
                                decoder->ARDrone3NetworkStateWifiScanListChangedCallback (_ssid, _rssi, _band, _channel, decoder->ARDrone3NetworkStateWifiScanListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCb (_ssid, _rssi, _band, _channel, ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFISCANLISTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFISCANCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3NetworkStateAllWifiScanChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3NetworkStateAllWifiScanChangedCallback) {
                                decoder->ARDrone3NetworkStateAllWifiScanChangedCallback (decoder->ARDrone3NetworkStateAllWifiScanChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCb (ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFISCANCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3NetworkStateWifiAuthChannelListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band;
                        uint8_t _channel;
                        uint8_t _in_or_out;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _in_or_out = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3NetworkStateWifiAuthChannelListChangedCallback) {
                                decoder->ARDrone3NetworkStateWifiAuthChannelListChangedCallback (_band, _channel, _in_or_out, decoder->ARDrone3NetworkStateWifiAuthChannelListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCb (_band, _channel, _in_or_out, ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3NetworkStateAllWifiAuthChannelChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3NetworkStateAllWifiAuthChannelChangedCallback) {
                                decoder->ARDrone3NetworkStateAllWifiAuthChannelChangedCallback (decoder->ARDrone3NetworkStateAllWifiAuthChannelChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCb (ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXALTITUDE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsMaxAltitudeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCb))
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsMaxAltitudeCallback) {
                                decoder->ARDrone3PilotingSettingsMaxAltitudeCallback (_current, decoder->ARDrone3PilotingSettingsMaxAltitudeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCb (_current, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXALTITUDE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXTILT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsMaxTiltCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCb))
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsMaxTiltCallback) {
                                decoder->ARDrone3PilotingSettingsMaxTiltCallback (_current, decoder->ARDrone3PilotingSettingsMaxTiltCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCb (_current, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXTILT */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_ABSOLUTCONTROL:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsAbsolutControlCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCb))
                    {
                        uint8_t _on;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _on = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsAbsolutControlCallback) {
                                decoder->ARDrone3PilotingSettingsAbsolutControlCallback (_on, decoder->ARDrone3PilotingSettingsAbsolutControlCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCb (_on, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_ABSOLUTCONTROL */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXDISTANCE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsMaxDistanceCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsMaxDistanceCallback) {
                                decoder->ARDrone3PilotingSettingsMaxDistanceCallback (_value, decoder->ARDrone3PilotingSettingsMaxDistanceCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXDISTANCE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_NOFLYOVERMAXDISTANCE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCb))
                    {
                        uint8_t _shouldNotFlyOver;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _shouldNotFlyOver = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback) {
                                decoder->ARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback (_shouldNotFlyOver, decoder->ARDrone3PilotingSettingsNoFlyOverMaxDistanceCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCb (_shouldNotFlyOver, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_NOFLYOVERMAXDISTANCE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXHORIZONTALSPEED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCallback) {
                                decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCallback (_value, decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXHORIZONTALSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXVERTICALSPEED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCallback) {
                                decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCallback (_value, decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXVERTICALSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXHORIZONTALACCELERATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCallback) {
                                decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCallback (_value, decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXHORIZONTALACCELERATION */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXVERTICALACCELERATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCallback) {
                                decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCallback (_value, decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXVERTICALACCELERATION */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXROTATIONSPEED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCallback) {
                                decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCallback (_value, decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXROTATIONSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_BANKEDTURN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsBankedTurnCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsBankedTurnCb))
                    {
                        uint8_t _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsBankedTurnCallback) {
                                decoder->ARDrone3PilotingSettingsBankedTurnCallback (_value, decoder->ARDrone3PilotingSettingsBankedTurnCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsBankedTurnCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsBankedTurnCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_BANKEDTURN */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MINALTITUDE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsMinAltitudeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMinAltitudeCb))
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsMinAltitudeCallback) {
                                decoder->ARDrone3PilotingSettingsMinAltitudeCallback (_current, decoder->ARDrone3PilotingSettingsMinAltitudeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMinAltitudeCb (_current, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMinAltitudeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MINALTITUDE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGDIRECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsCirclingDirectionCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingDirectionCb))
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_CIRCLINGDIRECTION_VALUE _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_CIRCLINGDIRECTION_VALUE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsCirclingDirectionCallback) {
                                decoder->ARDrone3PilotingSettingsCirclingDirectionCallback (_value, decoder->ARDrone3PilotingSettingsCirclingDirectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingDirectionCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingDirectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGDIRECTION */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGRADIUS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsCirclingRadiusCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingRadiusCb))
                    {
                        uint16_t _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsCirclingRadiusCallback) {
                                decoder->ARDrone3PilotingSettingsCirclingRadiusCallback (_value, decoder->ARDrone3PilotingSettingsCirclingRadiusCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingRadiusCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingRadiusCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGRADIUS */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGALTITUDE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsCirclingAltitudeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingAltitudeCb))
                    {
                        uint16_t _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsCirclingAltitudeCallback) {
                                decoder->ARDrone3PilotingSettingsCirclingAltitudeCallback (_value, decoder->ARDrone3PilotingSettingsCirclingAltitudeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingAltitudeCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingAltitudeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGALTITUDE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_PITCHMODE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsPitchModeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsPitchModeCb))
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_PITCHMODE_VALUE _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_PITCHMODE_VALUE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsPitchModeCallback) {
                                decoder->ARDrone3PilotingSettingsPitchModeCallback (_value, decoder->ARDrone3PilotingSettingsPitchModeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsPitchModeCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsPitchModeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_PITCHMODE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXALTITUDECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateMaxAltitudeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCb))
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateMaxAltitudeChangedCallback) {
                                decoder->ARDrone3PilotingSettingsStateMaxAltitudeChangedCallback (_current, _min, _max, decoder->ARDrone3PilotingSettingsStateMaxAltitudeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXALTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXTILTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateMaxTiltChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCb))
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateMaxTiltChangedCallback) {
                                decoder->ARDrone3PilotingSettingsStateMaxTiltChangedCallback (_current, _min, _max, decoder->ARDrone3PilotingSettingsStateMaxTiltChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXTILTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_ABSOLUTCONTROLCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateAbsolutControlChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCb))
                    {
                        uint8_t _on;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _on = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateAbsolutControlChangedCallback) {
                                decoder->ARDrone3PilotingSettingsStateAbsolutControlChangedCallback (_on, decoder->ARDrone3PilotingSettingsStateAbsolutControlChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCb (_on, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_ABSOLUTCONTROLCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXDISTANCECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateMaxDistanceChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCb))
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateMaxDistanceChangedCallback) {
                                decoder->ARDrone3PilotingSettingsStateMaxDistanceChangedCallback (_current, _min, _max, decoder->ARDrone3PilotingSettingsStateMaxDistanceChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXDISTANCECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_NOFLYOVERMAXDISTANCECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCb))
                    {
                        uint8_t _shouldNotFlyOver;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _shouldNotFlyOver = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback) {
                                decoder->ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback (_shouldNotFlyOver, decoder->ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCb (_shouldNotFlyOver, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_NOFLYOVERMAXDISTANCECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXHORIZONTALSPEED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback) {
                                decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback (_value, decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXHORIZONTALSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXVERTICALSPEED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback) {
                                decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback (_value, decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXVERTICALSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXHORIZONTALACCELERATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback) {
                                decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback (_value, decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXHORIZONTALACCELERATION */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXVERTICALACCELERATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback) {
                                decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback (_value, decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXVERTICALACCELERATION */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXROTATIONSPEED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback) {
                                decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback (_value, decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXROTATIONSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_BANKEDTURNCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateBankedTurnChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateBankedTurnChangedCb))
                    {
                        uint8_t _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateBankedTurnChangedCallback) {
                                decoder->ARDrone3PilotingSettingsStateBankedTurnChangedCallback (_state, decoder->ARDrone3PilotingSettingsStateBankedTurnChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateBankedTurnChangedCb (_state, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateBankedTurnChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_BANKEDTURNCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MINALTITUDECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateMinAltitudeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMinAltitudeChangedCb))
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateMinAltitudeChangedCallback) {
                                decoder->ARDrone3PilotingSettingsStateMinAltitudeChangedCallback (_current, _min, _max, decoder->ARDrone3PilotingSettingsStateMinAltitudeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMinAltitudeChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMinAltitudeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MINALTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGDIRECTIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateCirclingDirectionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingDirectionChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED_VALUE _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED_VALUE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateCirclingDirectionChangedCallback) {
                                decoder->ARDrone3PilotingSettingsStateCirclingDirectionChangedCallback (_value, decoder->ARDrone3PilotingSettingsStateCirclingDirectionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingDirectionChangedCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingDirectionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGDIRECTIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGRADIUSCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateCirclingRadiusChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingRadiusChangedCb))
                    {
                        uint16_t _current;
                        uint16_t _min;
                        uint16_t _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateCirclingRadiusChangedCallback) {
                                decoder->ARDrone3PilotingSettingsStateCirclingRadiusChangedCallback (_current, _min, _max, decoder->ARDrone3PilotingSettingsStateCirclingRadiusChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingRadiusChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingRadiusChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGRADIUSCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGALTITUDECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateCirclingAltitudeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingAltitudeChangedCb))
                    {
                        uint16_t _current;
                        uint16_t _min;
                        uint16_t _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateCirclingAltitudeChangedCallback) {
                                decoder->ARDrone3PilotingSettingsStateCirclingAltitudeChangedCallback (_current, _min, _max, decoder->ARDrone3PilotingSettingsStateCirclingAltitudeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingAltitudeChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingAltitudeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGALTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_PITCHMODECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStatePitchModeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStatePitchModeChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED_VALUE _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED_VALUE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStatePitchModeChangedCallback) {
                                decoder->ARDrone3PilotingSettingsStatePitchModeChangedCallback (_value, decoder->ARDrone3PilotingSettingsStatePitchModeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStatePitchModeChangedCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStatePitchModeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_PITCHMODECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXVERTICALSPEED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SpeedSettingsMaxVerticalSpeedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCb))
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SpeedSettingsMaxVerticalSpeedCallback) {
                                decoder->ARDrone3SpeedSettingsMaxVerticalSpeedCallback (_current, decoder->ARDrone3SpeedSettingsMaxVerticalSpeedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCb (_current, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXVERTICALSPEED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXROTATIONSPEED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SpeedSettingsMaxRotationSpeedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCb))
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SpeedSettingsMaxRotationSpeedCallback) {
                                decoder->ARDrone3SpeedSettingsMaxRotationSpeedCallback (_current, decoder->ARDrone3SpeedSettingsMaxRotationSpeedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCb (_current, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXROTATIONSPEED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_HULLPROTECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SpeedSettingsHullProtectionCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCb))
                    {
                        uint8_t _present;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _present = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SpeedSettingsHullProtectionCallback) {
                                decoder->ARDrone3SpeedSettingsHullProtectionCallback (_present, decoder->ARDrone3SpeedSettingsHullProtectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCb (_present, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_HULLPROTECTION */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_OUTDOOR:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SpeedSettingsOutdoorCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCb))
                    {
                        uint8_t _outdoor;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _outdoor = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SpeedSettingsOutdoorCallback) {
                                decoder->ARDrone3SpeedSettingsOutdoorCallback (_outdoor, decoder->ARDrone3SpeedSettingsOutdoorCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCb (_outdoor, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_OUTDOOR */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXPITCHROLLROTATIONSPEED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCb))
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCallback) {
                                decoder->ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCallback (_current, decoder->ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCb (_current, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXPITCHROLLROTATIONSPEED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXVERTICALSPEEDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCb))
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback) {
                                decoder->ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback (_current, _min, _max, decoder->ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXVERTICALSPEEDCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXROTATIONSPEEDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCb))
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback) {
                                decoder->ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback (_current, _min, _max, decoder->ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXROTATIONSPEEDCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_HULLPROTECTIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SpeedSettingsStateHullProtectionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCb))
                    {
                        uint8_t _present;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _present = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SpeedSettingsStateHullProtectionChangedCallback) {
                                decoder->ARDrone3SpeedSettingsStateHullProtectionChangedCallback (_present, decoder->ARDrone3SpeedSettingsStateHullProtectionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCb (_present, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_HULLPROTECTIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_OUTDOORCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SpeedSettingsStateOutdoorChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCb))
                    {
                        uint8_t _outdoor;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _outdoor = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SpeedSettingsStateOutdoorChangedCallback) {
                                decoder->ARDrone3SpeedSettingsStateOutdoorChangedCallback (_outdoor, decoder->ARDrone3SpeedSettingsStateOutdoorChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCb (_outdoor, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_OUTDOORCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXPITCHROLLROTATIONSPEEDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCb))
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback) {
                                decoder->ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback (_current, _min, _max, decoder->ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXPITCHROLLROTATIONSPEEDCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGS_CMD_WIFISELECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3NetworkSettingsWifiSelectionCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCb))
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_TYPE _type;
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3NetworkSettingsWifiSelectionCallback) {
                                decoder->ARDrone3NetworkSettingsWifiSelectionCallback (_type, _band, _channel, decoder->ARDrone3NetworkSettingsWifiSelectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCb (_type, _band, _channel, ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGS_CMD_WIFISELECTION */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGS_CMD_WIFISECURITY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3NetworkSettingsWifiSecurityCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSecurityCb))
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_TYPE _type;
                        char * _key = NULL;
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_KEYTYPE _keyType;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _key = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _keyType = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_KEYTYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3NetworkSettingsWifiSecurityCallback) {
                                decoder->ARDrone3NetworkSettingsWifiSecurityCallback (_type, _key, _keyType, decoder->ARDrone3NetworkSettingsWifiSecurityCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSecurityCb (_type, _key, _keyType, ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSecurityCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGS_CMD_WIFISECURITY */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3NetworkSettingsStateWifiSelectionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type;
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3NetworkSettingsStateWifiSelectionChangedCallback) {
                                decoder->ARDrone3NetworkSettingsStateWifiSelectionChangedCallback (_type, _band, _channel, decoder->ARDrone3NetworkSettingsStateWifiSelectionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCb (_type, _band, _channel, ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISECURITYCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3NetworkSettingsStateWifiSecurityChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITYCHANGED_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITYCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3NetworkSettingsStateWifiSecurityChangedCallback) {
                                decoder->ARDrone3NetworkSettingsStateWifiSecurityChangedCallback (_type, decoder->ARDrone3NetworkSettingsStateWifiSecurityChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityChangedCb (_type, ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISECURITYCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISECURITY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3NetworkSettingsStateWifiSecurityCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityCb))
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_TYPE _type;
                        char * _key = NULL;
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_KEYTYPE _keyType;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _key = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _keyType = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_KEYTYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3NetworkSettingsStateWifiSecurityCallback) {
                                decoder->ARDrone3NetworkSettingsStateWifiSecurityCallback (_type, _key, _keyType, decoder->ARDrone3NetworkSettingsStateWifiSecurityCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityCb (_type, _key, _keyType, ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISECURITY */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTMOTORVERSIONLISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SettingsStateProductMotorVersionListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCb))
                    {
                        uint8_t _motor_number;
                        char * _type = NULL;
                        char * _software = NULL;
                        char * _hardware = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _motor_number = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _software = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _hardware = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SettingsStateProductMotorVersionListChangedCallback) {
                                decoder->ARDrone3SettingsStateProductMotorVersionListChangedCallback (_motor_number, _type, _software, _hardware, decoder->ARDrone3SettingsStateProductMotorVersionListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCb (_motor_number, _type, _software, _hardware, ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTMOTORVERSIONLISTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTGPSVERSIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SettingsStateProductGPSVersionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCb))
                    {
                        char * _software = NULL;
                        char * _hardware = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _software = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _hardware = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SettingsStateProductGPSVersionChangedCallback) {
                                decoder->ARDrone3SettingsStateProductGPSVersionChangedCallback (_software, _hardware, decoder->ARDrone3SettingsStateProductGPSVersionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCb (_software, _hardware, ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTGPSVERSIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SettingsStateMotorErrorStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCb))
                    {
                        uint8_t _motorIds;
                        eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR _motorError;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _motorIds = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _motorError = (eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SettingsStateMotorErrorStateChangedCallback) {
                                decoder->ARDrone3SettingsStateMotorErrorStateChangedCallback (_motorIds, _motorError, decoder->ARDrone3SettingsStateMotorErrorStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCb (_motorIds, _motorError, ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORSOFTWAREVERSIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SettingsStateMotorSoftwareVersionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCb))
                    {
                        char * _version = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _version = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SettingsStateMotorSoftwareVersionChangedCallback) {
                                decoder->ARDrone3SettingsStateMotorSoftwareVersionChangedCallback (_version, decoder->ARDrone3SettingsStateMotorSoftwareVersionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCb (_version, ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORSOFTWAREVERSIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORFLIGHTSSTATUSCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SettingsStateMotorFlightsStatusChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCb))
                    {
                        uint16_t _nbFlights;
                        uint16_t _lastFlightDuration;
                        uint32_t _totalFlightDuration;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbFlights = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _lastFlightDuration = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _totalFlightDuration = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SettingsStateMotorFlightsStatusChangedCallback) {
                                decoder->ARDrone3SettingsStateMotorFlightsStatusChangedCallback (_nbFlights, _lastFlightDuration, _totalFlightDuration, decoder->ARDrone3SettingsStateMotorFlightsStatusChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCb (_nbFlights, _lastFlightDuration, _totalFlightDuration, ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORFLIGHTSSTATUSCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORLASTERRORCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SettingsStateMotorErrorLastErrorChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR _motorError;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _motorError = (eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SettingsStateMotorErrorLastErrorChangedCallback) {
                                decoder->ARDrone3SettingsStateMotorErrorLastErrorChangedCallback (_motorError, decoder->ARDrone3SettingsStateMotorErrorLastErrorChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCb (_motorError, ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORLASTERRORCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_P7ID:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SettingsStateP7IDCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCb))
                    {
                        char * _serialID = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _serialID = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SettingsStateP7IDCallback) {
                                decoder->ARDrone3SettingsStateP7IDCallback (_serialID, decoder->ARDrone3SettingsStateP7IDCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCb (_serialID, ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_P7ID */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_CPUID:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SettingsStateCPUIDCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SettingsStateCPUIDCb))
                    {
                        char * _id = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _id = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SettingsStateCPUIDCallback) {
                                decoder->ARDrone3SettingsStateCPUIDCallback (_id, decoder->ARDrone3SettingsStateCPUIDCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SettingsStateCPUIDCb (_id, ARCOMMANDS_Decoder_ARDrone3SettingsStateCPUIDCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_CPUID */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_PICTUREFORMATSELECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsPictureFormatSelectionCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_PICTUREFORMATSELECTION_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_PICTUREFORMATSELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsPictureFormatSelectionCallback) {
                                decoder->ARDrone3PictureSettingsPictureFormatSelectionCallback (_type, decoder->ARDrone3PictureSettingsPictureFormatSelectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCb (_type, ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_PICTUREFORMATSELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_AUTOWHITEBALANCESELECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_AUTOWHITEBALANCESELECTION_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_AUTOWHITEBALANCESELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback) {
                                decoder->ARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback (_type, decoder->ARDrone3PictureSettingsAutoWhiteBalanceSelectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCb (_type, ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_AUTOWHITEBALANCESELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_EXPOSITIONSELECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsExpositionSelectionCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsExpositionSelectionCallback) {
                                decoder->ARDrone3PictureSettingsExpositionSelectionCallback (_value, decoder->ARDrone3PictureSettingsExpositionSelectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCb (_value, ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_EXPOSITIONSELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_SATURATIONSELECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsSaturationSelectionCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsSaturationSelectionCallback) {
                                decoder->ARDrone3PictureSettingsSaturationSelectionCallback (_value, decoder->ARDrone3PictureSettingsSaturationSelectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCb (_value, ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_SATURATIONSELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_TIMELAPSESELECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsTimelapseSelectionCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCb))
                    {
                        uint8_t _enabled;
                        float _interval;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _interval = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsTimelapseSelectionCallback) {
                                decoder->ARDrone3PictureSettingsTimelapseSelectionCallback (_enabled, _interval, decoder->ARDrone3PictureSettingsTimelapseSelectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCb (_enabled, _interval, ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_TIMELAPSESELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOAUTORECORDSELECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsVideoAutorecordSelectionCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCb))
                    {
                        uint8_t _enabled;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsVideoAutorecordSelectionCallback) {
                                decoder->ARDrone3PictureSettingsVideoAutorecordSelectionCallback (_enabled, _mass_storage_id, decoder->ARDrone3PictureSettingsVideoAutorecordSelectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCb (_enabled, _mass_storage_id, ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOAUTORECORDSELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOSTABILIZATIONMODE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsVideoStabilizationModeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoStabilizationModeCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOSTABILIZATIONMODE_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOSTABILIZATIONMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsVideoStabilizationModeCallback) {
                                decoder->ARDrone3PictureSettingsVideoStabilizationModeCallback (_mode, decoder->ARDrone3PictureSettingsVideoStabilizationModeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoStabilizationModeCb (_mode, ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoStabilizationModeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOSTABILIZATIONMODE */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEORECORDINGMODE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsVideoRecordingModeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoRecordingModeCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORECORDINGMODE_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORECORDINGMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsVideoRecordingModeCallback) {
                                decoder->ARDrone3PictureSettingsVideoRecordingModeCallback (_mode, decoder->ARDrone3PictureSettingsVideoRecordingModeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoRecordingModeCb (_mode, ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoRecordingModeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEORECORDINGMODE */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOFRAMERATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsVideoFramerateCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoFramerateCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOFRAMERATE_FRAMERATE _framerate;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _framerate = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOFRAMERATE_FRAMERATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsVideoFramerateCallback) {
                                decoder->ARDrone3PictureSettingsVideoFramerateCallback (_framerate, decoder->ARDrone3PictureSettingsVideoFramerateCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoFramerateCb (_framerate, ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoFramerateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOFRAMERATE */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEORESOLUTIONS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsVideoResolutionsCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoResolutionsCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORESOLUTIONS_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORESOLUTIONS_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsVideoResolutionsCallback) {
                                decoder->ARDrone3PictureSettingsVideoResolutionsCallback (_type, decoder->ARDrone3PictureSettingsVideoResolutionsCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoResolutionsCb (_type, ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoResolutionsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEORESOLUTIONS */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_PICTUREFORMATCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsStatePictureFormatChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsStatePictureFormatChangedCallback) {
                                decoder->ARDrone3PictureSettingsStatePictureFormatChangedCallback (_type, decoder->ARDrone3PictureSettingsStatePictureFormatChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCb (_type, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_PICTUREFORMATCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_AUTOWHITEBALANCECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback) {
                                decoder->ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback (_type, decoder->ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCb (_type, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_AUTOWHITEBALANCECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_EXPOSITIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsStateExpositionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCb))
                    {
                        float _value;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsStateExpositionChangedCallback) {
                                decoder->ARDrone3PictureSettingsStateExpositionChangedCallback (_value, _min, _max, decoder->ARDrone3PictureSettingsStateExpositionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCb (_value, _min, _max, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_EXPOSITIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_SATURATIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsStateSaturationChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCb))
                    {
                        float _value;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsStateSaturationChangedCallback) {
                                decoder->ARDrone3PictureSettingsStateSaturationChangedCallback (_value, _min, _max, decoder->ARDrone3PictureSettingsStateSaturationChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCb (_value, _min, _max, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_SATURATIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_TIMELAPSECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsStateTimelapseChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCb))
                    {
                        uint8_t _enabled;
                        float _interval;
                        float _minInterval;
                        float _maxInterval;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _interval = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _minInterval = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _maxInterval = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsStateTimelapseChangedCallback) {
                                decoder->ARDrone3PictureSettingsStateTimelapseChangedCallback (_enabled, _interval, _minInterval, _maxInterval, decoder->ARDrone3PictureSettingsStateTimelapseChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCb (_enabled, _interval, _minInterval, _maxInterval, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_TIMELAPSECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOAUTORECORDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsStateVideoAutorecordChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCb))
                    {
                        uint8_t _enabled;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsStateVideoAutorecordChangedCallback) {
                                decoder->ARDrone3PictureSettingsStateVideoAutorecordChangedCallback (_enabled, _mass_storage_id, decoder->ARDrone3PictureSettingsStateVideoAutorecordChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCb (_enabled, _mass_storage_id, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOAUTORECORDCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOSTABILIZATIONMODECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsStateVideoStabilizationModeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoStabilizationModeChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsStateVideoStabilizationModeChangedCallback) {
                                decoder->ARDrone3PictureSettingsStateVideoStabilizationModeChangedCallback (_mode, decoder->ARDrone3PictureSettingsStateVideoStabilizationModeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoStabilizationModeChangedCb (_mode, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoStabilizationModeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOSTABILIZATIONMODECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEORECORDINGMODECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsStateVideoRecordingModeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoRecordingModeChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORECORDINGMODECHANGED_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORECORDINGMODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsStateVideoRecordingModeChangedCallback) {
                                decoder->ARDrone3PictureSettingsStateVideoRecordingModeChangedCallback (_mode, decoder->ARDrone3PictureSettingsStateVideoRecordingModeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoRecordingModeChangedCb (_mode, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoRecordingModeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEORECORDINGMODECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOFRAMERATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsStateVideoFramerateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoFramerateChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOFRAMERATECHANGED_FRAMERATE _framerate;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _framerate = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOFRAMERATECHANGED_FRAMERATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsStateVideoFramerateChangedCallback) {
                                decoder->ARDrone3PictureSettingsStateVideoFramerateChangedCallback (_framerate, decoder->ARDrone3PictureSettingsStateVideoFramerateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoFramerateChangedCb (_framerate, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoFramerateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOFRAMERATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEORESOLUTIONSCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsStateVideoResolutionsChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoResolutionsChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORESOLUTIONSCHANGED_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORESOLUTIONSCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsStateVideoResolutionsChangedCallback) {
                                decoder->ARDrone3PictureSettingsStateVideoResolutionsChangedCallback (_type, decoder->ARDrone3PictureSettingsStateVideoResolutionsChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoResolutionsChangedCb (_type, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoResolutionsChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEORESOLUTIONSCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMING_CMD_VIDEOENABLE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaStreamingVideoEnableCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCb))
                    {
                        uint8_t _enable;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enable = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaStreamingVideoEnableCallback) {
                                decoder->ARDrone3MediaStreamingVideoEnableCallback (_enable, decoder->ARDrone3MediaStreamingVideoEnableCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCb (_enable, ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMING_CMD_VIDEOENABLE */
                case ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMING_CMD_VIDEOSTREAMMODE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaStreamingVideoStreamModeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoStreamModeCb))
                    {
                        eARCOMMANDS_ARDRONE3_MEDIASTREAMING_VIDEOSTREAMMODE_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_ARDRONE3_MEDIASTREAMING_VIDEOSTREAMMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaStreamingVideoStreamModeCallback) {
                                decoder->ARDrone3MediaStreamingVideoStreamModeCallback (_mode, decoder->ARDrone3MediaStreamingVideoStreamModeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoStreamModeCb (_mode, ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoStreamModeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMING_CMD_VIDEOSTREAMMODE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMING */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaStreamingStateVideoEnableChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED _enabled;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = (eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaStreamingStateVideoEnableChangedCallback) {
                                decoder->ARDrone3MediaStreamingStateVideoEnableChangedCallback (_enabled, decoder->ARDrone3MediaStreamingStateVideoEnableChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCb (_enabled, ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMINGSTATE_CMD_VIDEOSTREAMMODECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaStreamingStateVideoStreamModeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoStreamModeChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOSTREAMMODECHANGED_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOSTREAMMODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaStreamingStateVideoStreamModeChangedCallback) {
                                decoder->ARDrone3MediaStreamingStateVideoStreamModeChangedCallback (_mode, decoder->ARDrone3MediaStreamingStateVideoStreamModeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoStreamModeChangedCb (_mode, ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoStreamModeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMINGSTATE_CMD_VIDEOSTREAMMODECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMINGSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SETHOME:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSSettingsSetHomeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCb))
                    {
                        double _latitude;
                        double _longitude;
                        double _altitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSSettingsSetHomeCallback) {
                                decoder->ARDrone3GPSSettingsSetHomeCallback (_latitude, _longitude, _altitude, decoder->ARDrone3GPSSettingsSetHomeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCb (_latitude, _longitude, _altitude, ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SETHOME */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RESETHOME:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSSettingsResetHomeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSSettingsResetHomeCallback) {
                                decoder->ARDrone3GPSSettingsResetHomeCallback (decoder->ARDrone3GPSSettingsResetHomeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCb (ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RESETHOME */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SENDCONTROLLERGPS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSSettingsSendControllerGPSCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCb))
                    {
                        double _latitude;
                        double _longitude;
                        double _altitude;
                        double _horizontalAccuracy;
                        double _verticalAccuracy;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _horizontalAccuracy = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _verticalAccuracy = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSSettingsSendControllerGPSCallback) {
                                decoder->ARDrone3GPSSettingsSendControllerGPSCallback (_latitude, _longitude, _altitude, _horizontalAccuracy, _verticalAccuracy, decoder->ARDrone3GPSSettingsSendControllerGPSCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCb (_latitude, _longitude, _altitude, _horizontalAccuracy, _verticalAccuracy, ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SENDCONTROLLERGPS */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_HOMETYPE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSSettingsHomeTypeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCb))
                    {
                        eARCOMMANDS_ARDRONE3_GPSSETTINGS_HOMETYPE_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_GPSSETTINGS_HOMETYPE_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSSettingsHomeTypeCallback) {
                                decoder->ARDrone3GPSSettingsHomeTypeCallback (_type, decoder->ARDrone3GPSSettingsHomeTypeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCb (_type, ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_HOMETYPE */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RETURNHOMEDELAY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSSettingsReturnHomeDelayCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCb))
                    {
                        uint16_t _delay;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _delay = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSSettingsReturnHomeDelayCallback) {
                                decoder->ARDrone3GPSSettingsReturnHomeDelayCallback (_delay, decoder->ARDrone3GPSSettingsReturnHomeDelayCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCb (_delay, ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RETURNHOMEDELAY */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSSettingsStateHomeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCb))
                    {
                        double _latitude;
                        double _longitude;
                        double _altitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSSettingsStateHomeChangedCallback) {
                                decoder->ARDrone3GPSSettingsStateHomeChangedCallback (_latitude, _longitude, _altitude, decoder->ARDrone3GPSSettingsStateHomeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCb (_latitude, _longitude, _altitude, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RESETHOMECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSSettingsStateResetHomeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCb))
                    {
                        double _latitude;
                        double _longitude;
                        double _altitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSSettingsStateResetHomeChangedCallback) {
                                decoder->ARDrone3GPSSettingsStateResetHomeChangedCallback (_latitude, _longitude, _altitude, decoder->ARDrone3GPSSettingsStateResetHomeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCb (_latitude, _longitude, _altitude, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RESETHOMECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSFIXSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSSettingsStateGPSFixStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCb))
                    {
                        uint8_t _fixed;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _fixed = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSSettingsStateGPSFixStateChangedCallback) {
                                decoder->ARDrone3GPSSettingsStateGPSFixStateChangedCallback (_fixed, decoder->ARDrone3GPSSettingsStateGPSFixStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCb (_fixed, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSFIXSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSUPDATESTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSSettingsStateGPSUpdateStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSSettingsStateGPSUpdateStateChangedCallback) {
                                decoder->ARDrone3GPSSettingsStateGPSUpdateStateChangedCallback (_state, decoder->ARDrone3GPSSettingsStateGPSUpdateStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCb (_state, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSUPDATESTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMETYPECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSSettingsStateHomeTypeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSSettingsStateHomeTypeChangedCallback) {
                                decoder->ARDrone3GPSSettingsStateHomeTypeChangedCallback (_type, decoder->ARDrone3GPSSettingsStateHomeTypeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCb (_type, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMETYPECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RETURNHOMEDELAYCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSSettingsStateReturnHomeDelayChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCb))
                    {
                        uint16_t _delay;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _delay = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSSettingsStateReturnHomeDelayChangedCallback) {
                                decoder->ARDrone3GPSSettingsStateReturnHomeDelayChangedCallback (_delay, decoder->ARDrone3GPSSettingsStateReturnHomeDelayChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCb (_delay, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RETURNHOMEDELAYCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERASTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_CAMERASTATE_CMD_ORIENTATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3CameraStateOrientationCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCb))
                    {
                        int8_t _tilt;
                        int8_t _pan;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _tilt =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _pan =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3CameraStateOrientationCallback) {
                                decoder->ARDrone3CameraStateOrientationCallback (_tilt, _pan, decoder->ARDrone3CameraStateOrientationCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCb (_tilt, _pan, ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_CAMERASTATE_CMD_ORIENTATION */
                case ARCOMMANDS_ID_ARDRONE3_CAMERASTATE_CMD_DEFAULTCAMERAORIENTATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3CameraStateDefaultCameraOrientationCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3CameraStateDefaultCameraOrientationCb))
                    {
                        int8_t _tilt;
                        int8_t _pan;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _tilt =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _pan =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3CameraStateDefaultCameraOrientationCallback) {
                                decoder->ARDrone3CameraStateDefaultCameraOrientationCallback (_tilt, _pan, decoder->ARDrone3CameraStateDefaultCameraOrientationCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3CameraStateDefaultCameraOrientationCb (_tilt, _pan, ARCOMMANDS_Decoder_ARDrone3CameraStateDefaultCameraOrientationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_CAMERASTATE_CMD_DEFAULTCAMERAORIENTATION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERASTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_ELECTRICFREQUENCY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3AntiflickeringElectricFrequencyCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCb))
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERING_ELECTRICFREQUENCY_FREQUENCY _frequency;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _frequency = (eARCOMMANDS_ARDRONE3_ANTIFLICKERING_ELECTRICFREQUENCY_FREQUENCY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3AntiflickeringElectricFrequencyCallback) {
                                decoder->ARDrone3AntiflickeringElectricFrequencyCallback (_frequency, decoder->ARDrone3AntiflickeringElectricFrequencyCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCb (_frequency, ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_ELECTRICFREQUENCY */
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_SETMODE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3AntiflickeringSetModeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCb))
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERING_SETMODE_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_ARDRONE3_ANTIFLICKERING_SETMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3AntiflickeringSetModeCallback) {
                                decoder->ARDrone3AntiflickeringSetModeCallback (_mode, decoder->ARDrone3AntiflickeringSetModeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCb (_mode, ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_SETMODE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERING */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_ELECTRICFREQUENCYCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3AntiflickeringStateElectricFrequencyChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY _frequency;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _frequency = (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3AntiflickeringStateElectricFrequencyChangedCallback) {
                                decoder->ARDrone3AntiflickeringStateElectricFrequencyChangedCallback (_frequency, decoder->ARDrone3AntiflickeringStateElectricFrequencyChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCb (_frequency, ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_ELECTRICFREQUENCYCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_MODECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3AntiflickeringStateModeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3AntiflickeringStateModeChangedCallback) {
                                decoder->ARDrone3AntiflickeringStateModeChangedCallback (_mode, decoder->ARDrone3AntiflickeringStateModeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCb (_mode, ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_MODECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERINGSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_NUMBEROFSATELLITECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSStateNumberOfSatelliteChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCb))
                    {
                        uint8_t _numberOfSatellite;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _numberOfSatellite = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSStateNumberOfSatelliteChangedCallback) {
                                decoder->ARDrone3GPSStateNumberOfSatelliteChangedCallback (_numberOfSatellite, decoder->ARDrone3GPSStateNumberOfSatelliteChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCb (_numberOfSatellite, ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_NUMBEROFSATELLITECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPEAVAILABILITYCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSStateHomeTypeAvailabilityChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE _type;
                        uint8_t _available;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _available = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSStateHomeTypeAvailabilityChangedCallback) {
                                decoder->ARDrone3GPSStateHomeTypeAvailabilityChangedCallback (_type, _available, decoder->ARDrone3GPSStateHomeTypeAvailabilityChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCb (_type, _available, ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPEAVAILABILITYCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPECHOSENCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSStateHomeTypeChosenChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSStateHomeTypeChosenChangedCallback) {
                                decoder->ARDrone3GPSStateHomeTypeChosenChangedCallback (_type, decoder->ARDrone3GPSStateHomeTypeChosenChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCb (_type, ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPECHOSENCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PROSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PROSTATE_CMD_FEATURES:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PROStateFeaturesCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCb))
                    {
                        uint64_t _features;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _features = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PROStateFeaturesCallback) {
                                decoder->ARDrone3PROStateFeaturesCallback (_features, decoder->ARDrone3PROStateFeaturesCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCb (_features, ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PROSTATE_CMD_FEATURES */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PROSTATE */
            default:
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_ARDRONE3 */
        case ARCOMMANDS_ID_FEATURE_COMMON:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_COMMON_CLASS_NETWORK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_NETWORK_CMD_DISCONNECT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonNetworkDisconnectCallback) || (!decoder && ARCOMMANDS_Decoder_CommonNetworkDisconnectCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonNetworkDisconnectCallback) {
                                decoder->CommonNetworkDisconnectCallback (decoder->CommonNetworkDisconnectCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonNetworkDisconnectCb (ARCOMMANDS_Decoder_CommonNetworkDisconnectCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_NETWORK_CMD_DISCONNECT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_NETWORK */
            case ARCOMMANDS_ID_COMMON_CLASS_NETWORKEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_NETWORKEVENT_CMD_DISCONNECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonNetworkEventDisconnectionCallback) || (!decoder && ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCb))
                    {
                        eARCOMMANDS_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE _cause;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _cause = (eARCOMMANDS_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonNetworkEventDisconnectionCallback) {
                                decoder->CommonNetworkEventDisconnectionCallback (_cause, decoder->CommonNetworkEventDisconnectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCb (_cause, ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_NETWORKEVENT_CMD_DISCONNECTION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_NETWORKEVENT */
            case ARCOMMANDS_ID_COMMON_CLASS_SETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_ALLSETTINGS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsAllSettingsCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsAllSettingsCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsAllSettingsCallback) {
                                decoder->CommonSettingsAllSettingsCallback (decoder->CommonSettingsAllSettingsCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsAllSettingsCb (ARCOMMANDS_Decoder_CommonSettingsAllSettingsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_ALLSETTINGS */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_RESET:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsResetCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsResetCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsResetCallback) {
                                decoder->CommonSettingsResetCallback (decoder->CommonSettingsResetCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsResetCb (ARCOMMANDS_Decoder_CommonSettingsResetCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_RESET */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_PRODUCTNAME:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsProductNameCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsProductNameCb))
                    {
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsProductNameCallback) {
                                decoder->CommonSettingsProductNameCallback (_name, decoder->CommonSettingsProductNameCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsProductNameCb (_name, ARCOMMANDS_Decoder_CommonSettingsProductNameCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_PRODUCTNAME */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_COUNTRY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsCountryCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsCountryCb))
                    {
                        char * _code = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _code = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsCountryCallback) {
                                decoder->CommonSettingsCountryCallback (_code, decoder->CommonSettingsCountryCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsCountryCb (_code, ARCOMMANDS_Decoder_CommonSettingsCountryCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_COUNTRY */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_AUTOCOUNTRY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsAutoCountryCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsAutoCountryCb))
                    {
                        uint8_t _automatic;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _automatic = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsAutoCountryCallback) {
                                decoder->CommonSettingsAutoCountryCallback (_automatic, decoder->CommonSettingsAutoCountryCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsAutoCountryCb (_automatic, ARCOMMANDS_Decoder_CommonSettingsAutoCountryCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_AUTOCOUNTRY */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_SETTINGS */
            case ARCOMMANDS_ID_COMMON_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_ALLSETTINGSCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsStateAllSettingsChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsStateAllSettingsChangedCallback) {
                                decoder->CommonSettingsStateAllSettingsChangedCallback (decoder->CommonSettingsStateAllSettingsChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCb (ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_ALLSETTINGSCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_RESETCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsStateResetChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsStateResetChangedCallback) {
                                decoder->CommonSettingsStateResetChangedCallback (decoder->CommonSettingsStateResetChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCb (ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_RESETCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTNAMECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsStateProductNameChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCb))
                    {
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsStateProductNameChangedCallback) {
                                decoder->CommonSettingsStateProductNameChangedCallback (_name, decoder->CommonSettingsStateProductNameChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCb (_name, ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTNAMECHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTVERSIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsStateProductVersionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCb))
                    {
                        char * _software = NULL;
                        char * _hardware = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _software = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _hardware = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsStateProductVersionChangedCallback) {
                                decoder->CommonSettingsStateProductVersionChangedCallback (_software, _hardware, decoder->CommonSettingsStateProductVersionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCb (_software, _hardware, ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTVERSIONCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALHIGHCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsStateProductSerialHighChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCb))
                    {
                        char * _high = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _high = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsStateProductSerialHighChangedCallback) {
                                decoder->CommonSettingsStateProductSerialHighChangedCallback (_high, decoder->CommonSettingsStateProductSerialHighChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCb (_high, ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALHIGHCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALLOWCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsStateProductSerialLowChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCb))
                    {
                        char * _low = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _low = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsStateProductSerialLowChangedCallback) {
                                decoder->CommonSettingsStateProductSerialLowChangedCallback (_low, decoder->CommonSettingsStateProductSerialLowChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCb (_low, ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALLOWCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_COUNTRYCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsStateCountryChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCb))
                    {
                        char * _code = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _code = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsStateCountryChangedCallback) {
                                decoder->CommonSettingsStateCountryChangedCallback (_code, decoder->CommonSettingsStateCountryChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCb (_code, ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_COUNTRYCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_AUTOCOUNTRYCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsStateAutoCountryChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCb))
                    {
                        uint8_t _automatic;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _automatic = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsStateAutoCountryChangedCallback) {
                                decoder->CommonSettingsStateAutoCountryChangedCallback (_automatic, decoder->CommonSettingsStateAutoCountryChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCb (_automatic, ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_AUTOCOUNTRYCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_COMMON:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_ALLSTATES:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonAllStatesCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonAllStatesCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonAllStatesCallback) {
                                decoder->CommonCommonAllStatesCallback (decoder->CommonCommonAllStatesCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonAllStatesCb (ARCOMMANDS_Decoder_CommonCommonAllStatesCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_ALLSTATES */
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTDATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonCurrentDateCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonCurrentDateCb))
                    {
                        char * _date = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _date = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonCurrentDateCallback) {
                                decoder->CommonCommonCurrentDateCallback (_date, decoder->CommonCommonCurrentDateCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonCurrentDateCb (_date, ARCOMMANDS_Decoder_CommonCommonCurrentDateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTDATE */
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTTIME:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonCurrentTimeCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonCurrentTimeCb))
                    {
                        char * _time = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _time = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonCurrentTimeCallback) {
                                decoder->CommonCommonCurrentTimeCallback (_time, decoder->CommonCommonCurrentTimeCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonCurrentTimeCb (_time, ARCOMMANDS_Decoder_CommonCommonCurrentTimeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTTIME */
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_REBOOT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonRebootCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonRebootCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonRebootCallback) {
                                decoder->CommonCommonRebootCallback (decoder->CommonCommonRebootCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonRebootCb (ARCOMMANDS_Decoder_CommonCommonRebootCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_REBOOT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_COMMON */
            case ARCOMMANDS_ID_COMMON_CLASS_COMMONSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_ALLSTATESCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateAllStatesChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateAllStatesChangedCallback) {
                                decoder->CommonCommonStateAllStatesChangedCallback (decoder->CommonCommonStateAllStatesChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCb (ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_ALLSTATESCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_BATTERYSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateBatteryStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCb))
                    {
                        uint8_t _percent;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _percent = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateBatteryStateChangedCallback) {
                                decoder->CommonCommonStateBatteryStateChangedCallback (_percent, decoder->CommonCommonStateBatteryStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCb (_percent, ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_BATTERYSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGESTATELISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateMassStorageStateListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCb))
                    {
                        uint8_t _mass_storage_id;
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateMassStorageStateListChangedCallback) {
                                decoder->CommonCommonStateMassStorageStateListChangedCallback (_mass_storage_id, _name, decoder->CommonCommonStateMassStorageStateListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCb (_mass_storage_id, _name, ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGESTATELISTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOSTATELISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateMassStorageInfoStateListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCb))
                    {
                        uint8_t _mass_storage_id;
                        uint32_t _size;
                        uint32_t _used_size;
                        uint8_t _plugged;
                        uint8_t _full;
                        uint8_t _internal;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _size = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _used_size = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _plugged = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _full = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _internal = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateMassStorageInfoStateListChangedCallback) {
                                decoder->CommonCommonStateMassStorageInfoStateListChangedCallback (_mass_storage_id, _size, _used_size, _plugged, _full, _internal, decoder->CommonCommonStateMassStorageInfoStateListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCb (_mass_storage_id, _size, _used_size, _plugged, _full, _internal, ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOSTATELISTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTDATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateCurrentDateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCb))
                    {
                        char * _date = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _date = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateCurrentDateChangedCallback) {
                                decoder->CommonCommonStateCurrentDateChangedCallback (_date, decoder->CommonCommonStateCurrentDateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCb (_date, ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTDATECHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTTIMECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateCurrentTimeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCb))
                    {
                        char * _time = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _time = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateCurrentTimeChangedCallback) {
                                decoder->CommonCommonStateCurrentTimeChangedCallback (_time, decoder->CommonCommonStateCurrentTimeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCb (_time, ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTTIMECHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOREMAININGLISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateMassStorageInfoRemainingListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCb))
                    {
                        uint32_t _free_space;
                        uint16_t _rec_time;
                        uint32_t _photo_remaining;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _free_space = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rec_time = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _photo_remaining = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateMassStorageInfoRemainingListChangedCallback) {
                                decoder->CommonCommonStateMassStorageInfoRemainingListChangedCallback (_free_space, _rec_time, _photo_remaining, decoder->CommonCommonStateMassStorageInfoRemainingListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCb (_free_space, _rec_time, _photo_remaining, ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOREMAININGLISTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_WIFISIGNALCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateWifiSignalChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCb))
                    {
                        int16_t _rssi;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rssi =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateWifiSignalChangedCallback) {
                                decoder->CommonCommonStateWifiSignalChangedCallback (_rssi, decoder->CommonCommonStateWifiSignalChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCb (_rssi, ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_WIFISIGNALCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_SENSORSSTATESLISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateSensorsStatesListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCb))
                    {
                        eARCOMMANDS_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME _sensorName;
                        uint8_t _sensorState;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _sensorName = (eARCOMMANDS_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _sensorState = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateSensorsStatesListChangedCallback) {
                                decoder->CommonCommonStateSensorsStatesListChangedCallback (_sensorName, _sensorState, decoder->CommonCommonStateSensorsStatesListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCb (_sensorName, _sensorState, ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_SENSORSSTATESLISTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_PRODUCTMODEL:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateProductModelCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateProductModelCb))
                    {
                        eARCOMMANDS_COMMON_COMMONSTATE_PRODUCTMODEL_MODEL _model;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _model = (eARCOMMANDS_COMMON_COMMONSTATE_PRODUCTMODEL_MODEL)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateProductModelCallback) {
                                decoder->CommonCommonStateProductModelCallback (_model, decoder->CommonCommonStateProductModelCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateProductModelCb (_model, ARCOMMANDS_Decoder_CommonCommonStateProductModelCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_PRODUCTMODEL */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_COUNTRYLISTKNOWN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateCountryListKnownCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateCountryListKnownCb))
                    {
                        uint8_t _listFlags;
                        char * _countryCodes = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _listFlags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _countryCodes = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateCountryListKnownCallback) {
                                decoder->CommonCommonStateCountryListKnownCallback (_listFlags, _countryCodes, decoder->CommonCommonStateCountryListKnownCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateCountryListKnownCb (_listFlags, _countryCodes, ARCOMMANDS_Decoder_CommonCommonStateCountryListKnownCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_COUNTRYLISTKNOWN */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_DEPRECATEDMASSSTORAGECONTENTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateDeprecatedMassStorageContentChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateDeprecatedMassStorageContentChangedCb))
                    {
                        uint8_t _mass_storage_id;
                        uint16_t _nbPhotos;
                        uint16_t _nbVideos;
                        uint16_t _nbPuds;
                        uint16_t _nbCrashLogs;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbPhotos = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbVideos = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbPuds = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbCrashLogs = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateDeprecatedMassStorageContentChangedCallback) {
                                decoder->CommonCommonStateDeprecatedMassStorageContentChangedCallback (_mass_storage_id, _nbPhotos, _nbVideos, _nbPuds, _nbCrashLogs, decoder->CommonCommonStateDeprecatedMassStorageContentChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateDeprecatedMassStorageContentChangedCb (_mass_storage_id, _nbPhotos, _nbVideos, _nbPuds, _nbCrashLogs, ARCOMMANDS_Decoder_CommonCommonStateDeprecatedMassStorageContentChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_DEPRECATEDMASSSTORAGECONTENTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGECONTENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateMassStorageContentCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentCb))
                    {
                        uint8_t _mass_storage_id;
                        uint16_t _nbPhotos;
                        uint16_t _nbVideos;
                        uint16_t _nbPuds;
                        uint16_t _nbCrashLogs;
                        uint16_t _nbRawPhotos;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbPhotos = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbVideos = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbPuds = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbCrashLogs = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbRawPhotos = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateMassStorageContentCallback) {
                                decoder->CommonCommonStateMassStorageContentCallback (_mass_storage_id, _nbPhotos, _nbVideos, _nbPuds, _nbCrashLogs, _nbRawPhotos, decoder->CommonCommonStateMassStorageContentCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentCb (_mass_storage_id, _nbPhotos, _nbVideos, _nbPuds, _nbCrashLogs, _nbRawPhotos, ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGECONTENT */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGECONTENTFORCURRENTRUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateMassStorageContentForCurrentRunCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentForCurrentRunCb))
                    {
                        uint8_t _mass_storage_id;
                        uint16_t _nbPhotos;
                        uint16_t _nbVideos;
                        uint16_t _nbRawPhotos;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbPhotos = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbVideos = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbRawPhotos = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateMassStorageContentForCurrentRunCallback) {
                                decoder->CommonCommonStateMassStorageContentForCurrentRunCallback (_mass_storage_id, _nbPhotos, _nbVideos, _nbRawPhotos, decoder->CommonCommonStateMassStorageContentForCurrentRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentForCurrentRunCb (_mass_storage_id, _nbPhotos, _nbVideos, _nbRawPhotos, ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentForCurrentRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGECONTENTFORCURRENTRUN */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_COMMONSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_OVERHEAT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_SWITCHOFF:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonOverHeatSwitchOffCallback) || (!decoder && ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonOverHeatSwitchOffCallback) {
                                decoder->CommonOverHeatSwitchOffCallback (decoder->CommonOverHeatSwitchOffCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCb (ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_SWITCHOFF */
                case ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_VENTILATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonOverHeatVentilateCallback) || (!decoder && ARCOMMANDS_Decoder_CommonOverHeatVentilateCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonOverHeatVentilateCallback) {
                                decoder->CommonOverHeatVentilateCallback (decoder->CommonOverHeatVentilateCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonOverHeatVentilateCb (ARCOMMANDS_Decoder_CommonOverHeatVentilateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_VENTILATE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_OVERHEAT */
            case ARCOMMANDS_ID_COMMON_CLASS_OVERHEATSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonOverHeatStateOverHeatChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonOverHeatStateOverHeatChangedCallback) {
                                decoder->CommonOverHeatStateOverHeatChangedCallback (decoder->CommonOverHeatStateOverHeatChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCb (ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATCHANGED */
                case ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATREGULATIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonOverHeatStateOverHeatRegulationChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCb))
                    {
                        uint8_t _regulationType;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _regulationType = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonOverHeatStateOverHeatRegulationChangedCallback) {
                                decoder->CommonOverHeatStateOverHeatRegulationChangedCallback (_regulationType, decoder->CommonOverHeatStateOverHeatRegulationChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCb (_regulationType, ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATREGULATIONCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_OVERHEATSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_CONTROLLER:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CONTROLLER_CMD_ISPILOTING:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonControllerIsPilotingCallback) || (!decoder && ARCOMMANDS_Decoder_CommonControllerIsPilotingCb))
                    {
                        uint8_t _piloting;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _piloting = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonControllerIsPilotingCallback) {
                                decoder->CommonControllerIsPilotingCallback (_piloting, decoder->CommonControllerIsPilotingCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonControllerIsPilotingCb (_piloting, ARCOMMANDS_Decoder_CommonControllerIsPilotingCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CONTROLLER_CMD_ISPILOTING */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CONTROLLER */
            case ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_WIFISETTINGS_CMD_OUTDOORSETTING:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonWifiSettingsOutdoorSettingCallback) || (!decoder && ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCb))
                    {
                        uint8_t _outdoor;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _outdoor = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonWifiSettingsOutdoorSettingCallback) {
                                decoder->CommonWifiSettingsOutdoorSettingCallback (_outdoor, decoder->CommonWifiSettingsOutdoorSettingCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCb (_outdoor, ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_WIFISETTINGS_CMD_OUTDOORSETTING */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGS */
            case ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_WIFISETTINGSSTATE_CMD_OUTDOORSETTINGSCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonWifiSettingsStateOutdoorSettingsChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCb))
                    {
                        uint8_t _outdoor;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _outdoor = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonWifiSettingsStateOutdoorSettingsChangedCallback) {
                                decoder->CommonWifiSettingsStateOutdoorSettingsChangedCallback (_outdoor, decoder->CommonWifiSettingsStateOutdoorSettingsChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCb (_outdoor, ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_WIFISETTINGSSTATE_CMD_OUTDOORSETTINGSCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_MAVLINK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_MAVLINK_CMD_START:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonMavlinkStartCallback) || (!decoder && ARCOMMANDS_Decoder_CommonMavlinkStartCb))
                    {
                        char * _filepath = NULL;
                        eARCOMMANDS_COMMON_MAVLINK_START_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _filepath = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_COMMON_MAVLINK_START_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonMavlinkStartCallback) {
                                decoder->CommonMavlinkStartCallback (_filepath, _type, decoder->CommonMavlinkStartCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonMavlinkStartCb (_filepath, _type, ARCOMMANDS_Decoder_CommonMavlinkStartCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINK_CMD_START */
                case ARCOMMANDS_ID_COMMON_MAVLINK_CMD_PAUSE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonMavlinkPauseCallback) || (!decoder && ARCOMMANDS_Decoder_CommonMavlinkPauseCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonMavlinkPauseCallback) {
                                decoder->CommonMavlinkPauseCallback (decoder->CommonMavlinkPauseCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonMavlinkPauseCb (ARCOMMANDS_Decoder_CommonMavlinkPauseCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINK_CMD_PAUSE */
                case ARCOMMANDS_ID_COMMON_MAVLINK_CMD_STOP:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonMavlinkStopCallback) || (!decoder && ARCOMMANDS_Decoder_CommonMavlinkStopCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonMavlinkStopCallback) {
                                decoder->CommonMavlinkStopCallback (decoder->CommonMavlinkStopCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonMavlinkStopCb (ARCOMMANDS_Decoder_CommonMavlinkStopCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINK_CMD_STOP */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_MAVLINK */
            case ARCOMMANDS_ID_COMMON_CLASS_MAVLINKSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKFILEPLAYINGSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonMavlinkStateMavlinkFilePlayingStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCb))
                    {
                        eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE _state;
                        char * _filepath = NULL;
                        eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _filepath = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonMavlinkStateMavlinkFilePlayingStateChangedCallback) {
                                decoder->CommonMavlinkStateMavlinkFilePlayingStateChangedCallback (_state, _filepath, _type, decoder->CommonMavlinkStateMavlinkFilePlayingStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCb (_state, _filepath, _type, ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKFILEPLAYINGSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKPLAYERRORSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonMavlinkStateMavlinkPlayErrorStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCb))
                    {
                        eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonMavlinkStateMavlinkPlayErrorStateChangedCallback) {
                                decoder->CommonMavlinkStateMavlinkPlayErrorStateChangedCallback (_error, decoder->CommonMavlinkStateMavlinkPlayErrorStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCb (_error, ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKPLAYERRORSTATECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_MAVLINKSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_CALIBRATION:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CALIBRATION_CMD_MAGNETOCALIBRATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCalibrationMagnetoCalibrationCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCb))
                    {
                        uint8_t _calibrate;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _calibrate = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCalibrationMagnetoCalibrationCallback) {
                                decoder->CommonCalibrationMagnetoCalibrationCallback (_calibrate, decoder->CommonCalibrationMagnetoCalibrationCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCb (_calibrate, ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATION_CMD_MAGNETOCALIBRATION */
                case ARCOMMANDS_ID_COMMON_CALIBRATION_CMD_PITOTCALIBRATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCalibrationPitotCalibrationCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCalibrationPitotCalibrationCb))
                    {
                        uint8_t _calibrate;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _calibrate = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCalibrationPitotCalibrationCallback) {
                                decoder->CommonCalibrationPitotCalibrationCallback (_calibrate, decoder->CommonCalibrationPitotCalibrationCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCalibrationPitotCalibrationCb (_calibrate, ARCOMMANDS_Decoder_CommonCalibrationPitotCalibrationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATION_CMD_PITOTCALIBRATION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CALIBRATION */
            case ARCOMMANDS_ID_COMMON_CLASS_CALIBRATIONSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCalibrationStateMagnetoCalibrationStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCb))
                    {
                        uint8_t _xAxisCalibration;
                        uint8_t _yAxisCalibration;
                        uint8_t _zAxisCalibration;
                        uint8_t _calibrationFailed;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _xAxisCalibration = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _yAxisCalibration = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _zAxisCalibration = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _calibrationFailed = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCalibrationStateMagnetoCalibrationStateChangedCallback) {
                                decoder->CommonCalibrationStateMagnetoCalibrationStateChangedCallback (_xAxisCalibration, _yAxisCalibration, _zAxisCalibration, _calibrationFailed, decoder->CommonCalibrationStateMagnetoCalibrationStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCb (_xAxisCalibration, _yAxisCalibration, _zAxisCalibration, _calibrationFailed, ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONREQUIREDSTATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCalibrationStateMagnetoCalibrationRequiredStateCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCb))
                    {
                        uint8_t _required;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _required = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCalibrationStateMagnetoCalibrationRequiredStateCallback) {
                                decoder->CommonCalibrationStateMagnetoCalibrationRequiredStateCallback (_required, decoder->CommonCalibrationStateMagnetoCalibrationRequiredStateCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCb (_required, ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONREQUIREDSTATE */
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCb))
                    {
                        eARCOMMANDS_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS _axis;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis = (eARCOMMANDS_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback) {
                                decoder->CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback (_axis, decoder->CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCb (_axis, ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED */
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTARTEDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCalibrationStateMagnetoCalibrationStartedChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCb))
                    {
                        uint8_t _started;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _started = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCalibrationStateMagnetoCalibrationStartedChangedCallback) {
                                decoder->CommonCalibrationStateMagnetoCalibrationStartedChangedCallback (_started, decoder->CommonCalibrationStateMagnetoCalibrationStartedChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCb (_started, ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTARTEDCHANGED */
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_PITOTCALIBRATIONSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCalibrationStatePitotCalibrationStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCalibrationStatePitotCalibrationStateChangedCb))
                    {
                        eARCOMMANDS_COMMON_CALIBRATIONSTATE_PITOTCALIBRATIONSTATECHANGED_STATE _state;
                        uint8_t _lastError;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_COMMON_CALIBRATIONSTATE_PITOTCALIBRATIONSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _lastError = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCalibrationStatePitotCalibrationStateChangedCallback) {
                                decoder->CommonCalibrationStatePitotCalibrationStateChangedCallback (_state, _lastError, decoder->CommonCalibrationStatePitotCalibrationStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCalibrationStatePitotCalibrationStateChangedCb (_state, _lastError, ARCOMMANDS_Decoder_CommonCalibrationStatePitotCalibrationStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_PITOTCALIBRATIONSTATECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CALIBRATIONSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_CAMERASETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CAMERASETTINGSSTATE_CMD_CAMERASETTINGSCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCameraSettingsStateCameraSettingsChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCb))
                    {
                        float _fov;
                        float _panMax;
                        float _panMin;
                        float _tiltMax;
                        float _tiltMin;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _fov = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _panMax = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _panMin = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _tiltMax = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _tiltMin = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCameraSettingsStateCameraSettingsChangedCallback) {
                                decoder->CommonCameraSettingsStateCameraSettingsChangedCallback (_fov, _panMax, _panMin, _tiltMax, _tiltMin, decoder->CommonCameraSettingsStateCameraSettingsChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCb (_fov, _panMax, _panMin, _tiltMax, _tiltMin, ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CAMERASETTINGSSTATE_CMD_CAMERASETTINGSCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CAMERASETTINGSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_GPS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_GPS_CMD_CONTROLLERPOSITIONFORRUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonGPSControllerPositionForRunCallback) || (!decoder && ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCb))
                    {
                        double _latitude;
                        double _longitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonGPSControllerPositionForRunCallback) {
                                decoder->CommonGPSControllerPositionForRunCallback (_latitude, _longitude, decoder->CommonGPSControllerPositionForRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCb (_latitude, _longitude, ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_GPS_CMD_CONTROLLERPOSITIONFORRUN */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_GPS */
            case ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_AVAILABILITYSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonFlightPlanStateAvailabilityStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCb))
                    {
                        uint8_t _AvailabilityState;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _AvailabilityState = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonFlightPlanStateAvailabilityStateChangedCallback) {
                                decoder->CommonFlightPlanStateAvailabilityStateChangedCallback (_AvailabilityState, decoder->CommonFlightPlanStateAvailabilityStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCb (_AvailabilityState, ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_AVAILABILITYSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_COMPONENTSTATELISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonFlightPlanStateComponentStateListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCb))
                    {
                        eARCOMMANDS_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT _component;
                        uint8_t _State;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _component = (eARCOMMANDS_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _State = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonFlightPlanStateComponentStateListChangedCallback) {
                                decoder->CommonFlightPlanStateComponentStateListChangedCallback (_component, _State, decoder->CommonFlightPlanStateComponentStateListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCb (_component, _State, ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_COMPONENTSTATELISTCHANGED */
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_LOCKSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonFlightPlanStateLockStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonFlightPlanStateLockStateChangedCb))
                    {
                        uint8_t _LockState;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _LockState = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonFlightPlanStateLockStateChangedCallback) {
                                decoder->CommonFlightPlanStateLockStateChangedCallback (_LockState, decoder->CommonFlightPlanStateLockStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonFlightPlanStateLockStateChangedCb (_LockState, ARCOMMANDS_Decoder_CommonFlightPlanStateLockStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_LOCKSTATECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_STARTINGERROREVENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonFlightPlanEventStartingErrorEventCallback) || (!decoder && ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonFlightPlanEventStartingErrorEventCallback) {
                                decoder->CommonFlightPlanEventStartingErrorEventCallback (decoder->CommonFlightPlanEventStartingErrorEventCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCb (ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_STARTINGERROREVENT */
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_SPEEDBRIDLEEVENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonFlightPlanEventSpeedBridleEventCallback) || (!decoder && ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonFlightPlanEventSpeedBridleEventCallback) {
                                decoder->CommonFlightPlanEventSpeedBridleEventCallback (decoder->CommonFlightPlanEventSpeedBridleEventCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCb (ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_SPEEDBRIDLEEVENT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANEVENT */
            case ARCOMMANDS_ID_COMMON_CLASS_ARLIBSVERSIONSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_CONTROLLERLIBARCOMMANDSVERSION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonARLibsVersionsStateControllerLibARCommandsVersionCallback) || (!decoder && ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCb))
                    {
                        char * _version = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _version = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonARLibsVersionsStateControllerLibARCommandsVersionCallback) {
                                decoder->CommonARLibsVersionsStateControllerLibARCommandsVersionCallback (_version, decoder->CommonARLibsVersionsStateControllerLibARCommandsVersionCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCb (_version, ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_CONTROLLERLIBARCOMMANDSVERSION */
                case ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_SKYCONTROLLERLIBARCOMMANDSVERSION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback) || (!decoder && ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCb))
                    {
                        char * _version = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _version = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback) {
                                decoder->CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback (_version, decoder->CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCb (_version, ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_SKYCONTROLLERLIBARCOMMANDSVERSION */
                case ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_DEVICELIBARCOMMANDSVERSION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonARLibsVersionsStateDeviceLibARCommandsVersionCallback) || (!decoder && ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCb))
                    {
                        char * _version = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _version = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonARLibsVersionsStateDeviceLibARCommandsVersionCallback) {
                                decoder->CommonARLibsVersionsStateDeviceLibARCommandsVersionCallback (_version, decoder->CommonARLibsVersionsStateDeviceLibARCommandsVersionCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCb (_version, ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_DEVICELIBARCOMMANDSVERSION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_ARLIBSVERSIONSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_AUDIO:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_AUDIO_CMD_CONTROLLERREADYFORSTREAMING:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonAudioControllerReadyForStreamingCallback) || (!decoder && ARCOMMANDS_Decoder_CommonAudioControllerReadyForStreamingCb))
                    {
                        uint8_t _ready;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ready = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonAudioControllerReadyForStreamingCallback) {
                                decoder->CommonAudioControllerReadyForStreamingCallback (_ready, decoder->CommonAudioControllerReadyForStreamingCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonAudioControllerReadyForStreamingCb (_ready, ARCOMMANDS_Decoder_CommonAudioControllerReadyForStreamingCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_AUDIO_CMD_CONTROLLERREADYFORSTREAMING */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_AUDIO */
            case ARCOMMANDS_ID_COMMON_CLASS_AUDIOSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_AUDIOSTATE_CMD_AUDIOSTREAMINGRUNNING:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonAudioStateAudioStreamingRunningCallback) || (!decoder && ARCOMMANDS_Decoder_CommonAudioStateAudioStreamingRunningCb))
                    {
                        uint8_t _running;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _running = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonAudioStateAudioStreamingRunningCallback) {
                                decoder->CommonAudioStateAudioStreamingRunningCallback (_running, decoder->CommonAudioStateAudioStreamingRunningCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonAudioStateAudioStreamingRunningCb (_running, ARCOMMANDS_Decoder_CommonAudioStateAudioStreamingRunningCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_AUDIOSTATE_CMD_AUDIOSTREAMINGRUNNING */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_AUDIOSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_HEADLIGHTS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_HEADLIGHTS_CMD_INTENSITY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonHeadlightsIntensityCallback) || (!decoder && ARCOMMANDS_Decoder_CommonHeadlightsIntensityCb))
                    {
                        uint8_t _left;
                        uint8_t _right;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _left = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _right = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonHeadlightsIntensityCallback) {
                                decoder->CommonHeadlightsIntensityCallback (_left, _right, decoder->CommonHeadlightsIntensityCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonHeadlightsIntensityCb (_left, _right, ARCOMMANDS_Decoder_CommonHeadlightsIntensityCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_HEADLIGHTS_CMD_INTENSITY */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_HEADLIGHTS */
            case ARCOMMANDS_ID_COMMON_CLASS_HEADLIGHTSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_HEADLIGHTSSTATE_CMD_INTENSITYCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonHeadlightsStateIntensityChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonHeadlightsStateIntensityChangedCb))
                    {
                        uint8_t _left;
                        uint8_t _right;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _left = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _right = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonHeadlightsStateIntensityChangedCallback) {
                                decoder->CommonHeadlightsStateIntensityChangedCallback (_left, _right, decoder->CommonHeadlightsStateIntensityChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonHeadlightsStateIntensityChangedCb (_left, _right, ARCOMMANDS_Decoder_CommonHeadlightsStateIntensityChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_HEADLIGHTSSTATE_CMD_INTENSITYCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_HEADLIGHTSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_ANIMATIONS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STARTANIMATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonAnimationsStartAnimationCallback) || (!decoder && ARCOMMANDS_Decoder_CommonAnimationsStartAnimationCb))
                    {
                        eARCOMMANDS_COMMON_ANIMATIONS_STARTANIMATION_ANIM _anim;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _anim = (eARCOMMANDS_COMMON_ANIMATIONS_STARTANIMATION_ANIM)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonAnimationsStartAnimationCallback) {
                                decoder->CommonAnimationsStartAnimationCallback (_anim, decoder->CommonAnimationsStartAnimationCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonAnimationsStartAnimationCb (_anim, ARCOMMANDS_Decoder_CommonAnimationsStartAnimationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STARTANIMATION */
                case ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STOPANIMATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonAnimationsStopAnimationCallback) || (!decoder && ARCOMMANDS_Decoder_CommonAnimationsStopAnimationCb))
                    {
                        eARCOMMANDS_COMMON_ANIMATIONS_STOPANIMATION_ANIM _anim;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _anim = (eARCOMMANDS_COMMON_ANIMATIONS_STOPANIMATION_ANIM)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonAnimationsStopAnimationCallback) {
                                decoder->CommonAnimationsStopAnimationCallback (_anim, decoder->CommonAnimationsStopAnimationCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonAnimationsStopAnimationCb (_anim, ARCOMMANDS_Decoder_CommonAnimationsStopAnimationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STOPANIMATION */
                case ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STOPALLANIMATIONS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonAnimationsStopAllAnimationsCallback) || (!decoder && ARCOMMANDS_Decoder_CommonAnimationsStopAllAnimationsCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonAnimationsStopAllAnimationsCallback) {
                                decoder->CommonAnimationsStopAllAnimationsCallback (decoder->CommonAnimationsStopAllAnimationsCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonAnimationsStopAllAnimationsCb (ARCOMMANDS_Decoder_CommonAnimationsStopAllAnimationsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STOPALLANIMATIONS */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_ANIMATIONS */
            case ARCOMMANDS_ID_COMMON_CLASS_ANIMATIONSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_ANIMATIONSSTATE_CMD_LIST:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonAnimationsStateListCallback) || (!decoder && ARCOMMANDS_Decoder_CommonAnimationsStateListCb))
                    {
                        eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ANIM _anim;
                        eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_STATE _state;
                        eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _anim = (eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ANIM)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonAnimationsStateListCallback) {
                                decoder->CommonAnimationsStateListCallback (_anim, _state, _error, decoder->CommonAnimationsStateListCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonAnimationsStateListCb (_anim, _state, _error, ARCOMMANDS_Decoder_CommonAnimationsStateListCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_ANIMATIONSSTATE_CMD_LIST */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_ANIMATIONSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_ACCESSORY:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_ACCESSORY_CMD_CONFIG:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonAccessoryConfigCallback) || (!decoder && ARCOMMANDS_Decoder_CommonAccessoryConfigCb))
                    {
                        eARCOMMANDS_COMMON_ACCESSORY_CONFIG_ACCESSORY _accessory;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _accessory = (eARCOMMANDS_COMMON_ACCESSORY_CONFIG_ACCESSORY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonAccessoryConfigCallback) {
                                decoder->CommonAccessoryConfigCallback (_accessory, decoder->CommonAccessoryConfigCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonAccessoryConfigCb (_accessory, ARCOMMANDS_Decoder_CommonAccessoryConfigCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_ACCESSORY_CMD_CONFIG */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_ACCESSORY */
            case ARCOMMANDS_ID_COMMON_CLASS_ACCESSORYSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_SUPPORTEDACCESSORIESLISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonAccessoryStateSupportedAccessoriesListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonAccessoryStateSupportedAccessoriesListChangedCb))
                    {
                        eARCOMMANDS_COMMON_ACCESSORYSTATE_SUPPORTEDACCESSORIESLISTCHANGED_ACCESSORY _accessory;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _accessory = (eARCOMMANDS_COMMON_ACCESSORYSTATE_SUPPORTEDACCESSORIESLISTCHANGED_ACCESSORY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonAccessoryStateSupportedAccessoriesListChangedCallback) {
                                decoder->CommonAccessoryStateSupportedAccessoriesListChangedCallback (_accessory, decoder->CommonAccessoryStateSupportedAccessoriesListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonAccessoryStateSupportedAccessoriesListChangedCb (_accessory, ARCOMMANDS_Decoder_CommonAccessoryStateSupportedAccessoriesListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_SUPPORTEDACCESSORIESLISTCHANGED */
                case ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_ACCESSORYCONFIGCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonAccessoryStateAccessoryConfigChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigChangedCb))
                    {
                        eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_NEWACCESSORY _newAccessory;
                        eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _newAccessory = (eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_NEWACCESSORY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonAccessoryStateAccessoryConfigChangedCallback) {
                                decoder->CommonAccessoryStateAccessoryConfigChangedCallback (_newAccessory, _error, decoder->CommonAccessoryStateAccessoryConfigChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigChangedCb (_newAccessory, _error, ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_ACCESSORYCONFIGCHANGED */
                case ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_ACCESSORYCONFIGMODIFICATIONENABLED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonAccessoryStateAccessoryConfigModificationEnabledCallback) || (!decoder && ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigModificationEnabledCb))
                    {
                        uint8_t _enabled;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonAccessoryStateAccessoryConfigModificationEnabledCallback) {
                                decoder->CommonAccessoryStateAccessoryConfigModificationEnabledCallback (_enabled, decoder->CommonAccessoryStateAccessoryConfigModificationEnabledCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigModificationEnabledCb (_enabled, ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigModificationEnabledCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_ACCESSORYCONFIGMODIFICATIONENABLED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_ACCESSORYSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_CHARGER:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CHARGER_CMD_SETMAXCHARGERATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonChargerSetMaxChargeRateCallback) || (!decoder && ARCOMMANDS_Decoder_CommonChargerSetMaxChargeRateCb))
                    {
                        eARCOMMANDS_COMMON_CHARGER_SETMAXCHARGERATE_RATE _rate;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rate = (eARCOMMANDS_COMMON_CHARGER_SETMAXCHARGERATE_RATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonChargerSetMaxChargeRateCallback) {
                                decoder->CommonChargerSetMaxChargeRateCallback (_rate, decoder->CommonChargerSetMaxChargeRateCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonChargerSetMaxChargeRateCb (_rate, ARCOMMANDS_Decoder_CommonChargerSetMaxChargeRateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CHARGER_CMD_SETMAXCHARGERATE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CHARGER */
            case ARCOMMANDS_ID_COMMON_CLASS_CHARGERSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_MAXCHARGERATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonChargerStateMaxChargeRateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonChargerStateMaxChargeRateChangedCb))
                    {
                        eARCOMMANDS_COMMON_CHARGERSTATE_MAXCHARGERATECHANGED_RATE _rate;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rate = (eARCOMMANDS_COMMON_CHARGERSTATE_MAXCHARGERATECHANGED_RATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonChargerStateMaxChargeRateChangedCallback) {
                                decoder->CommonChargerStateMaxChargeRateChangedCallback (_rate, decoder->CommonChargerStateMaxChargeRateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonChargerStateMaxChargeRateChangedCb (_rate, ARCOMMANDS_Decoder_CommonChargerStateMaxChargeRateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_MAXCHARGERATECHANGED */
                case ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_CURRENTCHARGESTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonChargerStateCurrentChargeStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonChargerStateCurrentChargeStateChangedCb))
                    {
                        eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_STATUS _status;
                        eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_PHASE _phase;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _status = (eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_STATUS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _phase = (eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_PHASE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonChargerStateCurrentChargeStateChangedCallback) {
                                decoder->CommonChargerStateCurrentChargeStateChangedCallback (_status, _phase, decoder->CommonChargerStateCurrentChargeStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonChargerStateCurrentChargeStateChangedCb (_status, _phase, ARCOMMANDS_Decoder_CommonChargerStateCurrentChargeStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_CURRENTCHARGESTATECHANGED */
                case ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_LASTCHARGERATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonChargerStateLastChargeRateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonChargerStateLastChargeRateChangedCb))
                    {
                        eARCOMMANDS_COMMON_CHARGERSTATE_LASTCHARGERATECHANGED_RATE _rate;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rate = (eARCOMMANDS_COMMON_CHARGERSTATE_LASTCHARGERATECHANGED_RATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonChargerStateLastChargeRateChangedCallback) {
                                decoder->CommonChargerStateLastChargeRateChangedCallback (_rate, decoder->CommonChargerStateLastChargeRateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonChargerStateLastChargeRateChangedCb (_rate, ARCOMMANDS_Decoder_CommonChargerStateLastChargeRateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_LASTCHARGERATECHANGED */
                case ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_CHARGINGINFO:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonChargerStateChargingInfoCallback) || (!decoder && ARCOMMANDS_Decoder_CommonChargerStateChargingInfoCb))
                    {
                        eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_PHASE _phase;
                        eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_RATE _rate;
                        uint8_t _intensity;
                        uint8_t _fullChargingTime;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _phase = (eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_PHASE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rate = (eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_RATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _intensity = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _fullChargingTime = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonChargerStateChargingInfoCallback) {
                                decoder->CommonChargerStateChargingInfoCallback (_phase, _rate, _intensity, _fullChargingTime, decoder->CommonChargerStateChargingInfoCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonChargerStateChargingInfoCb (_phase, _rate, _intensity, _fullChargingTime, ARCOMMANDS_Decoder_CommonChargerStateChargingInfoCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_CHARGINGINFO */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CHARGERSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_RUNSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_RUNSTATE_CMD_RUNIDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonRunStateRunIdChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonRunStateRunIdChangedCb))
                    {
                        char * _runId = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _runId = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonRunStateRunIdChangedCallback) {
                                decoder->CommonRunStateRunIdChangedCallback (_runId, decoder->CommonRunStateRunIdChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonRunStateRunIdChangedCb (_runId, ARCOMMANDS_Decoder_CommonRunStateRunIdChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_RUNSTATE_CMD_RUNIDCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_RUNSTATE */
            default:
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_COMMON */
        case ARCOMMANDS_ID_FEATURE_CONTROLLER_INFO:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_CONTROLLER_INFO_CMD_GPS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ControllerInfoGpsCallback) || (!decoder && ARCOMMANDS_Decoder_ControllerInfoGpsCb))
                    {
                        double _latitude;
                        double _longitude;
                        float _altitude;
                        float _horizontal_accuracy;
                        float _vertical_accuracy;
                        float _north_speed;
                        float _east_speed;
                        float _down_speed;
                        double _timestamp;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _horizontal_accuracy = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_accuracy = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _north_speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _east_speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _down_speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _timestamp = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ControllerInfoGpsCallback) {
                                decoder->ControllerInfoGpsCallback (_latitude, _longitude, _altitude, _horizontal_accuracy, _vertical_accuracy, _north_speed, _east_speed, _down_speed, _timestamp, decoder->ControllerInfoGpsCustom);
                            } else {
                                ARCOMMANDS_Decoder_ControllerInfoGpsCb (_latitude, _longitude, _altitude, _horizontal_accuracy, _vertical_accuracy, _north_speed, _east_speed, _down_speed, _timestamp, ARCOMMANDS_Decoder_ControllerInfoGpsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_CONTROLLER_INFO_RUNSTATE_CMD_GPS */
                case ARCOMMANDS_ID_CONTROLLER_INFO_CMD_BAROMETER:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ControllerInfoBarometerCallback) || (!decoder && ARCOMMANDS_Decoder_ControllerInfoBarometerCb))
                    {
                        float _pressure;
                        double _timestamp;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _pressure = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _timestamp = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ControllerInfoBarometerCallback) {
                                decoder->ControllerInfoBarometerCallback (_pressure, _timestamp, decoder->ControllerInfoBarometerCustom);
                            } else {
                                ARCOMMANDS_Decoder_ControllerInfoBarometerCb (_pressure, _timestamp, ARCOMMANDS_Decoder_ControllerInfoBarometerCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_CONTROLLER_INFO_RUNSTATE_CMD_BAROMETER */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_CONTROLLER_INFO */
        case ARCOMMANDS_ID_FEATURE_DEBUG:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_DEBUG_CMD_GET_ALL_SETTINGS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->DebugGetAllSettingsCallback) || (!decoder && ARCOMMANDS_Decoder_DebugGetAllSettingsCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->DebugGetAllSettingsCallback) {
                                decoder->DebugGetAllSettingsCallback (decoder->DebugGetAllSettingsCustom);
                            } else {
                                ARCOMMANDS_Decoder_DebugGetAllSettingsCb (ARCOMMANDS_Decoder_DebugGetAllSettingsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_DEBUG_RUNSTATE_CMD_GET_ALL_SETTINGS */
                case ARCOMMANDS_ID_DEBUG_CMD_SET_SETTING:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->DebugSetSettingCallback) || (!decoder && ARCOMMANDS_Decoder_DebugSetSettingCb))
                    {
                        uint16_t _id;
                        char * _value = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _id = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->DebugSetSettingCallback) {
                                decoder->DebugSetSettingCallback (_id, _value, decoder->DebugSetSettingCustom);
                            } else {
                                ARCOMMANDS_Decoder_DebugSetSettingCb (_id, _value, ARCOMMANDS_Decoder_DebugSetSettingCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_DEBUG_RUNSTATE_CMD_SET_SETTING */
                case ARCOMMANDS_ID_DEBUG_CMD_SETTINGS_INFO:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->DebugSettingsInfoCallback) || (!decoder && ARCOMMANDS_Decoder_DebugSettingsInfoCb))
                    {
                        uint8_t _listFlags;
                        uint16_t _id;
                        char * _label = NULL;
                        eARCOMMANDS_DEBUG_SETTING_TYPE _type;
                        eARCOMMANDS_DEBUG_SETTING_MODE _mode;
                        char * _range_min = NULL;
                        char * _range_max = NULL;
                        char * _range_step = NULL;
                        char * _value = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _listFlags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _id = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _label = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_DEBUG_SETTING_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_DEBUG_SETTING_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _range_min = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _range_max = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _range_step = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->DebugSettingsInfoCallback) {
                                decoder->DebugSettingsInfoCallback (_listFlags, _id, _label, _type, _mode, _range_min, _range_max, _range_step, _value, decoder->DebugSettingsInfoCustom);
                            } else {
                                ARCOMMANDS_Decoder_DebugSettingsInfoCb (_listFlags, _id, _label, _type, _mode, _range_min, _range_max, _range_step, _value, ARCOMMANDS_Decoder_DebugSettingsInfoCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_DEBUG_RUNSTATE_CMD_SETTINGS_INFO */
                case ARCOMMANDS_ID_DEBUG_CMD_SETTINGS_LIST:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->DebugSettingsListCallback) || (!decoder && ARCOMMANDS_Decoder_DebugSettingsListCb))
                    {
                        uint16_t _id;
                        char * _value = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _id = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->DebugSettingsListCallback) {
                                decoder->DebugSettingsListCallback (_id, _value, decoder->DebugSettingsListCustom);
                            } else {
                                ARCOMMANDS_Decoder_DebugSettingsListCb (_id, _value, ARCOMMANDS_Decoder_DebugSettingsListCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_DEBUG_RUNSTATE_CMD_SETTINGS_LIST */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_DEBUG */
        case ARCOMMANDS_ID_FEATURE_DRONE_MANAGER:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_DISCOVER_DRONES:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->DroneManagerDiscoverDronesCallback) || (!decoder && ARCOMMANDS_Decoder_DroneManagerDiscoverDronesCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->DroneManagerDiscoverDronesCallback) {
                                decoder->DroneManagerDiscoverDronesCallback (decoder->DroneManagerDiscoverDronesCustom);
                            } else {
                                ARCOMMANDS_Decoder_DroneManagerDiscoverDronesCb (ARCOMMANDS_Decoder_DroneManagerDiscoverDronesCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_RUNSTATE_CMD_DISCOVER_DRONES */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_CONNECT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->DroneManagerConnectCallback) || (!decoder && ARCOMMANDS_Decoder_DroneManagerConnectCb))
                    {
                        char * _serial = NULL;
                        char * _key = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _serial = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _key = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->DroneManagerConnectCallback) {
                                decoder->DroneManagerConnectCallback (_serial, _key, decoder->DroneManagerConnectCustom);
                            } else {
                                ARCOMMANDS_Decoder_DroneManagerConnectCb (_serial, _key, ARCOMMANDS_Decoder_DroneManagerConnectCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_RUNSTATE_CMD_CONNECT */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_FORGET:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->DroneManagerForgetCallback) || (!decoder && ARCOMMANDS_Decoder_DroneManagerForgetCb))
                    {
                        char * _serial = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _serial = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->DroneManagerForgetCallback) {
                                decoder->DroneManagerForgetCallback (_serial, decoder->DroneManagerForgetCustom);
                            } else {
                                ARCOMMANDS_Decoder_DroneManagerForgetCb (_serial, ARCOMMANDS_Decoder_DroneManagerForgetCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_RUNSTATE_CMD_FORGET */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_DRONE_LIST_ITEM:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->DroneManagerDroneListItemCallback) || (!decoder && ARCOMMANDS_Decoder_DroneManagerDroneListItemCb))
                    {
                        char * _serial = NULL;
                        uint16_t _model;
                        char * _name = NULL;
                        uint8_t _connection_order;
                        uint8_t _active;
                        uint8_t _visible;
                        eARCOMMANDS_DRONE_MANAGER_SECURITY _security;
                        uint8_t _has_saved_key;
                        int8_t _rssi;
                        uint8_t _list_flags;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _serial = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _model = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _connection_order = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _active = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _visible = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _security = (eARCOMMANDS_DRONE_MANAGER_SECURITY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _has_saved_key = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rssi =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _list_flags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->DroneManagerDroneListItemCallback) {
                                decoder->DroneManagerDroneListItemCallback (_serial, _model, _name, _connection_order, _active, _visible, _security, _has_saved_key, _rssi, _list_flags, decoder->DroneManagerDroneListItemCustom);
                            } else {
                                ARCOMMANDS_Decoder_DroneManagerDroneListItemCb (_serial, _model, _name, _connection_order, _active, _visible, _security, _has_saved_key, _rssi, _list_flags, ARCOMMANDS_Decoder_DroneManagerDroneListItemCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_RUNSTATE_CMD_DRONE_LIST_ITEM */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_CONNECTION_STATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->DroneManagerConnectionStateCallback) || (!decoder && ARCOMMANDS_Decoder_DroneManagerConnectionStateCb))
                    {
                        eARCOMMANDS_DRONE_MANAGER_CONNECTION_STATE _state;
                        char * _serial = NULL;
                        uint16_t _model;
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_DRONE_MANAGER_CONNECTION_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _serial = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _model = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->DroneManagerConnectionStateCallback) {
                                decoder->DroneManagerConnectionStateCallback (_state, _serial, _model, _name, decoder->DroneManagerConnectionStateCustom);
                            } else {
                                ARCOMMANDS_Decoder_DroneManagerConnectionStateCb (_state, _serial, _model, _name, ARCOMMANDS_Decoder_DroneManagerConnectionStateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_RUNSTATE_CMD_CONNECTION_STATE */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_AUTHENTICATION_FAILED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->DroneManagerAuthenticationFailedCallback) || (!decoder && ARCOMMANDS_Decoder_DroneManagerAuthenticationFailedCb))
                    {
                        char * _serial = NULL;
                        uint16_t _model;
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _serial = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _model = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->DroneManagerAuthenticationFailedCallback) {
                                decoder->DroneManagerAuthenticationFailedCallback (_serial, _model, _name, decoder->DroneManagerAuthenticationFailedCustom);
                            } else {
                                ARCOMMANDS_Decoder_DroneManagerAuthenticationFailedCb (_serial, _model, _name, ARCOMMANDS_Decoder_DroneManagerAuthenticationFailedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_RUNSTATE_CMD_AUTHENTICATION_FAILED */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_CONNECTION_REFUSED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->DroneManagerConnectionRefusedCallback) || (!decoder && ARCOMMANDS_Decoder_DroneManagerConnectionRefusedCb))
                    {
                        char * _serial = NULL;
                        uint16_t _model;
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _serial = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _model = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->DroneManagerConnectionRefusedCallback) {
                                decoder->DroneManagerConnectionRefusedCallback (_serial, _model, _name, decoder->DroneManagerConnectionRefusedCustom);
                            } else {
                                ARCOMMANDS_Decoder_DroneManagerConnectionRefusedCb (_serial, _model, _name, ARCOMMANDS_Decoder_DroneManagerConnectionRefusedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_RUNSTATE_CMD_CONNECTION_REFUSED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_DRONE_MANAGER */
        case ARCOMMANDS_ID_FEATURE_JUMPINGSUMO:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_PILOTING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_PCMD:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoPilotingPCMDCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoPilotingPCMDCb))
                    {
                        uint8_t _flag;
                        int8_t _speed;
                        int8_t _turn;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _flag = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _turn =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoPilotingPCMDCallback) {
                                decoder->JumpingSumoPilotingPCMDCallback (_flag, _speed, _turn, decoder->JumpingSumoPilotingPCMDCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoPilotingPCMDCb (_flag, _speed, _turn, ARCOMMANDS_Decoder_JumpingSumoPilotingPCMDCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_PCMD */
                case ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_POSTURE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoPilotingPostureCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoPilotingPostureCb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_PILOTING_POSTURE_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_JUMPINGSUMO_PILOTING_POSTURE_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoPilotingPostureCallback) {
                                decoder->JumpingSumoPilotingPostureCallback (_type, decoder->JumpingSumoPilotingPostureCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoPilotingPostureCb (_type, ARCOMMANDS_Decoder_JumpingSumoPilotingPostureCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_POSTURE */
                case ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_ADDCAPOFFSET:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoPilotingAddCapOffsetCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoPilotingAddCapOffsetCb))
                    {
                        float _offset;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _offset = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoPilotingAddCapOffsetCallback) {
                                decoder->JumpingSumoPilotingAddCapOffsetCallback (_offset, decoder->JumpingSumoPilotingAddCapOffsetCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoPilotingAddCapOffsetCb (_offset, ARCOMMANDS_Decoder_JumpingSumoPilotingAddCapOffsetCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_ADDCAPOFFSET */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_PILOTING */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_PILOTINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_PILOTINGSTATE_CMD_POSTURECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoPilotingStatePostureChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoPilotingStatePostureChangedCb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoPilotingStatePostureChangedCallback) {
                                decoder->JumpingSumoPilotingStatePostureChangedCallback (_state, decoder->JumpingSumoPilotingStatePostureChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoPilotingStatePostureChangedCb (_state, ARCOMMANDS_Decoder_JumpingSumoPilotingStatePostureChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_PILOTINGSTATE_CMD_POSTURECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_PILOTINGSTATE_CMD_ALERTSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoPilotingStateAlertStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoPilotingStateAlertStateChangedCb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoPilotingStateAlertStateChangedCallback) {
                                decoder->JumpingSumoPilotingStateAlertStateChangedCallback (_state, decoder->JumpingSumoPilotingStateAlertStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoPilotingStateAlertStateChangedCb (_state, ARCOMMANDS_Decoder_JumpingSumoPilotingStateAlertStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_PILOTINGSTATE_CMD_ALERTSTATECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_PILOTINGSTATE_CMD_SPEEDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoPilotingStateSpeedChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoPilotingStateSpeedChangedCb))
                    {
                        int8_t _speed;
                        int16_t _realSpeed;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _realSpeed =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoPilotingStateSpeedChangedCallback) {
                                decoder->JumpingSumoPilotingStateSpeedChangedCallback (_speed, _realSpeed, decoder->JumpingSumoPilotingStateSpeedChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoPilotingStateSpeedChangedCb (_speed, _realSpeed, ARCOMMANDS_Decoder_JumpingSumoPilotingStateSpeedChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_PILOTINGSTATE_CMD_SPEEDCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_PILOTINGSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ANIMATIONS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPSTOP:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoAnimationsJumpStopCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpStopCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoAnimationsJumpStopCallback) {
                                decoder->JumpingSumoAnimationsJumpStopCallback (decoder->JumpingSumoAnimationsJumpStopCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpStopCb (ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpStopCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPSTOP */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPCANCEL:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoAnimationsJumpCancelCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCancelCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoAnimationsJumpCancelCallback) {
                                decoder->JumpingSumoAnimationsJumpCancelCallback (decoder->JumpingSumoAnimationsJumpCancelCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCancelCb (ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCancelCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPCANCEL */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPLOAD:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoAnimationsJumpLoadCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpLoadCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoAnimationsJumpLoadCallback) {
                                decoder->JumpingSumoAnimationsJumpLoadCallback (decoder->JumpingSumoAnimationsJumpLoadCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpLoadCb (ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpLoadCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPLOAD */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMP:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoAnimationsJumpCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_JUMP_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_JUMP_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoAnimationsJumpCallback) {
                                decoder->JumpingSumoAnimationsJumpCallback (_type, decoder->JumpingSumoAnimationsJumpCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCb (_type, ARCOMMANDS_Decoder_JumpingSumoAnimationsJumpCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMP */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_SIMPLEANIMATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoAnimationsSimpleAnimationCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoAnimationsSimpleAnimationCb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_SIMPLEANIMATION_ID _id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _id = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_SIMPLEANIMATION_ID)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoAnimationsSimpleAnimationCallback) {
                                decoder->JumpingSumoAnimationsSimpleAnimationCallback (_id, decoder->JumpingSumoAnimationsSimpleAnimationCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoAnimationsSimpleAnimationCb (_id, ARCOMMANDS_Decoder_JumpingSumoAnimationsSimpleAnimationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_SIMPLEANIMATION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ANIMATIONS */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ANIMATIONSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPLOADCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoAnimationsStateJumpLoadChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpLoadChangedCb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoAnimationsStateJumpLoadChangedCallback) {
                                decoder->JumpingSumoAnimationsStateJumpLoadChangedCallback (_state, decoder->JumpingSumoAnimationsStateJumpLoadChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpLoadChangedCb (_state, ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpLoadChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPLOADCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPTYPECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoAnimationsStateJumpTypeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpTypeChangedCb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoAnimationsStateJumpTypeChangedCallback) {
                                decoder->JumpingSumoAnimationsStateJumpTypeChangedCallback (_state, decoder->JumpingSumoAnimationsStateJumpTypeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpTypeChangedCb (_state, ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpTypeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPTYPECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPMOTORPROBLEMCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoAnimationsStateJumpMotorProblemChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpMotorProblemChangedCb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoAnimationsStateJumpMotorProblemChangedCallback) {
                                decoder->JumpingSumoAnimationsStateJumpMotorProblemChangedCallback (_error, decoder->JumpingSumoAnimationsStateJumpMotorProblemChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpMotorProblemChangedCb (_error, ARCOMMANDS_Decoder_JumpingSumoAnimationsStateJumpMotorProblemChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPMOTORPROBLEMCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ANIMATIONSSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_SETTINGSSTATE_CMD_PRODUCTGPSVERSIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoSettingsStateProductGPSVersionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoSettingsStateProductGPSVersionChangedCb))
                    {
                        char * _software = NULL;
                        char * _hardware = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _software = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _hardware = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoSettingsStateProductGPSVersionChangedCallback) {
                                decoder->JumpingSumoSettingsStateProductGPSVersionChangedCallback (_software, _hardware, decoder->JumpingSumoSettingsStateProductGPSVersionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoSettingsStateProductGPSVersionChangedCb (_software, _hardware, ARCOMMANDS_Decoder_JumpingSumoSettingsStateProductGPSVersionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_SETTINGSSTATE_CMD_PRODUCTGPSVERSIONCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORD:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_PICTURE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoMediaRecordPictureCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureCb))
                    {
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoMediaRecordPictureCallback) {
                                decoder->JumpingSumoMediaRecordPictureCallback (_mass_storage_id, decoder->JumpingSumoMediaRecordPictureCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureCb (_mass_storage_id, ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_PICTURE */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_VIDEO:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoMediaRecordVideoCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoCb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEO_RECORD _record;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _record = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEO_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoMediaRecordVideoCallback) {
                                decoder->JumpingSumoMediaRecordVideoCallback (_record, _mass_storage_id, decoder->JumpingSumoMediaRecordVideoCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoCb (_record, _mass_storage_id, ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_VIDEO */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_PICTUREV2:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoMediaRecordPictureV2Callback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureV2Cb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoMediaRecordPictureV2Callback) {
                                decoder->JumpingSumoMediaRecordPictureV2Callback (decoder->JumpingSumoMediaRecordPictureV2Custom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureV2Cb (ARCOMMANDS_Decoder_JumpingSumoMediaRecordPictureV2Custom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_PICTUREV2 */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_VIDEOV2:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoMediaRecordVideoV2Callback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoV2Cb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEOV2_RECORD _record;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _record = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEOV2_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoMediaRecordVideoV2Callback) {
                                decoder->JumpingSumoMediaRecordVideoV2Callback (_record, decoder->JumpingSumoMediaRecordVideoV2Custom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoV2Cb (_record, ARCOMMANDS_Decoder_JumpingSumoMediaRecordVideoV2Custom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_VIDEOV2 */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORD */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORDSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoMediaRecordStatePictureStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedCb))
                    {
                        uint8_t _state;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoMediaRecordStatePictureStateChangedCallback) {
                                decoder->JumpingSumoMediaRecordStatePictureStateChangedCallback (_state, _mass_storage_id, decoder->JumpingSumoMediaRecordStatePictureStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedCb (_state, _mass_storage_id, ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoMediaRecordStateVideoStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedCb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE _state;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoMediaRecordStateVideoStateChangedCallback) {
                                decoder->JumpingSumoMediaRecordStateVideoStateChangedCallback (_state, _mass_storage_id, decoder->JumpingSumoMediaRecordStateVideoStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedCb (_state, _mass_storage_id, ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoMediaRecordStatePictureStateChangedV2Callback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedV2Cb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state;
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoMediaRecordStatePictureStateChangedV2Callback) {
                                decoder->JumpingSumoMediaRecordStatePictureStateChangedV2Callback (_state, _error, decoder->JumpingSumoMediaRecordStatePictureStateChangedV2Custom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedV2Cb (_state, _error, ARCOMMANDS_Decoder_JumpingSumoMediaRecordStatePictureStateChangedV2Custom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2 */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoMediaRecordStateVideoStateChangedV2Callback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedV2Cb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE _state;
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoMediaRecordStateVideoStateChangedV2Callback) {
                                decoder->JumpingSumoMediaRecordStateVideoStateChangedV2Callback (_state, _error, decoder->JumpingSumoMediaRecordStateVideoStateChangedV2Custom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedV2Cb (_state, _error, ARCOMMANDS_Decoder_JumpingSumoMediaRecordStateVideoStateChangedV2Custom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2 */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORDSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORDEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoMediaRecordEventPictureEventChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventPictureEventChangedCb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event;
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _event = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoMediaRecordEventPictureEventChangedCallback) {
                                decoder->JumpingSumoMediaRecordEventPictureEventChangedCallback (_event, _error, decoder->JumpingSumoMediaRecordEventPictureEventChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventPictureEventChangedCb (_event, _error, ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventPictureEventChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoMediaRecordEventVideoEventChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventVideoEventChangedCb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT _event;
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _event = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoMediaRecordEventVideoEventChangedCallback) {
                                decoder->JumpingSumoMediaRecordEventVideoEventChangedCallback (_event, _error, decoder->JumpingSumoMediaRecordEventVideoEventChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventVideoEventChangedCb (_event, _error, ARCOMMANDS_Decoder_JumpingSumoMediaRecordEventVideoEventChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORDEVENT */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSETTINGS_CMD_WIFISELECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoNetworkSettingsWifiSelectionCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsWifiSelectionCb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_TYPE _type;
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoNetworkSettingsWifiSelectionCallback) {
                                decoder->JumpingSumoNetworkSettingsWifiSelectionCallback (_type, _band, _channel, decoder->JumpingSumoNetworkSettingsWifiSelectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsWifiSelectionCb (_type, _band, _channel, ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsWifiSelectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSETTINGS_CMD_WIFISELECTION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSETTINGS */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoNetworkSettingsStateWifiSelectionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsStateWifiSelectionChangedCb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type;
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoNetworkSettingsStateWifiSelectionChangedCallback) {
                                decoder->JumpingSumoNetworkSettingsStateWifiSelectionChangedCallback (_type, _band, _channel, decoder->JumpingSumoNetworkSettingsStateWifiSelectionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsStateWifiSelectionChangedCb (_type, _band, _channel, ARCOMMANDS_Decoder_JumpingSumoNetworkSettingsStateWifiSelectionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSETTINGSSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORK_CMD_WIFISCAN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoNetworkWifiScanCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoNetworkWifiScanCb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_NETWORK_WIFISCAN_BAND _band;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_JUMPINGSUMO_NETWORK_WIFISCAN_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoNetworkWifiScanCallback) {
                                decoder->JumpingSumoNetworkWifiScanCallback (_band, decoder->JumpingSumoNetworkWifiScanCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoNetworkWifiScanCb (_band, ARCOMMANDS_Decoder_JumpingSumoNetworkWifiScanCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORK_CMD_WIFISCAN */
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORK_CMD_WIFIAUTHCHANNEL:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoNetworkWifiAuthChannelCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoNetworkWifiAuthChannelCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoNetworkWifiAuthChannelCallback) {
                                decoder->JumpingSumoNetworkWifiAuthChannelCallback (decoder->JumpingSumoNetworkWifiAuthChannelCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoNetworkWifiAuthChannelCb (ARCOMMANDS_Decoder_JumpingSumoNetworkWifiAuthChannelCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORK_CMD_WIFIAUTHCHANNEL */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORK */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_WIFISCANLISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoNetworkStateWifiScanListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiScanListChangedCb))
                    {
                        char * _ssid = NULL;
                        int16_t _rssi;
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rssi =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoNetworkStateWifiScanListChangedCallback) {
                                decoder->JumpingSumoNetworkStateWifiScanListChangedCallback (_ssid, _rssi, _band, _channel, decoder->JumpingSumoNetworkStateWifiScanListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiScanListChangedCb (_ssid, _rssi, _band, _channel, ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiScanListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_WIFISCANLISTCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_ALLWIFISCANCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoNetworkStateAllWifiScanChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiScanChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoNetworkStateAllWifiScanChangedCallback) {
                                decoder->JumpingSumoNetworkStateAllWifiScanChangedCallback (decoder->JumpingSumoNetworkStateAllWifiScanChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiScanChangedCb (ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiScanChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_ALLWIFISCANCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoNetworkStateWifiAuthChannelListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiAuthChannelListChangedCb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band;
                        uint8_t _channel;
                        uint8_t _in_or_out;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _in_or_out = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoNetworkStateWifiAuthChannelListChangedCallback) {
                                decoder->JumpingSumoNetworkStateWifiAuthChannelListChangedCallback (_band, _channel, _in_or_out, decoder->JumpingSumoNetworkStateWifiAuthChannelListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiAuthChannelListChangedCb (_band, _channel, _in_or_out, ARCOMMANDS_Decoder_JumpingSumoNetworkStateWifiAuthChannelListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoNetworkStateAllWifiAuthChannelChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiAuthChannelChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoNetworkStateAllWifiAuthChannelChangedCallback) {
                                decoder->JumpingSumoNetworkStateAllWifiAuthChannelChangedCallback (decoder->JumpingSumoNetworkStateAllWifiAuthChannelChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiAuthChannelChangedCb (ARCOMMANDS_Decoder_JumpingSumoNetworkStateAllWifiAuthChannelChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_LINKQUALITYCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoNetworkStateLinkQualityChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoNetworkStateLinkQualityChangedCb))
                    {
                        uint8_t _quality;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _quality = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoNetworkStateLinkQualityChangedCallback) {
                                decoder->JumpingSumoNetworkStateLinkQualityChangedCallback (_quality, decoder->JumpingSumoNetworkStateLinkQualityChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoNetworkStateLinkQualityChangedCb (_quality, ARCOMMANDS_Decoder_JumpingSumoNetworkStateLinkQualityChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_LINKQUALITYCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_AUDIOSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGS_CMD_MASTERVOLUME:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoAudioSettingsMasterVolumeCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoAudioSettingsMasterVolumeCb))
                    {
                        uint8_t _volume;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _volume = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoAudioSettingsMasterVolumeCallback) {
                                decoder->JumpingSumoAudioSettingsMasterVolumeCallback (_volume, decoder->JumpingSumoAudioSettingsMasterVolumeCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoAudioSettingsMasterVolumeCb (_volume, ARCOMMANDS_Decoder_JumpingSumoAudioSettingsMasterVolumeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGS_CMD_MASTERVOLUME */
                case ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGS_CMD_THEME:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoAudioSettingsThemeCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoAudioSettingsThemeCb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGS_THEME_THEME _theme;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _theme = (eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGS_THEME_THEME)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoAudioSettingsThemeCallback) {
                                decoder->JumpingSumoAudioSettingsThemeCallback (_theme, decoder->JumpingSumoAudioSettingsThemeCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoAudioSettingsThemeCb (_theme, ARCOMMANDS_Decoder_JumpingSumoAudioSettingsThemeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGS_CMD_THEME */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_AUDIOSETTINGS */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_AUDIOSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGSSTATE_CMD_MASTERVOLUMECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoAudioSettingsStateMasterVolumeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateMasterVolumeChangedCb))
                    {
                        uint8_t _volume;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _volume = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoAudioSettingsStateMasterVolumeChangedCallback) {
                                decoder->JumpingSumoAudioSettingsStateMasterVolumeChangedCallback (_volume, decoder->JumpingSumoAudioSettingsStateMasterVolumeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateMasterVolumeChangedCb (_volume, ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateMasterVolumeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGSSTATE_CMD_MASTERVOLUMECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGSSTATE_CMD_THEMECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoAudioSettingsStateThemeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateThemeChangedCb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED_THEME _theme;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _theme = (eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED_THEME)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoAudioSettingsStateThemeChangedCallback) {
                                decoder->JumpingSumoAudioSettingsStateThemeChangedCallback (_theme, decoder->JumpingSumoAudioSettingsStateThemeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateThemeChangedCb (_theme, ARCOMMANDS_Decoder_JumpingSumoAudioSettingsStateThemeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGSSTATE_CMD_THEMECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_AUDIOSETTINGSSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ROADPLAN:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_ALLSCRIPTSMETADATA:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoRoadPlanAllScriptsMetadataCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoRoadPlanAllScriptsMetadataCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoRoadPlanAllScriptsMetadataCallback) {
                                decoder->JumpingSumoRoadPlanAllScriptsMetadataCallback (decoder->JumpingSumoRoadPlanAllScriptsMetadataCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoRoadPlanAllScriptsMetadataCb (ARCOMMANDS_Decoder_JumpingSumoRoadPlanAllScriptsMetadataCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_ALLSCRIPTSMETADATA */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_SCRIPTUPLOADED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoRoadPlanScriptUploadedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptUploadedCb))
                    {
                        char * _uuid = NULL;
                        char * _md5Hash = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _uuid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _md5Hash = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoRoadPlanScriptUploadedCallback) {
                                decoder->JumpingSumoRoadPlanScriptUploadedCallback (_uuid, _md5Hash, decoder->JumpingSumoRoadPlanScriptUploadedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptUploadedCb (_uuid, _md5Hash, ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptUploadedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_SCRIPTUPLOADED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_SCRIPTDELETE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoRoadPlanScriptDeleteCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptDeleteCb))
                    {
                        char * _uuid = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _uuid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoRoadPlanScriptDeleteCallback) {
                                decoder->JumpingSumoRoadPlanScriptDeleteCallback (_uuid, decoder->JumpingSumoRoadPlanScriptDeleteCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptDeleteCb (_uuid, ARCOMMANDS_Decoder_JumpingSumoRoadPlanScriptDeleteCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_SCRIPTDELETE */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_PLAYSCRIPT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoRoadPlanPlayScriptCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoRoadPlanPlayScriptCb))
                    {
                        char * _uuid = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _uuid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoRoadPlanPlayScriptCallback) {
                                decoder->JumpingSumoRoadPlanPlayScriptCallback (_uuid, decoder->JumpingSumoRoadPlanPlayScriptCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoRoadPlanPlayScriptCb (_uuid, ARCOMMANDS_Decoder_JumpingSumoRoadPlanPlayScriptCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_PLAYSCRIPT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ROADPLAN */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ROADPLANSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTMETADATALISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoRoadPlanStateScriptMetadataListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptMetadataListChangedCb))
                    {
                        char * _uuid = NULL;
                        uint8_t _version;
                        char * _product = NULL;
                        char * _name = NULL;
                        uint64_t _lastModified;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _uuid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _version = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _product = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _lastModified = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoRoadPlanStateScriptMetadataListChangedCallback) {
                                decoder->JumpingSumoRoadPlanStateScriptMetadataListChangedCallback (_uuid, _version, _product, _name, _lastModified, decoder->JumpingSumoRoadPlanStateScriptMetadataListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptMetadataListChangedCb (_uuid, _version, _product, _name, _lastModified, ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptMetadataListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTMETADATALISTCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_ALLSCRIPTSMETADATACHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoRoadPlanStateAllScriptsMetadataChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateAllScriptsMetadataChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoRoadPlanStateAllScriptsMetadataChangedCallback) {
                                decoder->JumpingSumoRoadPlanStateAllScriptsMetadataChangedCallback (decoder->JumpingSumoRoadPlanStateAllScriptsMetadataChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateAllScriptsMetadataChangedCb (ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateAllScriptsMetadataChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_ALLSCRIPTSMETADATACHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTUPLOADCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoRoadPlanStateScriptUploadChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptUploadChangedCb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED_RESULTCODE _resultCode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _resultCode = (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED_RESULTCODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoRoadPlanStateScriptUploadChangedCallback) {
                                decoder->JumpingSumoRoadPlanStateScriptUploadChangedCallback (_resultCode, decoder->JumpingSumoRoadPlanStateScriptUploadChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptUploadChangedCb (_resultCode, ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptUploadChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTUPLOADCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTDELETECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoRoadPlanStateScriptDeleteChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptDeleteChangedCb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED_RESULTCODE _resultCode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _resultCode = (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED_RESULTCODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoRoadPlanStateScriptDeleteChangedCallback) {
                                decoder->JumpingSumoRoadPlanStateScriptDeleteChangedCallback (_resultCode, decoder->JumpingSumoRoadPlanStateScriptDeleteChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptDeleteChangedCb (_resultCode, ARCOMMANDS_Decoder_JumpingSumoRoadPlanStateScriptDeleteChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTDELETECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_PLAYSCRIPTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoRoadPlanStatePlayScriptChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoRoadPlanStatePlayScriptChangedCb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED_RESULTCODE _resultCode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _resultCode = (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED_RESULTCODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoRoadPlanStatePlayScriptChangedCallback) {
                                decoder->JumpingSumoRoadPlanStatePlayScriptChangedCallback (_resultCode, decoder->JumpingSumoRoadPlanStatePlayScriptChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoRoadPlanStatePlayScriptChangedCb (_resultCode, ARCOMMANDS_Decoder_JumpingSumoRoadPlanStatePlayScriptChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_PLAYSCRIPTCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ROADPLANSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SPEEDSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_SPEEDSETTINGS_CMD_OUTDOOR:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoSpeedSettingsOutdoorCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsOutdoorCb))
                    {
                        uint8_t _outdoor;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _outdoor = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoSpeedSettingsOutdoorCallback) {
                                decoder->JumpingSumoSpeedSettingsOutdoorCallback (_outdoor, decoder->JumpingSumoSpeedSettingsOutdoorCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsOutdoorCb (_outdoor, ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsOutdoorCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_SPEEDSETTINGS_CMD_OUTDOOR */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SPEEDSETTINGS */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SPEEDSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_SPEEDSETTINGSSTATE_CMD_OUTDOORCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoSpeedSettingsStateOutdoorChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsStateOutdoorChangedCb))
                    {
                        uint8_t _outdoor;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _outdoor = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoSpeedSettingsStateOutdoorChangedCallback) {
                                decoder->JumpingSumoSpeedSettingsStateOutdoorChangedCallback (_outdoor, decoder->JumpingSumoSpeedSettingsStateOutdoorChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsStateOutdoorChangedCb (_outdoor, ARCOMMANDS_Decoder_JumpingSumoSpeedSettingsStateOutdoorChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_SPEEDSETTINGSSTATE_CMD_OUTDOORCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SPEEDSETTINGSSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIASTREAMING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIASTREAMING_CMD_VIDEOENABLE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoMediaStreamingVideoEnableCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoMediaStreamingVideoEnableCb))
                    {
                        uint8_t _enable;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enable = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoMediaStreamingVideoEnableCallback) {
                                decoder->JumpingSumoMediaStreamingVideoEnableCallback (_enable, decoder->JumpingSumoMediaStreamingVideoEnableCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoMediaStreamingVideoEnableCb (_enable, ARCOMMANDS_Decoder_JumpingSumoMediaStreamingVideoEnableCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIASTREAMING_CMD_VIDEOENABLE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIASTREAMING */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIASTREAMINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoMediaStreamingStateVideoEnableChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoMediaStreamingStateVideoEnableChangedCb))
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED _enabled;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = (eARCOMMANDS_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoMediaStreamingStateVideoEnableChangedCallback) {
                                decoder->JumpingSumoMediaStreamingStateVideoEnableChangedCallback (_enabled, decoder->JumpingSumoMediaStreamingStateVideoEnableChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoMediaStreamingStateVideoEnableChangedCb (_enabled, ARCOMMANDS_Decoder_JumpingSumoMediaStreamingStateVideoEnableChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIASTREAMINGSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_VIDEOSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_VIDEOSETTINGS_CMD_AUTORECORD:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoVideoSettingsAutorecordCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoVideoSettingsAutorecordCb))
                    {
                        uint8_t _enabled;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoVideoSettingsAutorecordCallback) {
                                decoder->JumpingSumoVideoSettingsAutorecordCallback (_enabled, decoder->JumpingSumoVideoSettingsAutorecordCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoVideoSettingsAutorecordCb (_enabled, ARCOMMANDS_Decoder_JumpingSumoVideoSettingsAutorecordCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_VIDEOSETTINGS_CMD_AUTORECORD */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_VIDEOSETTINGS */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_VIDEOSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_VIDEOSETTINGSSTATE_CMD_AUTORECORDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->JumpingSumoVideoSettingsStateAutorecordChangedCallback) || (!decoder && ARCOMMANDS_Decoder_JumpingSumoVideoSettingsStateAutorecordChangedCb))
                    {
                        uint8_t _enabled;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->JumpingSumoVideoSettingsStateAutorecordChangedCallback) {
                                decoder->JumpingSumoVideoSettingsStateAutorecordChangedCallback (_enabled, decoder->JumpingSumoVideoSettingsStateAutorecordChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_JumpingSumoVideoSettingsStateAutorecordChangedCb (_enabled, ARCOMMANDS_Decoder_JumpingSumoVideoSettingsStateAutorecordChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_VIDEOSETTINGSSTATE_CMD_AUTORECORDCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_VIDEOSETTINGSSTATE */
            default:
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_JUMPINGSUMO */
        case ARCOMMANDS_ID_FEATURE_MAPPER:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MAPPER_CMD_GRAB:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperGrabCallback) || (!decoder && ARCOMMANDS_Decoder_MapperGrabCb))
                    {
                        uint32_t _buttons;
                        uint32_t _axes;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _buttons = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axes = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperGrabCallback) {
                                decoder->MapperGrabCallback (_buttons, _axes, decoder->MapperGrabCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperGrabCb (_buttons, _axes, ARCOMMANDS_Decoder_MapperGrabCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_GRAB */
                case ARCOMMANDS_ID_MAPPER_CMD_MAP_BUTTON_ACTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperMapButtonActionCallback) || (!decoder && ARCOMMANDS_Decoder_MapperMapButtonActionCb))
                    {
                        uint16_t _product;
                        eARCOMMANDS_MAPPER_BUTTON_ACTION _action;
                        uint32_t _buttons;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _product = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _action = (eARCOMMANDS_MAPPER_BUTTON_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _buttons = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperMapButtonActionCallback) {
                                decoder->MapperMapButtonActionCallback (_product, _action, _buttons, decoder->MapperMapButtonActionCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperMapButtonActionCb (_product, _action, _buttons, ARCOMMANDS_Decoder_MapperMapButtonActionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_MAP_BUTTON_ACTION */
                case ARCOMMANDS_ID_MAPPER_CMD_MAP_AXIS_ACTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperMapAxisActionCallback) || (!decoder && ARCOMMANDS_Decoder_MapperMapAxisActionCb))
                    {
                        uint16_t _product;
                        eARCOMMANDS_MAPPER_AXIS_ACTION _action;
                        int32_t _axis;
                        uint32_t _buttons;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _product = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _action = (eARCOMMANDS_MAPPER_AXIS_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _buttons = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperMapAxisActionCallback) {
                                decoder->MapperMapAxisActionCallback (_product, _action, _axis, _buttons, decoder->MapperMapAxisActionCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperMapAxisActionCb (_product, _action, _axis, _buttons, ARCOMMANDS_Decoder_MapperMapAxisActionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_MAP_AXIS_ACTION */
                case ARCOMMANDS_ID_MAPPER_CMD_RESET_MAPPING:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperResetMappingCallback) || (!decoder && ARCOMMANDS_Decoder_MapperResetMappingCb))
                    {
                        uint16_t _product;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _product = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperResetMappingCallback) {
                                decoder->MapperResetMappingCallback (_product, decoder->MapperResetMappingCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperResetMappingCb (_product, ARCOMMANDS_Decoder_MapperResetMappingCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_RESET_MAPPING */
                case ARCOMMANDS_ID_MAPPER_CMD_SET_EXPO:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperSetExpoCallback) || (!decoder && ARCOMMANDS_Decoder_MapperSetExpoCb))
                    {
                        uint16_t _product;
                        int32_t _axis;
                        eARCOMMANDS_MAPPER_EXPO_TYPE _expo;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _product = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _expo = (eARCOMMANDS_MAPPER_EXPO_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperSetExpoCallback) {
                                decoder->MapperSetExpoCallback (_product, _axis, _expo, decoder->MapperSetExpoCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperSetExpoCb (_product, _axis, _expo, ARCOMMANDS_Decoder_MapperSetExpoCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_SET_EXPO */
                case ARCOMMANDS_ID_MAPPER_CMD_SET_INVERTED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperSetInvertedCallback) || (!decoder && ARCOMMANDS_Decoder_MapperSetInvertedCb))
                    {
                        uint16_t _product;
                        int32_t _axis;
                        uint8_t _inverted;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _product = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _inverted = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperSetInvertedCallback) {
                                decoder->MapperSetInvertedCallback (_product, _axis, _inverted, decoder->MapperSetInvertedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperSetInvertedCb (_product, _axis, _inverted, ARCOMMANDS_Decoder_MapperSetInvertedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_SET_INVERTED */
                case ARCOMMANDS_ID_MAPPER_CMD_GRAB_STATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperGrabStateCallback) || (!decoder && ARCOMMANDS_Decoder_MapperGrabStateCb))
                    {
                        uint32_t _buttons;
                        uint32_t _axes;
                        uint32_t _buttons_state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _buttons = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axes = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _buttons_state = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperGrabStateCallback) {
                                decoder->MapperGrabStateCallback (_buttons, _axes, _buttons_state, decoder->MapperGrabStateCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperGrabStateCb (_buttons, _axes, _buttons_state, ARCOMMANDS_Decoder_MapperGrabStateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_GRAB_STATE */
                case ARCOMMANDS_ID_MAPPER_CMD_GRAB_BUTTON_EVENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperGrabButtonEventCallback) || (!decoder && ARCOMMANDS_Decoder_MapperGrabButtonEventCb))
                    {
                        uint32_t _button;
                        eARCOMMANDS_MAPPER_BUTTON_EVENT _event;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _button = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _event = (eARCOMMANDS_MAPPER_BUTTON_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperGrabButtonEventCallback) {
                                decoder->MapperGrabButtonEventCallback (_button, _event, decoder->MapperGrabButtonEventCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperGrabButtonEventCb (_button, _event, ARCOMMANDS_Decoder_MapperGrabButtonEventCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_GRAB_BUTTON_EVENT */
                case ARCOMMANDS_ID_MAPPER_CMD_GRAB_AXIS_EVENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperGrabAxisEventCallback) || (!decoder && ARCOMMANDS_Decoder_MapperGrabAxisEventCb))
                    {
                        uint32_t _axis;
                        int8_t _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperGrabAxisEventCallback) {
                                decoder->MapperGrabAxisEventCallback (_axis, _value, decoder->MapperGrabAxisEventCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperGrabAxisEventCb (_axis, _value, ARCOMMANDS_Decoder_MapperGrabAxisEventCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_GRAB_AXIS_EVENT */
                case ARCOMMANDS_ID_MAPPER_CMD_BUTTON_MAPPING_ITEM:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperButtonMappingItemCallback) || (!decoder && ARCOMMANDS_Decoder_MapperButtonMappingItemCb))
                    {
                        uint32_t _uid;
                        uint16_t _product;
                        eARCOMMANDS_MAPPER_BUTTON_ACTION _action;
                        uint32_t _buttons;
                        uint8_t _list_flags;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _uid = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _product = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _action = (eARCOMMANDS_MAPPER_BUTTON_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _buttons = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _list_flags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperButtonMappingItemCallback) {
                                decoder->MapperButtonMappingItemCallback (_uid, _product, _action, _buttons, _list_flags, decoder->MapperButtonMappingItemCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperButtonMappingItemCb (_uid, _product, _action, _buttons, _list_flags, ARCOMMANDS_Decoder_MapperButtonMappingItemCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_BUTTON_MAPPING_ITEM */
                case ARCOMMANDS_ID_MAPPER_CMD_AXIS_MAPPING_ITEM:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperAxisMappingItemCallback) || (!decoder && ARCOMMANDS_Decoder_MapperAxisMappingItemCb))
                    {
                        uint32_t _uid;
                        uint16_t _product;
                        eARCOMMANDS_MAPPER_AXIS_ACTION _action;
                        int32_t _axis;
                        uint32_t _buttons;
                        uint8_t _list_flags;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _uid = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _product = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _action = (eARCOMMANDS_MAPPER_AXIS_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _buttons = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _list_flags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperAxisMappingItemCallback) {
                                decoder->MapperAxisMappingItemCallback (_uid, _product, _action, _axis, _buttons, _list_flags, decoder->MapperAxisMappingItemCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperAxisMappingItemCb (_uid, _product, _action, _axis, _buttons, _list_flags, ARCOMMANDS_Decoder_MapperAxisMappingItemCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_AXIS_MAPPING_ITEM */
                case ARCOMMANDS_ID_MAPPER_CMD_APPLICATION_AXIS_EVENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperApplicationAxisEventCallback) || (!decoder && ARCOMMANDS_Decoder_MapperApplicationAxisEventCb))
                    {
                        eARCOMMANDS_MAPPER_AXIS_ACTION _action;
                        int8_t _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _action = (eARCOMMANDS_MAPPER_AXIS_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperApplicationAxisEventCallback) {
                                decoder->MapperApplicationAxisEventCallback (_action, _value, decoder->MapperApplicationAxisEventCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperApplicationAxisEventCb (_action, _value, ARCOMMANDS_Decoder_MapperApplicationAxisEventCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_APPLICATION_AXIS_EVENT */
                case ARCOMMANDS_ID_MAPPER_CMD_APPLICATION_BUTTON_EVENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperApplicationButtonEventCallback) || (!decoder && ARCOMMANDS_Decoder_MapperApplicationButtonEventCb))
                    {
                        eARCOMMANDS_MAPPER_BUTTON_ACTION _action;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _action = (eARCOMMANDS_MAPPER_BUTTON_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperApplicationButtonEventCallback) {
                                decoder->MapperApplicationButtonEventCallback (_action, decoder->MapperApplicationButtonEventCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperApplicationButtonEventCb (_action, ARCOMMANDS_Decoder_MapperApplicationButtonEventCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_APPLICATION_BUTTON_EVENT */
                case ARCOMMANDS_ID_MAPPER_CMD_EXPO_MAP_ITEM:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperExpoMapItemCallback) || (!decoder && ARCOMMANDS_Decoder_MapperExpoMapItemCb))
                    {
                        uint32_t _uid;
                        uint16_t _product;
                        int32_t _axis;
                        eARCOMMANDS_MAPPER_EXPO_TYPE _expo;
                        uint8_t _list_flags;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _uid = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _product = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _expo = (eARCOMMANDS_MAPPER_EXPO_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _list_flags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperExpoMapItemCallback) {
                                decoder->MapperExpoMapItemCallback (_uid, _product, _axis, _expo, _list_flags, decoder->MapperExpoMapItemCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperExpoMapItemCb (_uid, _product, _axis, _expo, _list_flags, ARCOMMANDS_Decoder_MapperExpoMapItemCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_EXPO_MAP_ITEM */
                case ARCOMMANDS_ID_MAPPER_CMD_INVERTED_MAP_ITEM:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperInvertedMapItemCallback) || (!decoder && ARCOMMANDS_Decoder_MapperInvertedMapItemCb))
                    {
                        uint32_t _uid;
                        uint16_t _product;
                        int32_t _axis;
                        uint8_t _inverted;
                        uint8_t _list_flags;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _uid = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _product = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _inverted = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _list_flags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperInvertedMapItemCallback) {
                                decoder->MapperInvertedMapItemCallback (_uid, _product, _axis, _inverted, _list_flags, decoder->MapperInvertedMapItemCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperInvertedMapItemCb (_uid, _product, _axis, _inverted, _list_flags, ARCOMMANDS_Decoder_MapperInvertedMapItemCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_INVERTED_MAP_ITEM */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_MAPPER */
        case ARCOMMANDS_ID_FEATURE_MINIDRONE:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_FLATTRIM:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDronePilotingFlatTrimCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDronePilotingFlatTrimCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDronePilotingFlatTrimCallback) {
                                decoder->MiniDronePilotingFlatTrimCallback (decoder->MiniDronePilotingFlatTrimCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDronePilotingFlatTrimCb (ARCOMMANDS_Decoder_MiniDronePilotingFlatTrimCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_FLATTRIM */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_TAKEOFF:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDronePilotingTakeOffCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDronePilotingTakeOffCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDronePilotingTakeOffCallback) {
                                decoder->MiniDronePilotingTakeOffCallback (decoder->MiniDronePilotingTakeOffCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDronePilotingTakeOffCb (ARCOMMANDS_Decoder_MiniDronePilotingTakeOffCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_TAKEOFF */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_PCMD:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDronePilotingPCMDCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDronePilotingPCMDCb))
                    {
                        uint8_t _flag;
                        int8_t _roll;
                        int8_t _pitch;
                        int8_t _yaw;
                        int8_t _gaz;
                        uint32_t _timestamp;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _flag = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _roll =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _pitch =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _yaw =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _gaz =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _timestamp = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDronePilotingPCMDCallback) {
                                decoder->MiniDronePilotingPCMDCallback (_flag, _roll, _pitch, _yaw, _gaz, _timestamp, decoder->MiniDronePilotingPCMDCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDronePilotingPCMDCb (_flag, _roll, _pitch, _yaw, _gaz, _timestamp, ARCOMMANDS_Decoder_MiniDronePilotingPCMDCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_PCMD */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_LANDING:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDronePilotingLandingCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDronePilotingLandingCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDronePilotingLandingCallback) {
                                decoder->MiniDronePilotingLandingCallback (decoder->MiniDronePilotingLandingCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDronePilotingLandingCb (ARCOMMANDS_Decoder_MiniDronePilotingLandingCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_LANDING */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_EMERGENCY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDronePilotingEmergencyCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDronePilotingEmergencyCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDronePilotingEmergencyCallback) {
                                decoder->MiniDronePilotingEmergencyCallback (decoder->MiniDronePilotingEmergencyCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDronePilotingEmergencyCb (ARCOMMANDS_Decoder_MiniDronePilotingEmergencyCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_EMERGENCY */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_AUTOTAKEOFFMODE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDronePilotingAutoTakeOffModeCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDronePilotingAutoTakeOffModeCb))
                    {
                        uint8_t _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDronePilotingAutoTakeOffModeCallback) {
                                decoder->MiniDronePilotingAutoTakeOffModeCallback (_state, decoder->MiniDronePilotingAutoTakeOffModeCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDronePilotingAutoTakeOffModeCb (_state, ARCOMMANDS_Decoder_MiniDronePilotingAutoTakeOffModeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_AUTOTAKEOFFMODE */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_FLYINGMODE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDronePilotingFlyingModeCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDronePilotingFlyingModeCb))
                    {
                        eARCOMMANDS_MINIDRONE_PILOTING_FLYINGMODE_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_MINIDRONE_PILOTING_FLYINGMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDronePilotingFlyingModeCallback) {
                                decoder->MiniDronePilotingFlyingModeCallback (_mode, decoder->MiniDronePilotingFlyingModeCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDronePilotingFlyingModeCb (_mode, ARCOMMANDS_Decoder_MiniDronePilotingFlyingModeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_FLYINGMODE */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_PLANEGEARBOX:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDronePilotingPlaneGearBoxCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDronePilotingPlaneGearBoxCb))
                    {
                        eARCOMMANDS_MINIDRONE_PILOTING_PLANEGEARBOX_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_MINIDRONE_PILOTING_PLANEGEARBOX_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDronePilotingPlaneGearBoxCallback) {
                                decoder->MiniDronePilotingPlaneGearBoxCallback (_state, decoder->MiniDronePilotingPlaneGearBoxCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDronePilotingPlaneGearBoxCb (_state, ARCOMMANDS_Decoder_MiniDronePilotingPlaneGearBoxCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_PLANEGEARBOX */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTING */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_FLATTRIMCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDronePilotingStateFlatTrimChangedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDronePilotingStateFlatTrimChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDronePilotingStateFlatTrimChangedCallback) {
                                decoder->MiniDronePilotingStateFlatTrimChangedCallback (decoder->MiniDronePilotingStateFlatTrimChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDronePilotingStateFlatTrimChangedCb (ARCOMMANDS_Decoder_MiniDronePilotingStateFlatTrimChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_FLATTRIMCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_FLYINGSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDronePilotingStateFlyingStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingStateChangedCb))
                    {
                        eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDronePilotingStateFlyingStateChangedCallback) {
                                decoder->MiniDronePilotingStateFlyingStateChangedCallback (_state, decoder->MiniDronePilotingStateFlyingStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingStateChangedCb (_state, ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_FLYINGSTATECHANGED */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_ALERTSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDronePilotingStateAlertStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDronePilotingStateAlertStateChangedCb))
                    {
                        eARCOMMANDS_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDronePilotingStateAlertStateChangedCallback) {
                                decoder->MiniDronePilotingStateAlertStateChangedCallback (_state, decoder->MiniDronePilotingStateAlertStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDronePilotingStateAlertStateChangedCb (_state, ARCOMMANDS_Decoder_MiniDronePilotingStateAlertStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_ALERTSTATECHANGED */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_AUTOTAKEOFFMODECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDronePilotingStateAutoTakeOffModeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDronePilotingStateAutoTakeOffModeChangedCb))
                    {
                        uint8_t _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDronePilotingStateAutoTakeOffModeChangedCallback) {
                                decoder->MiniDronePilotingStateAutoTakeOffModeChangedCallback (_state, decoder->MiniDronePilotingStateAutoTakeOffModeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDronePilotingStateAutoTakeOffModeChangedCb (_state, ARCOMMANDS_Decoder_MiniDronePilotingStateAutoTakeOffModeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_AUTOTAKEOFFMODECHANGED */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_FLYINGMODECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDronePilotingStateFlyingModeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingModeChangedCb))
                    {
                        eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGMODECHANGED_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGMODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDronePilotingStateFlyingModeChangedCallback) {
                                decoder->MiniDronePilotingStateFlyingModeChangedCallback (_mode, decoder->MiniDronePilotingStateFlyingModeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingModeChangedCb (_mode, ARCOMMANDS_Decoder_MiniDronePilotingStateFlyingModeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_FLYINGMODECHANGED */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_PLANEGEARBOXCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDronePilotingStatePlaneGearBoxChangedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDronePilotingStatePlaneGearBoxChangedCb))
                    {
                        eARCOMMANDS_MINIDRONE_PILOTINGSTATE_PLANEGEARBOXCHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_PLANEGEARBOXCHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDronePilotingStatePlaneGearBoxChangedCallback) {
                                decoder->MiniDronePilotingStatePlaneGearBoxChangedCallback (_state, decoder->MiniDronePilotingStatePlaneGearBoxChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDronePilotingStatePlaneGearBoxChangedCb (_state, ARCOMMANDS_Decoder_MiniDronePilotingStatePlaneGearBoxChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_PLANEGEARBOXCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_ANIMATIONS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_ANIMATIONS_CMD_FLIP:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneAnimationsFlipCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneAnimationsFlipCb))
                    {
                        eARCOMMANDS_MINIDRONE_ANIMATIONS_FLIP_DIRECTION _direction;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _direction = (eARCOMMANDS_MINIDRONE_ANIMATIONS_FLIP_DIRECTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneAnimationsFlipCallback) {
                                decoder->MiniDroneAnimationsFlipCallback (_direction, decoder->MiniDroneAnimationsFlipCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneAnimationsFlipCb (_direction, ARCOMMANDS_Decoder_MiniDroneAnimationsFlipCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_ANIMATIONS_CMD_FLIP */
                case ARCOMMANDS_ID_MINIDRONE_ANIMATIONS_CMD_CAP:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneAnimationsCapCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneAnimationsCapCb))
                    {
                        int16_t _offset;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _offset =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneAnimationsCapCallback) {
                                decoder->MiniDroneAnimationsCapCallback (_offset, decoder->MiniDroneAnimationsCapCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneAnimationsCapCb (_offset, ARCOMMANDS_Decoder_MiniDroneAnimationsCapCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_ANIMATIONS_CMD_CAP */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_ANIMATIONS */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORD:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_MEDIARECORD_CMD_PICTURE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneMediaRecordPictureCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureCb))
                    {
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneMediaRecordPictureCallback) {
                                decoder->MiniDroneMediaRecordPictureCallback (_mass_storage_id, decoder->MiniDroneMediaRecordPictureCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureCb (_mass_storage_id, ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_MEDIARECORD_CMD_PICTURE */
                case ARCOMMANDS_ID_MINIDRONE_MEDIARECORD_CMD_PICTUREV2:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneMediaRecordPictureV2Callback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureV2Cb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneMediaRecordPictureV2Callback) {
                                decoder->MiniDroneMediaRecordPictureV2Callback (decoder->MiniDroneMediaRecordPictureV2Custom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureV2Cb (ARCOMMANDS_Decoder_MiniDroneMediaRecordPictureV2Custom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_MEDIARECORD_CMD_PICTUREV2 */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORD */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORDSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneMediaRecordStatePictureStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedCb))
                    {
                        uint8_t _state;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneMediaRecordStatePictureStateChangedCallback) {
                                decoder->MiniDroneMediaRecordStatePictureStateChangedCallback (_state, _mass_storage_id, decoder->MiniDroneMediaRecordStatePictureStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedCb (_state, _mass_storage_id, ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED */
                case ARCOMMANDS_ID_MINIDRONE_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneMediaRecordStatePictureStateChangedV2Callback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedV2Cb))
                    {
                        eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state;
                        eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneMediaRecordStatePictureStateChangedV2Callback) {
                                decoder->MiniDroneMediaRecordStatePictureStateChangedV2Callback (_state, _error, decoder->MiniDroneMediaRecordStatePictureStateChangedV2Custom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedV2Cb (_state, _error, ARCOMMANDS_Decoder_MiniDroneMediaRecordStatePictureStateChangedV2Custom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2 */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORDSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORDEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneMediaRecordEventPictureEventChangedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneMediaRecordEventPictureEventChangedCb))
                    {
                        eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event;
                        eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _event = (eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneMediaRecordEventPictureEventChangedCallback) {
                                decoder->MiniDroneMediaRecordEventPictureEventChangedCallback (_event, _error, decoder->MiniDroneMediaRecordEventPictureEventChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneMediaRecordEventPictureEventChangedCb (_event, _error, ARCOMMANDS_Decoder_MiniDroneMediaRecordEventPictureEventChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORDEVENT */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGS_CMD_MAXALTITUDE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDronePilotingSettingsMaxAltitudeCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxAltitudeCb))
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDronePilotingSettingsMaxAltitudeCallback) {
                                decoder->MiniDronePilotingSettingsMaxAltitudeCallback (_current, decoder->MiniDronePilotingSettingsMaxAltitudeCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxAltitudeCb (_current, ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxAltitudeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGS_CMD_MAXALTITUDE */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGS_CMD_MAXTILT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDronePilotingSettingsMaxTiltCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxTiltCb))
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDronePilotingSettingsMaxTiltCallback) {
                                decoder->MiniDronePilotingSettingsMaxTiltCallback (_current, decoder->MiniDronePilotingSettingsMaxTiltCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxTiltCb (_current, ARCOMMANDS_Decoder_MiniDronePilotingSettingsMaxTiltCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGS_CMD_MAXTILT */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGS_CMD_PLANEMODEPITCH:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDronePilotingSettingsPlaneModePitchCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDronePilotingSettingsPlaneModePitchCb))
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDronePilotingSettingsPlaneModePitchCallback) {
                                decoder->MiniDronePilotingSettingsPlaneModePitchCallback (_current, decoder->MiniDronePilotingSettingsPlaneModePitchCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDronePilotingSettingsPlaneModePitchCb (_current, ARCOMMANDS_Decoder_MiniDronePilotingSettingsPlaneModePitchCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGS_CMD_PLANEMODEPITCH */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSETTINGS */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGSSTATE_CMD_MAXALTITUDECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDronePilotingSettingsStateMaxAltitudeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxAltitudeChangedCb))
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDronePilotingSettingsStateMaxAltitudeChangedCallback) {
                                decoder->MiniDronePilotingSettingsStateMaxAltitudeChangedCallback (_current, _min, _max, decoder->MiniDronePilotingSettingsStateMaxAltitudeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxAltitudeChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxAltitudeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGSSTATE_CMD_MAXALTITUDECHANGED */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGSSTATE_CMD_MAXTILTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDronePilotingSettingsStateMaxTiltChangedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxTiltChangedCb))
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDronePilotingSettingsStateMaxTiltChangedCallback) {
                                decoder->MiniDronePilotingSettingsStateMaxTiltChangedCallback (_current, _min, _max, decoder->MiniDronePilotingSettingsStateMaxTiltChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxTiltChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_MiniDronePilotingSettingsStateMaxTiltChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGSSTATE_CMD_MAXTILTCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGSSTATE_CMD_PLANEMODEPITCHCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDronePilotingSettingsStatePlaneModePitchChangedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDronePilotingSettingsStatePlaneModePitchChangedCb))
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDronePilotingSettingsStatePlaneModePitchChangedCallback) {
                                decoder->MiniDronePilotingSettingsStatePlaneModePitchChangedCallback (_current, _min, _max, decoder->MiniDronePilotingSettingsStatePlaneModePitchChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDronePilotingSettingsStatePlaneModePitchChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_MiniDronePilotingSettingsStatePlaneModePitchChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGSSTATE_CMD_PLANEMODEPITCHCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSETTINGSSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_SPEEDSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXVERTICALSPEED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneSpeedSettingsMaxVerticalSpeedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxVerticalSpeedCb))
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneSpeedSettingsMaxVerticalSpeedCallback) {
                                decoder->MiniDroneSpeedSettingsMaxVerticalSpeedCallback (_current, decoder->MiniDroneSpeedSettingsMaxVerticalSpeedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxVerticalSpeedCb (_current, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxVerticalSpeedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXVERTICALSPEED */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXROTATIONSPEED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneSpeedSettingsMaxRotationSpeedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxRotationSpeedCb))
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneSpeedSettingsMaxRotationSpeedCallback) {
                                decoder->MiniDroneSpeedSettingsMaxRotationSpeedCallback (_current, decoder->MiniDroneSpeedSettingsMaxRotationSpeedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxRotationSpeedCb (_current, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxRotationSpeedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXROTATIONSPEED */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_WHEELS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneSpeedSettingsWheelsCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneSpeedSettingsWheelsCb))
                    {
                        uint8_t _present;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _present = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneSpeedSettingsWheelsCallback) {
                                decoder->MiniDroneSpeedSettingsWheelsCallback (_present, decoder->MiniDroneSpeedSettingsWheelsCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneSpeedSettingsWheelsCb (_present, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsWheelsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_WHEELS */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXHORIZONTALSPEED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneSpeedSettingsMaxHorizontalSpeedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxHorizontalSpeedCb))
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneSpeedSettingsMaxHorizontalSpeedCallback) {
                                decoder->MiniDroneSpeedSettingsMaxHorizontalSpeedCallback (_current, decoder->MiniDroneSpeedSettingsMaxHorizontalSpeedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxHorizontalSpeedCb (_current, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxHorizontalSpeedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXHORIZONTALSPEED */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXPLANEMODEROTATIONSPEED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneSpeedSettingsMaxPlaneModeRotationSpeedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxPlaneModeRotationSpeedCb))
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneSpeedSettingsMaxPlaneModeRotationSpeedCallback) {
                                decoder->MiniDroneSpeedSettingsMaxPlaneModeRotationSpeedCallback (_current, decoder->MiniDroneSpeedSettingsMaxPlaneModeRotationSpeedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxPlaneModeRotationSpeedCb (_current, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsMaxPlaneModeRotationSpeedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXPLANEMODEROTATIONSPEED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_SPEEDSETTINGS */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_SPEEDSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXVERTICALSPEEDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCb))
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCallback) {
                                decoder->MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCallback (_current, _min, _max, decoder->MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXVERTICALSPEEDCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXROTATIONSPEEDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCb))
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCallback) {
                                decoder->MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCallback (_current, _min, _max, decoder->MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxRotationSpeedChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXROTATIONSPEEDCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_WHEELSCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneSpeedSettingsStateWheelsChangedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateWheelsChangedCb))
                    {
                        uint8_t _present;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _present = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneSpeedSettingsStateWheelsChangedCallback) {
                                decoder->MiniDroneSpeedSettingsStateWheelsChangedCallback (_present, decoder->MiniDroneSpeedSettingsStateWheelsChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateWheelsChangedCb (_present, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateWheelsChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_WHEELSCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXHORIZONTALSPEEDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCb))
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCallback) {
                                decoder->MiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCallback (_current, _min, _max, decoder->MiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXHORIZONTALSPEEDCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXPLANEMODEROTATIONSPEEDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCb))
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCallback) {
                                decoder->MiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCallback (_current, _min, _max, decoder->MiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_MiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXPLANEMODEROTATIONSPEEDCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_SPEEDSETTINGSSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_SETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_SETTINGS_CMD_CUTOUTMODE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneSettingsCutOutModeCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneSettingsCutOutModeCb))
                    {
                        uint8_t _enable;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enable = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneSettingsCutOutModeCallback) {
                                decoder->MiniDroneSettingsCutOutModeCallback (_enable, decoder->MiniDroneSettingsCutOutModeCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneSettingsCutOutModeCb (_enable, ARCOMMANDS_Decoder_MiniDroneSettingsCutOutModeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SETTINGS_CMD_CUTOUTMODE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_SETTINGS */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_PRODUCTMOTORSVERSIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneSettingsStateProductMotorsVersionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneSettingsStateProductMotorsVersionChangedCb))
                    {
                        uint8_t _motor;
                        char * _type = NULL;
                        char * _software = NULL;
                        char * _hardware = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _motor = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _software = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _hardware = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneSettingsStateProductMotorsVersionChangedCallback) {
                                decoder->MiniDroneSettingsStateProductMotorsVersionChangedCallback (_motor, _type, _software, _hardware, decoder->MiniDroneSettingsStateProductMotorsVersionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneSettingsStateProductMotorsVersionChangedCb (_motor, _type, _software, _hardware, ARCOMMANDS_Decoder_MiniDroneSettingsStateProductMotorsVersionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_PRODUCTMOTORSVERSIONCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_PRODUCTINERTIALVERSIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneSettingsStateProductInertialVersionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneSettingsStateProductInertialVersionChangedCb))
                    {
                        char * _software = NULL;
                        char * _hardware = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _software = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _hardware = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneSettingsStateProductInertialVersionChangedCallback) {
                                decoder->MiniDroneSettingsStateProductInertialVersionChangedCallback (_software, _hardware, decoder->MiniDroneSettingsStateProductInertialVersionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneSettingsStateProductInertialVersionChangedCb (_software, _hardware, ARCOMMANDS_Decoder_MiniDroneSettingsStateProductInertialVersionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_PRODUCTINERTIALVERSIONCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_CUTOUTMODECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneSettingsStateCutOutModeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneSettingsStateCutOutModeChangedCb))
                    {
                        uint8_t _enable;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enable = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneSettingsStateCutOutModeChangedCallback) {
                                decoder->MiniDroneSettingsStateCutOutModeChangedCallback (_enable, decoder->MiniDroneSettingsStateCutOutModeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneSettingsStateCutOutModeChangedCb (_enable, ARCOMMANDS_Decoder_MiniDroneSettingsStateCutOutModeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_CUTOUTMODECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_FLOODCONTROLSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_FLOODCONTROLSTATE_CMD_FLOODCONTROLCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneFloodControlStateFloodControlChangedCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneFloodControlStateFloodControlChangedCb))
                    {
                        uint16_t _delay;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _delay = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneFloodControlStateFloodControlChangedCallback) {
                                decoder->MiniDroneFloodControlStateFloodControlChangedCallback (_delay, decoder->MiniDroneFloodControlStateFloodControlChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneFloodControlStateFloodControlChangedCb (_delay, ARCOMMANDS_Decoder_MiniDroneFloodControlStateFloodControlChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_FLOODCONTROLSTATE_CMD_FLOODCONTROLCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_FLOODCONTROLSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_GPS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_GPS_CMD_CONTROLLERLATITUDEFORRUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneGPSControllerLatitudeForRunCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneGPSControllerLatitudeForRunCb))
                    {
                        double _latitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneGPSControllerLatitudeForRunCallback) {
                                decoder->MiniDroneGPSControllerLatitudeForRunCallback (_latitude, decoder->MiniDroneGPSControllerLatitudeForRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneGPSControllerLatitudeForRunCb (_latitude, ARCOMMANDS_Decoder_MiniDroneGPSControllerLatitudeForRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_GPS_CMD_CONTROLLERLATITUDEFORRUN */
                case ARCOMMANDS_ID_MINIDRONE_GPS_CMD_CONTROLLERLONGITUDEFORRUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneGPSControllerLongitudeForRunCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneGPSControllerLongitudeForRunCb))
                    {
                        double _longitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneGPSControllerLongitudeForRunCallback) {
                                decoder->MiniDroneGPSControllerLongitudeForRunCallback (_longitude, decoder->MiniDroneGPSControllerLongitudeForRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneGPSControllerLongitudeForRunCb (_longitude, ARCOMMANDS_Decoder_MiniDroneGPSControllerLongitudeForRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_GPS_CMD_CONTROLLERLONGITUDEFORRUN */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_GPS */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_CONFIGURATION:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_CONFIGURATION_CMD_CONTROLLERTYPE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneConfigurationControllerTypeCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneConfigurationControllerTypeCb))
                    {
                        char * _type = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneConfigurationControllerTypeCallback) {
                                decoder->MiniDroneConfigurationControllerTypeCallback (_type, decoder->MiniDroneConfigurationControllerTypeCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneConfigurationControllerTypeCb (_type, ARCOMMANDS_Decoder_MiniDroneConfigurationControllerTypeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_CONFIGURATION_CMD_CONTROLLERTYPE */
                case ARCOMMANDS_ID_MINIDRONE_CONFIGURATION_CMD_CONTROLLERNAME:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneConfigurationControllerNameCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneConfigurationControllerNameCb))
                    {
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneConfigurationControllerNameCallback) {
                                decoder->MiniDroneConfigurationControllerNameCallback (_name, decoder->MiniDroneConfigurationControllerNameCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneConfigurationControllerNameCb (_name, ARCOMMANDS_Decoder_MiniDroneConfigurationControllerNameCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_CONFIGURATION_CMD_CONTROLLERNAME */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_CONFIGURATION */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_USBACCESSORYSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_USBACCESSORYSTATE_CMD_LIGHTSTATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneUsbAccessoryStateLightStateCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateLightStateCb))
                    {
                        uint8_t _id;
                        eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE_STATE _state;
                        uint8_t _intensity;
                        uint8_t _list_flags;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _intensity = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _list_flags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneUsbAccessoryStateLightStateCallback) {
                                decoder->MiniDroneUsbAccessoryStateLightStateCallback (_id, _state, _intensity, _list_flags, decoder->MiniDroneUsbAccessoryStateLightStateCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateLightStateCb (_id, _state, _intensity, _list_flags, ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateLightStateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_USBACCESSORYSTATE_CMD_LIGHTSTATE */
                case ARCOMMANDS_ID_MINIDRONE_USBACCESSORYSTATE_CMD_CLAWSTATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneUsbAccessoryStateClawStateCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateClawStateCb))
                    {
                        uint8_t _id;
                        eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_CLAWSTATE_STATE _state;
                        uint8_t _list_flags;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_CLAWSTATE_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _list_flags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneUsbAccessoryStateClawStateCallback) {
                                decoder->MiniDroneUsbAccessoryStateClawStateCallback (_id, _state, _list_flags, decoder->MiniDroneUsbAccessoryStateClawStateCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateClawStateCb (_id, _state, _list_flags, ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateClawStateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_USBACCESSORYSTATE_CMD_CLAWSTATE */
                case ARCOMMANDS_ID_MINIDRONE_USBACCESSORYSTATE_CMD_GUNSTATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneUsbAccessoryStateGunStateCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateGunStateCb))
                    {
                        uint8_t _id;
                        eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_GUNSTATE_STATE _state;
                        uint8_t _list_flags;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_GUNSTATE_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _list_flags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneUsbAccessoryStateGunStateCallback) {
                                decoder->MiniDroneUsbAccessoryStateGunStateCallback (_id, _state, _list_flags, decoder->MiniDroneUsbAccessoryStateGunStateCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateGunStateCb (_id, _state, _list_flags, ARCOMMANDS_Decoder_MiniDroneUsbAccessoryStateGunStateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_USBACCESSORYSTATE_CMD_GUNSTATE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_USBACCESSORYSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_USBACCESSORY:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_USBACCESSORY_CMD_LIGHTCONTROL:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneUsbAccessoryLightControlCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneUsbAccessoryLightControlCb))
                    {
                        uint8_t _id;
                        eARCOMMANDS_MINIDRONE_USBACCESSORY_LIGHTCONTROL_MODE _mode;
                        uint8_t _intensity;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_MINIDRONE_USBACCESSORY_LIGHTCONTROL_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _intensity = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneUsbAccessoryLightControlCallback) {
                                decoder->MiniDroneUsbAccessoryLightControlCallback (_id, _mode, _intensity, decoder->MiniDroneUsbAccessoryLightControlCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneUsbAccessoryLightControlCb (_id, _mode, _intensity, ARCOMMANDS_Decoder_MiniDroneUsbAccessoryLightControlCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_USBACCESSORY_CMD_LIGHTCONTROL */
                case ARCOMMANDS_ID_MINIDRONE_USBACCESSORY_CMD_CLAWCONTROL:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneUsbAccessoryClawControlCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneUsbAccessoryClawControlCb))
                    {
                        uint8_t _id;
                        eARCOMMANDS_MINIDRONE_USBACCESSORY_CLAWCONTROL_ACTION _action;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _action = (eARCOMMANDS_MINIDRONE_USBACCESSORY_CLAWCONTROL_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneUsbAccessoryClawControlCallback) {
                                decoder->MiniDroneUsbAccessoryClawControlCallback (_id, _action, decoder->MiniDroneUsbAccessoryClawControlCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneUsbAccessoryClawControlCb (_id, _action, ARCOMMANDS_Decoder_MiniDroneUsbAccessoryClawControlCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_USBACCESSORY_CMD_CLAWCONTROL */
                case ARCOMMANDS_ID_MINIDRONE_USBACCESSORY_CMD_GUNCONTROL:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneUsbAccessoryGunControlCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneUsbAccessoryGunControlCb))
                    {
                        uint8_t _id;
                        eARCOMMANDS_MINIDRONE_USBACCESSORY_GUNCONTROL_ACTION _action;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _action = (eARCOMMANDS_MINIDRONE_USBACCESSORY_GUNCONTROL_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneUsbAccessoryGunControlCallback) {
                                decoder->MiniDroneUsbAccessoryGunControlCallback (_id, _action, decoder->MiniDroneUsbAccessoryGunControlCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneUsbAccessoryGunControlCb (_id, _action, ARCOMMANDS_Decoder_MiniDroneUsbAccessoryGunControlCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_USBACCESSORY_CMD_GUNCONTROL */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_USBACCESSORY */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_REMOTECONTROLLER:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_REMOTECONTROLLER_CMD_SETPAIREDREMOTE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneRemoteControllerSetPairedRemoteCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneRemoteControllerSetPairedRemoteCb))
                    {
                        uint16_t _msb_mac;
                        uint16_t _mid_mac;
                        uint16_t _lsb_mac;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _msb_mac = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mid_mac = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _lsb_mac = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneRemoteControllerSetPairedRemoteCallback) {
                                decoder->MiniDroneRemoteControllerSetPairedRemoteCallback (_msb_mac, _mid_mac, _lsb_mac, decoder->MiniDroneRemoteControllerSetPairedRemoteCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneRemoteControllerSetPairedRemoteCb (_msb_mac, _mid_mac, _lsb_mac, ARCOMMANDS_Decoder_MiniDroneRemoteControllerSetPairedRemoteCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_REMOTECONTROLLER_CMD_SETPAIREDREMOTE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_REMOTECONTROLLER */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_NAVIGATIONDATASTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_NAVIGATIONDATASTATE_CMD_DRONEPOSITION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MiniDroneNavigationDataStateDronePositionCallback) || (!decoder && ARCOMMANDS_Decoder_MiniDroneNavigationDataStateDronePositionCb))
                    {
                        float _posx;
                        float _posy;
                        int16_t _posz;
                        int16_t _psi;
                        int16_t _ts;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _posx = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _posy = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _posz =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _psi =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ts =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MiniDroneNavigationDataStateDronePositionCallback) {
                                decoder->MiniDroneNavigationDataStateDronePositionCallback (_posx, _posy, _posz, _psi, _ts, decoder->MiniDroneNavigationDataStateDronePositionCustom);
                            } else {
                                ARCOMMANDS_Decoder_MiniDroneNavigationDataStateDronePositionCb (_posx, _posy, _posz, _psi, _ts, ARCOMMANDS_Decoder_MiniDroneNavigationDataStateDronePositionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_NAVIGATIONDATASTATE_CMD_DRONEPOSITION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_NAVIGATIONDATASTATE */
            default:
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_MINIDRONE */
        case ARCOMMANDS_ID_FEATURE_POWERUP:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_POWERUP_CLASS_PILOTING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_PILOTING_CMD_PCMD:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupPilotingPCMDCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupPilotingPCMDCb))
                    {
                        uint8_t _flag;
                        uint8_t _throttle;
                        int8_t _roll;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _flag = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _throttle = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _roll =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupPilotingPCMDCallback) {
                                decoder->PowerupPilotingPCMDCallback (_flag, _throttle, _roll, decoder->PowerupPilotingPCMDCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupPilotingPCMDCb (_flag, _throttle, _roll, ARCOMMANDS_Decoder_PowerupPilotingPCMDCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTING_CMD_PCMD */
                case ARCOMMANDS_ID_POWERUP_PILOTING_CMD_USERTAKEOFF:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupPilotingUserTakeOffCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupPilotingUserTakeOffCb))
                    {
                        uint8_t _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupPilotingUserTakeOffCallback) {
                                decoder->PowerupPilotingUserTakeOffCallback (_state, decoder->PowerupPilotingUserTakeOffCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupPilotingUserTakeOffCb (_state, ARCOMMANDS_Decoder_PowerupPilotingUserTakeOffCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTING_CMD_USERTAKEOFF */
                case ARCOMMANDS_ID_POWERUP_PILOTING_CMD_MOTORMODE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupPilotingMotorModeCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupPilotingMotorModeCb))
                    {
                        eARCOMMANDS_POWERUP_PILOTING_MOTORMODE_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_POWERUP_PILOTING_MOTORMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupPilotingMotorModeCallback) {
                                decoder->PowerupPilotingMotorModeCallback (_mode, decoder->PowerupPilotingMotorModeCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupPilotingMotorModeCb (_mode, ARCOMMANDS_Decoder_PowerupPilotingMotorModeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTING_CMD_MOTORMODE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_PILOTING */
            case ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ALERTSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupPilotingStateAlertStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupPilotingStateAlertStateChangedCb))
                    {
                        eARCOMMANDS_POWERUP_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_POWERUP_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupPilotingStateAlertStateChangedCallback) {
                                decoder->PowerupPilotingStateAlertStateChangedCallback (_state, decoder->PowerupPilotingStateAlertStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupPilotingStateAlertStateChangedCb (_state, ARCOMMANDS_Decoder_PowerupPilotingStateAlertStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ALERTSTATECHANGED */
                case ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_FLYINGSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupPilotingStateFlyingStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupPilotingStateFlyingStateChangedCb))
                    {
                        eARCOMMANDS_POWERUP_PILOTINGSTATE_FLYINGSTATECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_POWERUP_PILOTINGSTATE_FLYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupPilotingStateFlyingStateChangedCallback) {
                                decoder->PowerupPilotingStateFlyingStateChangedCallback (_state, decoder->PowerupPilotingStateFlyingStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupPilotingStateFlyingStateChangedCb (_state, ARCOMMANDS_Decoder_PowerupPilotingStateFlyingStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_FLYINGSTATECHANGED */
                case ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_MOTORMODECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupPilotingStateMotorModeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupPilotingStateMotorModeChangedCb))
                    {
                        eARCOMMANDS_POWERUP_PILOTINGSTATE_MOTORMODECHANGED_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_POWERUP_PILOTINGSTATE_MOTORMODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupPilotingStateMotorModeChangedCallback) {
                                decoder->PowerupPilotingStateMotorModeChangedCallback (_mode, decoder->PowerupPilotingStateMotorModeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupPilotingStateMotorModeChangedCb (_mode, ARCOMMANDS_Decoder_PowerupPilotingStateMotorModeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_MOTORMODECHANGED */
                case ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ATTITUDECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupPilotingStateAttitudeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupPilotingStateAttitudeChangedCb))
                    {
                        float _roll;
                        float _pitch;
                        float _yaw;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _roll = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _pitch = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _yaw = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupPilotingStateAttitudeChangedCallback) {
                                decoder->PowerupPilotingStateAttitudeChangedCallback (_roll, _pitch, _yaw, decoder->PowerupPilotingStateAttitudeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupPilotingStateAttitudeChangedCb (_roll, _pitch, _yaw, ARCOMMANDS_Decoder_PowerupPilotingStateAttitudeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ATTITUDECHANGED */
                case ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ALTITUDECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupPilotingStateAltitudeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupPilotingStateAltitudeChangedCb))
                    {
                        float _altitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupPilotingStateAltitudeChangedCallback) {
                                decoder->PowerupPilotingStateAltitudeChangedCallback (_altitude, decoder->PowerupPilotingStateAltitudeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupPilotingStateAltitudeChangedCb (_altitude, ARCOMMANDS_Decoder_PowerupPilotingStateAltitudeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ALTITUDECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_PILOTINGSETTINGS_CMD_SET:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupPilotingSettingsSetCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupPilotingSettingsSetCb))
                    {
                        eARCOMMANDS_POWERUP_PILOTINGSETTINGS_SET_SETTING _setting;
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _setting = (eARCOMMANDS_POWERUP_PILOTINGSETTINGS_SET_SETTING)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupPilotingSettingsSetCallback) {
                                decoder->PowerupPilotingSettingsSetCallback (_setting, _value, decoder->PowerupPilotingSettingsSetCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupPilotingSettingsSetCb (_setting, _value, ARCOMMANDS_Decoder_PowerupPilotingSettingsSetCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSETTINGS_CMD_SET */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSETTINGS */
            case ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_PILOTINGSETTINGSSTATE_CMD_SETTINGCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupPilotingSettingsStateSettingChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupPilotingSettingsStateSettingChangedCb))
                    {
                        eARCOMMANDS_POWERUP_PILOTINGSETTINGSSTATE_SETTINGCHANGED_SETTING _setting;
                        float _current;
                        float _min;
                        float _max;
                        uint8_t _list_flags;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _setting = (eARCOMMANDS_POWERUP_PILOTINGSETTINGSSTATE_SETTINGCHANGED_SETTING)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _list_flags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupPilotingSettingsStateSettingChangedCallback) {
                                decoder->PowerupPilotingSettingsStateSettingChangedCallback (_setting, _current, _min, _max, _list_flags, decoder->PowerupPilotingSettingsStateSettingChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupPilotingSettingsStateSettingChangedCb (_setting, _current, _min, _max, _list_flags, ARCOMMANDS_Decoder_PowerupPilotingSettingsStateSettingChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSETTINGSSTATE_CMD_SETTINGCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSETTINGSSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORD:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_MEDIARECORD_CMD_PICTUREV2:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupMediaRecordPictureV2Callback) || (!decoder && ARCOMMANDS_Decoder_PowerupMediaRecordPictureV2Cb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupMediaRecordPictureV2Callback) {
                                decoder->PowerupMediaRecordPictureV2Callback (decoder->PowerupMediaRecordPictureV2Custom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupMediaRecordPictureV2Cb (ARCOMMANDS_Decoder_PowerupMediaRecordPictureV2Custom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORD_CMD_PICTUREV2 */
                case ARCOMMANDS_ID_POWERUP_MEDIARECORD_CMD_VIDEOV2:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupMediaRecordVideoV2Callback) || (!decoder && ARCOMMANDS_Decoder_PowerupMediaRecordVideoV2Cb))
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORD_VIDEOV2_RECORD _record;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _record = (eARCOMMANDS_POWERUP_MEDIARECORD_VIDEOV2_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupMediaRecordVideoV2Callback) {
                                decoder->PowerupMediaRecordVideoV2Callback (_record, decoder->PowerupMediaRecordVideoV2Custom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupMediaRecordVideoV2Cb (_record, ARCOMMANDS_Decoder_PowerupMediaRecordVideoV2Custom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORD_CMD_VIDEOV2 */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORD */
            case ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORDSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupMediaRecordStatePictureStateChangedV2Callback) || (!decoder && ARCOMMANDS_Decoder_PowerupMediaRecordStatePictureStateChangedV2Cb))
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state;
                        eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupMediaRecordStatePictureStateChangedV2Callback) {
                                decoder->PowerupMediaRecordStatePictureStateChangedV2Callback (_state, _error, decoder->PowerupMediaRecordStatePictureStateChangedV2Custom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupMediaRecordStatePictureStateChangedV2Cb (_state, _error, ARCOMMANDS_Decoder_PowerupMediaRecordStatePictureStateChangedV2Custom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2 */
                case ARCOMMANDS_ID_POWERUP_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupMediaRecordStateVideoStateChangedV2Callback) || (!decoder && ARCOMMANDS_Decoder_PowerupMediaRecordStateVideoStateChangedV2Cb))
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE _state;
                        eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupMediaRecordStateVideoStateChangedV2Callback) {
                                decoder->PowerupMediaRecordStateVideoStateChangedV2Callback (_state, _error, decoder->PowerupMediaRecordStateVideoStateChangedV2Custom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupMediaRecordStateVideoStateChangedV2Cb (_state, _error, ARCOMMANDS_Decoder_PowerupMediaRecordStateVideoStateChangedV2Custom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2 */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORDSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORDEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupMediaRecordEventPictureEventChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupMediaRecordEventPictureEventChangedCb))
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event;
                        eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _event = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupMediaRecordEventPictureEventChangedCallback) {
                                decoder->PowerupMediaRecordEventPictureEventChangedCallback (_event, _error, decoder->PowerupMediaRecordEventPictureEventChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupMediaRecordEventPictureEventChangedCb (_event, _error, ARCOMMANDS_Decoder_PowerupMediaRecordEventPictureEventChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED */
                case ARCOMMANDS_ID_POWERUP_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupMediaRecordEventVideoEventChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupMediaRecordEventVideoEventChangedCb))
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT _event;
                        eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _event = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupMediaRecordEventVideoEventChangedCallback) {
                                decoder->PowerupMediaRecordEventVideoEventChangedCallback (_event, _error, decoder->PowerupMediaRecordEventVideoEventChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupMediaRecordEventVideoEventChangedCb (_event, _error, ARCOMMANDS_Decoder_PowerupMediaRecordEventVideoEventChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORDEVENT */
            case ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_NETWORKSETTINGS_CMD_WIFISELECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupNetworkSettingsWifiSelectionCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupNetworkSettingsWifiSelectionCb))
                    {
                        eARCOMMANDS_POWERUP_NETWORKSETTINGS_WIFISELECTION_TYPE _type;
                        eARCOMMANDS_POWERUP_NETWORKSETTINGS_WIFISELECTION_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_POWERUP_NETWORKSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_POWERUP_NETWORKSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupNetworkSettingsWifiSelectionCallback) {
                                decoder->PowerupNetworkSettingsWifiSelectionCallback (_type, _band, _channel, decoder->PowerupNetworkSettingsWifiSelectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupNetworkSettingsWifiSelectionCb (_type, _band, _channel, ARCOMMANDS_Decoder_PowerupNetworkSettingsWifiSelectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSETTINGS_CMD_WIFISELECTION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSETTINGS */
            case ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupNetworkSettingsStateWifiSelectionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupNetworkSettingsStateWifiSelectionChangedCb))
                    {
                        eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type;
                        eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupNetworkSettingsStateWifiSelectionChangedCallback) {
                                decoder->PowerupNetworkSettingsStateWifiSelectionChangedCallback (_type, _band, _channel, decoder->PowerupNetworkSettingsStateWifiSelectionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupNetworkSettingsStateWifiSelectionChangedCb (_type, _band, _channel, ARCOMMANDS_Decoder_PowerupNetworkSettingsStateWifiSelectionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSETTINGSSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_NETWORK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_NETWORK_CMD_WIFISCAN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupNetworkWifiScanCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupNetworkWifiScanCb))
                    {
                        eARCOMMANDS_POWERUP_NETWORK_WIFISCAN_BAND _band;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_POWERUP_NETWORK_WIFISCAN_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupNetworkWifiScanCallback) {
                                decoder->PowerupNetworkWifiScanCallback (_band, decoder->PowerupNetworkWifiScanCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupNetworkWifiScanCb (_band, ARCOMMANDS_Decoder_PowerupNetworkWifiScanCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORK_CMD_WIFISCAN */
                case ARCOMMANDS_ID_POWERUP_NETWORK_CMD_WIFIAUTHCHANNEL:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupNetworkWifiAuthChannelCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupNetworkWifiAuthChannelCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupNetworkWifiAuthChannelCallback) {
                                decoder->PowerupNetworkWifiAuthChannelCallback (decoder->PowerupNetworkWifiAuthChannelCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupNetworkWifiAuthChannelCb (ARCOMMANDS_Decoder_PowerupNetworkWifiAuthChannelCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORK_CMD_WIFIAUTHCHANNEL */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_NETWORK */
            case ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_WIFISCANLISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupNetworkStateWifiScanListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupNetworkStateWifiScanListChangedCb))
                    {
                        char * _ssid = NULL;
                        int16_t _rssi;
                        eARCOMMANDS_POWERUP_NETWORKSTATE_WIFISCANLISTCHANGED_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rssi =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_POWERUP_NETWORKSTATE_WIFISCANLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupNetworkStateWifiScanListChangedCallback) {
                                decoder->PowerupNetworkStateWifiScanListChangedCallback (_ssid, _rssi, _band, _channel, decoder->PowerupNetworkStateWifiScanListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupNetworkStateWifiScanListChangedCb (_ssid, _rssi, _band, _channel, ARCOMMANDS_Decoder_PowerupNetworkStateWifiScanListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_WIFISCANLISTCHANGED */
                case ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_ALLWIFISCANCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupNetworkStateAllWifiScanChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiScanChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupNetworkStateAllWifiScanChangedCallback) {
                                decoder->PowerupNetworkStateAllWifiScanChangedCallback (decoder->PowerupNetworkStateAllWifiScanChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiScanChangedCb (ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiScanChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_ALLWIFISCANCHANGED */
                case ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupNetworkStateWifiAuthChannelListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupNetworkStateWifiAuthChannelListChangedCb))
                    {
                        eARCOMMANDS_POWERUP_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band;
                        uint8_t _channel;
                        uint8_t _in_or_out;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_POWERUP_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _in_or_out = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupNetworkStateWifiAuthChannelListChangedCallback) {
                                decoder->PowerupNetworkStateWifiAuthChannelListChangedCallback (_band, _channel, _in_or_out, decoder->PowerupNetworkStateWifiAuthChannelListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupNetworkStateWifiAuthChannelListChangedCb (_band, _channel, _in_or_out, ARCOMMANDS_Decoder_PowerupNetworkStateWifiAuthChannelListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED */
                case ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupNetworkStateAllWifiAuthChannelChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiAuthChannelChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupNetworkStateAllWifiAuthChannelChangedCallback) {
                                decoder->PowerupNetworkStateAllWifiAuthChannelChangedCallback (decoder->PowerupNetworkStateAllWifiAuthChannelChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiAuthChannelChangedCb (ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiAuthChannelChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED */
                case ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_LINKQUALITYCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupNetworkStateLinkQualityChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupNetworkStateLinkQualityChangedCb))
                    {
                        uint8_t _quality;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _quality = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupNetworkStateLinkQualityChangedCallback) {
                                decoder->PowerupNetworkStateLinkQualityChangedCallback (_quality, decoder->PowerupNetworkStateLinkQualityChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupNetworkStateLinkQualityChangedCb (_quality, ARCOMMANDS_Decoder_PowerupNetworkStateLinkQualityChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_LINKQUALITYCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_MEDIASTREAMING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_MEDIASTREAMING_CMD_VIDEOENABLE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupMediaStreamingVideoEnableCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupMediaStreamingVideoEnableCb))
                    {
                        uint8_t _enable;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enable = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupMediaStreamingVideoEnableCallback) {
                                decoder->PowerupMediaStreamingVideoEnableCallback (_enable, decoder->PowerupMediaStreamingVideoEnableCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupMediaStreamingVideoEnableCb (_enable, ARCOMMANDS_Decoder_PowerupMediaStreamingVideoEnableCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIASTREAMING_CMD_VIDEOENABLE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_MEDIASTREAMING */
            case ARCOMMANDS_ID_POWERUP_CLASS_MEDIASTREAMINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupMediaStreamingStateVideoEnableChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupMediaStreamingStateVideoEnableChangedCb))
                    {
                        eARCOMMANDS_POWERUP_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED _enabled;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = (eARCOMMANDS_POWERUP_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupMediaStreamingStateVideoEnableChangedCallback) {
                                decoder->PowerupMediaStreamingStateVideoEnableChangedCallback (_enabled, decoder->PowerupMediaStreamingStateVideoEnableChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupMediaStreamingStateVideoEnableChangedCb (_enabled, ARCOMMANDS_Decoder_PowerupMediaStreamingStateVideoEnableChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_MEDIASTREAMINGSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_VIDEOSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_VIDEOSETTINGS_CMD_AUTORECORD:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupVideoSettingsAutorecordCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupVideoSettingsAutorecordCb))
                    {
                        uint8_t _enable;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enable = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupVideoSettingsAutorecordCallback) {
                                decoder->PowerupVideoSettingsAutorecordCallback (_enable, decoder->PowerupVideoSettingsAutorecordCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupVideoSettingsAutorecordCb (_enable, ARCOMMANDS_Decoder_PowerupVideoSettingsAutorecordCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_VIDEOSETTINGS_CMD_AUTORECORD */
                case ARCOMMANDS_ID_POWERUP_VIDEOSETTINGS_CMD_VIDEOMODE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupVideoSettingsVideoModeCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupVideoSettingsVideoModeCb))
                    {
                        eARCOMMANDS_POWERUP_VIDEOSETTINGS_VIDEOMODE_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_POWERUP_VIDEOSETTINGS_VIDEOMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupVideoSettingsVideoModeCallback) {
                                decoder->PowerupVideoSettingsVideoModeCallback (_mode, decoder->PowerupVideoSettingsVideoModeCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupVideoSettingsVideoModeCb (_mode, ARCOMMANDS_Decoder_PowerupVideoSettingsVideoModeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_VIDEOSETTINGS_CMD_VIDEOMODE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_VIDEOSETTINGS */
            case ARCOMMANDS_ID_POWERUP_CLASS_VIDEOSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_VIDEOSETTINGSSTATE_CMD_AUTORECORDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupVideoSettingsStateAutorecordChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupVideoSettingsStateAutorecordChangedCb))
                    {
                        uint8_t _enabled;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupVideoSettingsStateAutorecordChangedCallback) {
                                decoder->PowerupVideoSettingsStateAutorecordChangedCallback (_enabled, decoder->PowerupVideoSettingsStateAutorecordChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupVideoSettingsStateAutorecordChangedCb (_enabled, ARCOMMANDS_Decoder_PowerupVideoSettingsStateAutorecordChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_VIDEOSETTINGSSTATE_CMD_AUTORECORDCHANGED */
                case ARCOMMANDS_ID_POWERUP_VIDEOSETTINGSSTATE_CMD_VIDEOMODECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupVideoSettingsStateVideoModeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupVideoSettingsStateVideoModeChangedCb))
                    {
                        eARCOMMANDS_POWERUP_VIDEOSETTINGSSTATE_VIDEOMODECHANGED_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_POWERUP_VIDEOSETTINGSSTATE_VIDEOMODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupVideoSettingsStateVideoModeChangedCallback) {
                                decoder->PowerupVideoSettingsStateVideoModeChangedCallback (_mode, decoder->PowerupVideoSettingsStateVideoModeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupVideoSettingsStateVideoModeChangedCb (_mode, ARCOMMANDS_Decoder_PowerupVideoSettingsStateVideoModeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_VIDEOSETTINGSSTATE_CMD_VIDEOMODECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_VIDEOSETTINGSSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_SOUNDS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_SOUNDS_CMD_BUZZ:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupSoundsBuzzCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupSoundsBuzzCb))
                    {
                        uint8_t _enable;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enable = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupSoundsBuzzCallback) {
                                decoder->PowerupSoundsBuzzCallback (_enable, decoder->PowerupSoundsBuzzCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupSoundsBuzzCb (_enable, ARCOMMANDS_Decoder_PowerupSoundsBuzzCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_SOUNDS_CMD_BUZZ */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_SOUNDS */
            case ARCOMMANDS_ID_POWERUP_CLASS_SOUNDSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_SOUNDSSTATE_CMD_BUZZCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupSoundsStateBuzzChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupSoundsStateBuzzChangedCb))
                    {
                        uint8_t _enabled;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupSoundsStateBuzzChangedCallback) {
                                decoder->PowerupSoundsStateBuzzChangedCallback (_enabled, decoder->PowerupSoundsStateBuzzChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupSoundsStateBuzzChangedCb (_enabled, ARCOMMANDS_Decoder_PowerupSoundsStateBuzzChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_SOUNDSSTATE_CMD_BUZZCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_SOUNDSSTATE */
            default:
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_POWERUP */
        case ARCOMMANDS_ID_FEATURE_PRO:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_PRO_CLASS_PRO:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_PRO_PRO_CMD_BOUGHTFEATURES:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ProProBoughtFeaturesCallback) || (!decoder && ARCOMMANDS_Decoder_ProProBoughtFeaturesCb))
                    {
                        uint64_t _features;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _features = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ProProBoughtFeaturesCallback) {
                                decoder->ProProBoughtFeaturesCallback (_features, decoder->ProProBoughtFeaturesCustom);
                            } else {
                                ARCOMMANDS_Decoder_ProProBoughtFeaturesCb (_features, ARCOMMANDS_Decoder_ProProBoughtFeaturesCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_PRO_PRO_CMD_BOUGHTFEATURES */
                case ARCOMMANDS_ID_PRO_PRO_CMD_RESPONSE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ProProResponseCallback) || (!decoder && ARCOMMANDS_Decoder_ProProResponseCb))
                    {
                        uint8_t _listFlags;
                        char * _signedChallenge = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _listFlags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _signedChallenge = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ProProResponseCallback) {
                                decoder->ProProResponseCallback (_listFlags, _signedChallenge, decoder->ProProResponseCustom);
                            } else {
                                ARCOMMANDS_Decoder_ProProResponseCb (_listFlags, _signedChallenge, ARCOMMANDS_Decoder_ProProResponseCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_PRO_PRO_CMD_RESPONSE */
                case ARCOMMANDS_ID_PRO_PRO_CMD_ACTIVATEFEATURES:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ProProActivateFeaturesCallback) || (!decoder && ARCOMMANDS_Decoder_ProProActivateFeaturesCb))
                    {
                        uint64_t _features;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _features = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ProProActivateFeaturesCallback) {
                                decoder->ProProActivateFeaturesCallback (_features, decoder->ProProActivateFeaturesCustom);
                            } else {
                                ARCOMMANDS_Decoder_ProProActivateFeaturesCb (_features, ARCOMMANDS_Decoder_ProProActivateFeaturesCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_PRO_PRO_CMD_ACTIVATEFEATURES */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_PRO_CLASS_PRO */
            case ARCOMMANDS_ID_PRO_CLASS_PROSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_PRO_PROSTATE_CMD_SUPPORTEDFEATURES:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ProProStateSupportedFeaturesCallback) || (!decoder && ARCOMMANDS_Decoder_ProProStateSupportedFeaturesCb))
                    {
                        eARCOMMANDS_PRO_PROSTATE_SUPPORTEDFEATURES_STATUS _status;
                        uint64_t _features;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _status = (eARCOMMANDS_PRO_PROSTATE_SUPPORTEDFEATURES_STATUS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _features = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ProProStateSupportedFeaturesCallback) {
                                decoder->ProProStateSupportedFeaturesCallback (_status, _features, decoder->ProProStateSupportedFeaturesCustom);
                            } else {
                                ARCOMMANDS_Decoder_ProProStateSupportedFeaturesCb (_status, _features, ARCOMMANDS_Decoder_ProProStateSupportedFeaturesCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_PRO_PROSTATE_CMD_SUPPORTEDFEATURES */
                case ARCOMMANDS_ID_PRO_PROSTATE_CMD_FEATURESACTIVATED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ProProStateFeaturesActivatedCallback) || (!decoder && ARCOMMANDS_Decoder_ProProStateFeaturesActivatedCb))
                    {
                        uint64_t _features;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _features = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ProProStateFeaturesActivatedCallback) {
                                decoder->ProProStateFeaturesActivatedCallback (_features, decoder->ProProStateFeaturesActivatedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ProProStateFeaturesActivatedCb (_features, ARCOMMANDS_Decoder_ProProStateFeaturesActivatedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_PRO_PROSTATE_CMD_FEATURESACTIVATED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_PRO_CLASS_PROSTATE */
            case ARCOMMANDS_ID_PRO_CLASS_PROEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_PRO_PROEVENT_CMD_CHALLENGEEVENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ProProEventChallengeEventCallback) || (!decoder && ARCOMMANDS_Decoder_ProProEventChallengeEventCb))
                    {
                        char * _challenge = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _challenge = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ProProEventChallengeEventCallback) {
                                decoder->ProProEventChallengeEventCallback (_challenge, decoder->ProProEventChallengeEventCustom);
                            } else {
                                ARCOMMANDS_Decoder_ProProEventChallengeEventCb (_challenge, ARCOMMANDS_Decoder_ProProEventChallengeEventCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_PRO_PROEVENT_CMD_CHALLENGEEVENT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_PRO_CLASS_PROEVENT */
            default:
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_PRO */
        case ARCOMMANDS_ID_FEATURE_RC:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_RC_CMD_MONITOR_CHANNELS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->RcMonitorChannelsCallback) || (!decoder && ARCOMMANDS_Decoder_RcMonitorChannelsCb))
                    {
                        uint8_t _enable;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enable = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->RcMonitorChannelsCallback) {
                                decoder->RcMonitorChannelsCallback (_enable, decoder->RcMonitorChannelsCustom);
                            } else {
                                ARCOMMANDS_Decoder_RcMonitorChannelsCb (_enable, ARCOMMANDS_Decoder_RcMonitorChannelsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_RC_PROEVENT_CMD_MONITOR_CHANNELS */
                case ARCOMMANDS_ID_RC_CMD_START_CALIBRATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->RcStartCalibrationCallback) || (!decoder && ARCOMMANDS_Decoder_RcStartCalibrationCb))
                    {
                        eARCOMMANDS_RC_CALIBRATION_TYPE _type;
                        eARCOMMANDS_RC_CHANNEL_TYPE _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_RC_CALIBRATION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->RcStartCalibrationCallback) {
                                decoder->RcStartCalibrationCallback (_type, _channel, decoder->RcStartCalibrationCustom);
                            } else {
                                ARCOMMANDS_Decoder_RcStartCalibrationCb (_type, _channel, ARCOMMANDS_Decoder_RcStartCalibrationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_RC_PROEVENT_CMD_START_CALIBRATION */
                case ARCOMMANDS_ID_RC_CMD_INVERT_CHANNEL:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->RcInvertChannelCallback) || (!decoder && ARCOMMANDS_Decoder_RcInvertChannelCb))
                    {
                        eARCOMMANDS_RC_CHANNEL_TYPE _channel;
                        uint8_t _flag;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _flag = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->RcInvertChannelCallback) {
                                decoder->RcInvertChannelCallback (_channel, _flag, decoder->RcInvertChannelCustom);
                            } else {
                                ARCOMMANDS_Decoder_RcInvertChannelCb (_channel, _flag, ARCOMMANDS_Decoder_RcInvertChannelCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_RC_PROEVENT_CMD_INVERT_CHANNEL */
                case ARCOMMANDS_ID_RC_CMD_ABORT_CALIBRATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->RcAbortCalibrationCallback) || (!decoder && ARCOMMANDS_Decoder_RcAbortCalibrationCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->RcAbortCalibrationCallback) {
                                decoder->RcAbortCalibrationCallback (decoder->RcAbortCalibrationCustom);
                            } else {
                                ARCOMMANDS_Decoder_RcAbortCalibrationCb (ARCOMMANDS_Decoder_RcAbortCalibrationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_RC_PROEVENT_CMD_ABORT_CALIBRATION */
                case ARCOMMANDS_ID_RC_CMD_RESET_CALIBRATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->RcResetCalibrationCallback) || (!decoder && ARCOMMANDS_Decoder_RcResetCalibrationCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->RcResetCalibrationCallback) {
                                decoder->RcResetCalibrationCallback (decoder->RcResetCalibrationCustom);
                            } else {
                                ARCOMMANDS_Decoder_RcResetCalibrationCb (ARCOMMANDS_Decoder_RcResetCalibrationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_RC_PROEVENT_CMD_RESET_CALIBRATION */
                case ARCOMMANDS_ID_RC_CMD_RECEIVER_STATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->RcReceiverStateCallback) || (!decoder && ARCOMMANDS_Decoder_RcReceiverStateCb))
                    {
                        eARCOMMANDS_RC_RECEIVER_STATE _state;
                        char * _protocol = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_RC_RECEIVER_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _protocol = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->RcReceiverStateCallback) {
                                decoder->RcReceiverStateCallback (_state, _protocol, decoder->RcReceiverStateCustom);
                            } else {
                                ARCOMMANDS_Decoder_RcReceiverStateCb (_state, _protocol, ARCOMMANDS_Decoder_RcReceiverStateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_RC_PROEVENT_CMD_RECEIVER_STATE */
                case ARCOMMANDS_ID_RC_CMD_CHANNELS_MONITOR_STATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->RcChannelsMonitorStateCallback) || (!decoder && ARCOMMANDS_Decoder_RcChannelsMonitorStateCb))
                    {
                        uint8_t _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->RcChannelsMonitorStateCallback) {
                                decoder->RcChannelsMonitorStateCallback (_state, decoder->RcChannelsMonitorStateCustom);
                            } else {
                                ARCOMMANDS_Decoder_RcChannelsMonitorStateCb (_state, ARCOMMANDS_Decoder_RcChannelsMonitorStateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_RC_PROEVENT_CMD_CHANNELS_MONITOR_STATE */
                case ARCOMMANDS_ID_RC_CMD_CHANNEL_VALUE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->RcChannelValueCallback) || (!decoder && ARCOMMANDS_Decoder_RcChannelValueCb))
                    {
                        uint8_t _id;
                        eARCOMMANDS_RC_CHANNEL_TYPE _type;
                        int16_t _value;
                        uint8_t _list_flags;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _list_flags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->RcChannelValueCallback) {
                                decoder->RcChannelValueCallback (_id, _type, _value, _list_flags, decoder->RcChannelValueCustom);
                            } else {
                                ARCOMMANDS_Decoder_RcChannelValueCb (_id, _type, _value, _list_flags, ARCOMMANDS_Decoder_RcChannelValueCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_RC_PROEVENT_CMD_CHANNEL_VALUE */
                case ARCOMMANDS_ID_RC_CMD_CALIBRATION_STATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->RcCalibrationStateCallback) || (!decoder && ARCOMMANDS_Decoder_RcCalibrationStateCb))
                    {
                        eARCOMMANDS_RC_CALIBRATION_TYPE _type;
                        eARCOMMANDS_RC_CHANNEL_TYPE _channel;
                        uint32_t _supported;
                        uint32_t _required;
                        uint32_t _calibrated;
                        uint8_t _neutral_calibrated;
                        uint32_t _inverted;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_RC_CALIBRATION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _supported = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _required = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _calibrated = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _neutral_calibrated = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _inverted = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->RcCalibrationStateCallback) {
                                decoder->RcCalibrationStateCallback (_type, _channel, _supported, _required, _calibrated, _neutral_calibrated, _inverted, decoder->RcCalibrationStateCustom);
                            } else {
                                ARCOMMANDS_Decoder_RcCalibrationStateCb (_type, _channel, _supported, _required, _calibrated, _neutral_calibrated, _inverted, ARCOMMANDS_Decoder_RcCalibrationStateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_RC_PROEVENT_CMD_CALIBRATION_STATE */
                case ARCOMMANDS_ID_RC_CMD_RECEIVER_QUALITY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->RcReceiverQualityCallback) || (!decoder && ARCOMMANDS_Decoder_RcReceiverQualityCb))
                    {
                        uint8_t _level;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _level = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->RcReceiverQualityCallback) {
                                decoder->RcReceiverQualityCallback (_level, decoder->RcReceiverQualityCustom);
                            } else {
                                ARCOMMANDS_Decoder_RcReceiverQualityCb (_level, ARCOMMANDS_Decoder_RcReceiverQualityCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_RC_PROEVENT_CMD_RECEIVER_QUALITY */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_RC */
        case ARCOMMANDS_ID_FEATURE_SKYCONTROLLER:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_WIFISTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFILIST:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerWifiStateWifiListCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerWifiStateWifiListCb))
                    {
                        char * _bssid = NULL;
                        char * _ssid = NULL;
                        uint8_t _secured;
                        uint8_t _saved;
                        int32_t _rssi;
                        int32_t _frequency;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _bssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _secured = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _saved = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rssi =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _frequency =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerWifiStateWifiListCallback) {
                                decoder->SkyControllerWifiStateWifiListCallback (_bssid, _ssid, _secured, _saved, _rssi, _frequency, decoder->SkyControllerWifiStateWifiListCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerWifiStateWifiListCb (_bssid, _ssid, _secured, _saved, _rssi, _frequency, ARCOMMANDS_Decoder_SkyControllerWifiStateWifiListCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFILIST */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_CONNEXIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerWifiStateConnexionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerWifiStateConnexionChangedCb))
                    {
                        char * _ssid = NULL;
                        eARCOMMANDS_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_STATUS _status;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _status = (eARCOMMANDS_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_STATUS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerWifiStateConnexionChangedCallback) {
                                decoder->SkyControllerWifiStateConnexionChangedCallback (_ssid, _status, decoder->SkyControllerWifiStateConnexionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerWifiStateConnexionChangedCb (_ssid, _status, ARCOMMANDS_Decoder_SkyControllerWifiStateConnexionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_CONNEXIONCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFIAUTHCHANNELLISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerWifiStateWifiAuthChannelListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerWifiStateWifiAuthChannelListChangedCb))
                    {
                        eARCOMMANDS_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band;
                        uint8_t _channel;
                        uint8_t _in_or_out;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _in_or_out = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerWifiStateWifiAuthChannelListChangedCallback) {
                                decoder->SkyControllerWifiStateWifiAuthChannelListChangedCallback (_band, _channel, _in_or_out, decoder->SkyControllerWifiStateWifiAuthChannelListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerWifiStateWifiAuthChannelListChangedCb (_band, _channel, _in_or_out, ARCOMMANDS_Decoder_SkyControllerWifiStateWifiAuthChannelListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFIAUTHCHANNELLISTCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_ALLWIFIAUTHCHANNELCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerWifiStateAllWifiAuthChannelChangedCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerWifiStateAllWifiAuthChannelChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerWifiStateAllWifiAuthChannelChangedCallback) {
                                decoder->SkyControllerWifiStateAllWifiAuthChannelChangedCallback (decoder->SkyControllerWifiStateAllWifiAuthChannelChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerWifiStateAllWifiAuthChannelChangedCb (ARCOMMANDS_Decoder_SkyControllerWifiStateAllWifiAuthChannelChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_ALLWIFIAUTHCHANNELCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFISIGNALCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerWifiStateWifiSignalChangedCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerWifiStateWifiSignalChangedCb))
                    {
                        uint8_t _level;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _level = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerWifiStateWifiSignalChangedCallback) {
                                decoder->SkyControllerWifiStateWifiSignalChangedCallback (_level, decoder->SkyControllerWifiStateWifiSignalChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerWifiStateWifiSignalChangedCb (_level, ARCOMMANDS_Decoder_SkyControllerWifiStateWifiSignalChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFISIGNALCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_WIFISTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_WIFI:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_REQUESTWIFILIST:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerWifiRequestWifiListCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerWifiRequestWifiListCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerWifiRequestWifiListCallback) {
                                decoder->SkyControllerWifiRequestWifiListCallback (decoder->SkyControllerWifiRequestWifiListCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerWifiRequestWifiListCb (ARCOMMANDS_Decoder_SkyControllerWifiRequestWifiListCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_REQUESTWIFILIST */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_REQUESTCURRENTWIFI:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerWifiRequestCurrentWifiCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerWifiRequestCurrentWifiCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerWifiRequestCurrentWifiCallback) {
                                decoder->SkyControllerWifiRequestCurrentWifiCallback (decoder->SkyControllerWifiRequestCurrentWifiCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerWifiRequestCurrentWifiCb (ARCOMMANDS_Decoder_SkyControllerWifiRequestCurrentWifiCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_REQUESTCURRENTWIFI */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_CONNECTTOWIFI:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerWifiConnectToWifiCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerWifiConnectToWifiCb))
                    {
                        char * _bssid = NULL;
                        char * _ssid = NULL;
                        char * _passphrase = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _bssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _passphrase = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerWifiConnectToWifiCallback) {
                                decoder->SkyControllerWifiConnectToWifiCallback (_bssid, _ssid, _passphrase, decoder->SkyControllerWifiConnectToWifiCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerWifiConnectToWifiCb (_bssid, _ssid, _passphrase, ARCOMMANDS_Decoder_SkyControllerWifiConnectToWifiCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_CONNECTTOWIFI */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_FORGETWIFI:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerWifiForgetWifiCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerWifiForgetWifiCb))
                    {
                        char * _ssid = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerWifiForgetWifiCallback) {
                                decoder->SkyControllerWifiForgetWifiCallback (_ssid, decoder->SkyControllerWifiForgetWifiCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerWifiForgetWifiCb (_ssid, ARCOMMANDS_Decoder_SkyControllerWifiForgetWifiCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_FORGETWIFI */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_WIFIAUTHCHANNEL:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerWifiWifiAuthChannelCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerWifiWifiAuthChannelCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerWifiWifiAuthChannelCallback) {
                                decoder->SkyControllerWifiWifiAuthChannelCallback (decoder->SkyControllerWifiWifiAuthChannelCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerWifiWifiAuthChannelCb (ARCOMMANDS_Decoder_SkyControllerWifiWifiAuthChannelCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_WIFIAUTHCHANNEL */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_WIFI */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_DEVICE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_REQUESTDEVICELIST:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerDeviceRequestDeviceListCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerDeviceRequestDeviceListCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerDeviceRequestDeviceListCallback) {
                                decoder->SkyControllerDeviceRequestDeviceListCallback (decoder->SkyControllerDeviceRequestDeviceListCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerDeviceRequestDeviceListCb (ARCOMMANDS_Decoder_SkyControllerDeviceRequestDeviceListCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_REQUESTDEVICELIST */
                case ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_REQUESTCURRENTDEVICE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerDeviceRequestCurrentDeviceCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerDeviceRequestCurrentDeviceCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerDeviceRequestCurrentDeviceCallback) {
                                decoder->SkyControllerDeviceRequestCurrentDeviceCallback (decoder->SkyControllerDeviceRequestCurrentDeviceCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerDeviceRequestCurrentDeviceCb (ARCOMMANDS_Decoder_SkyControllerDeviceRequestCurrentDeviceCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_REQUESTCURRENTDEVICE */
                case ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_CONNECTTODEVICE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerDeviceConnectToDeviceCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerDeviceConnectToDeviceCb))
                    {
                        char * _deviceName = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _deviceName = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerDeviceConnectToDeviceCallback) {
                                decoder->SkyControllerDeviceConnectToDeviceCallback (_deviceName, decoder->SkyControllerDeviceConnectToDeviceCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerDeviceConnectToDeviceCb (_deviceName, ARCOMMANDS_Decoder_SkyControllerDeviceConnectToDeviceCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_CONNECTTODEVICE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_DEVICE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_DEVICESTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_DEVICESTATE_CMD_DEVICELIST:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerDeviceStateDeviceListCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerDeviceStateDeviceListCb))
                    {
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerDeviceStateDeviceListCallback) {
                                decoder->SkyControllerDeviceStateDeviceListCallback (_name, decoder->SkyControllerDeviceStateDeviceListCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerDeviceStateDeviceListCb (_name, ARCOMMANDS_Decoder_SkyControllerDeviceStateDeviceListCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_DEVICESTATE_CMD_DEVICELIST */
                case ARCOMMANDS_ID_SKYCONTROLLER_DEVICESTATE_CMD_CONNEXIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerDeviceStateConnexionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerDeviceStateConnexionChangedCb))
                    {
                        eARCOMMANDS_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_STATUS _status;
                        char * _deviceName = NULL;
                        uint16_t _deviceProductID;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _status = (eARCOMMANDS_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_STATUS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _deviceName = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _deviceProductID = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerDeviceStateConnexionChangedCallback) {
                                decoder->SkyControllerDeviceStateConnexionChangedCallback (_status, _deviceName, _deviceProductID, decoder->SkyControllerDeviceStateConnexionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerDeviceStateConnexionChangedCb (_status, _deviceName, _deviceProductID, ARCOMMANDS_Decoder_SkyControllerDeviceStateConnexionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_DEVICESTATE_CMD_CONNEXIONCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_DEVICESTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGS_CMD_ALLSETTINGS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerSettingsAllSettingsCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerSettingsAllSettingsCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerSettingsAllSettingsCallback) {
                                decoder->SkyControllerSettingsAllSettingsCallback (decoder->SkyControllerSettingsAllSettingsCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerSettingsAllSettingsCb (ARCOMMANDS_Decoder_SkyControllerSettingsAllSettingsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGS_CMD_ALLSETTINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGS_CMD_RESET:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerSettingsResetCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerSettingsResetCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerSettingsResetCallback) {
                                decoder->SkyControllerSettingsResetCallback (decoder->SkyControllerSettingsResetCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerSettingsResetCb (ARCOMMANDS_Decoder_SkyControllerSettingsResetCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGS_CMD_RESET */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SETTINGS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_ALLSETTINGSCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerSettingsStateAllSettingsChangedCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerSettingsStateAllSettingsChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerSettingsStateAllSettingsChangedCallback) {
                                decoder->SkyControllerSettingsStateAllSettingsChangedCallback (decoder->SkyControllerSettingsStateAllSettingsChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerSettingsStateAllSettingsChangedCb (ARCOMMANDS_Decoder_SkyControllerSettingsStateAllSettingsChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_ALLSETTINGSCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_RESETCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerSettingsStateResetChangedCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerSettingsStateResetChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerSettingsStateResetChangedCallback) {
                                decoder->SkyControllerSettingsStateResetChangedCallback (decoder->SkyControllerSettingsStateResetChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerSettingsStateResetChangedCb (ARCOMMANDS_Decoder_SkyControllerSettingsStateResetChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_RESETCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_PRODUCTSERIALCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerSettingsStateProductSerialChangedCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerSettingsStateProductSerialChangedCb))
                    {
                        char * _serialNumber = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _serialNumber = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerSettingsStateProductSerialChangedCallback) {
                                decoder->SkyControllerSettingsStateProductSerialChangedCallback (_serialNumber, decoder->SkyControllerSettingsStateProductSerialChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerSettingsStateProductSerialChangedCb (_serialNumber, ARCOMMANDS_Decoder_SkyControllerSettingsStateProductSerialChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_PRODUCTSERIALCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_PRODUCTVARIANTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerSettingsStateProductVariantChangedCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerSettingsStateProductVariantChangedCb))
                    {
                        eARCOMMANDS_SKYCONTROLLER_SETTINGSSTATE_PRODUCTVARIANTCHANGED_VARIANT _variant;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _variant = (eARCOMMANDS_SKYCONTROLLER_SETTINGSSTATE_PRODUCTVARIANTCHANGED_VARIANT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerSettingsStateProductVariantChangedCallback) {
                                decoder->SkyControllerSettingsStateProductVariantChangedCallback (_variant, decoder->SkyControllerSettingsStateProductVariantChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerSettingsStateProductVariantChangedCb (_variant, ARCOMMANDS_Decoder_SkyControllerSettingsStateProductVariantChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_PRODUCTVARIANTCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_PRODUCTVERSIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerSettingsStateProductVersionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerSettingsStateProductVersionChangedCb))
                    {
                        char * _software = NULL;
                        char * _hardware = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _software = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _hardware = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerSettingsStateProductVersionChangedCallback) {
                                decoder->SkyControllerSettingsStateProductVersionChangedCallback (_software, _hardware, decoder->SkyControllerSettingsStateProductVersionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerSettingsStateProductVersionChangedCb (_software, _hardware, ARCOMMANDS_Decoder_SkyControllerSettingsStateProductVersionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_PRODUCTVERSIONCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COMMON:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_COMMON_CMD_ALLSTATES:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerCommonAllStatesCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerCommonAllStatesCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerCommonAllStatesCallback) {
                                decoder->SkyControllerCommonAllStatesCallback (decoder->SkyControllerCommonAllStatesCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerCommonAllStatesCb (ARCOMMANDS_Decoder_SkyControllerCommonAllStatesCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_COMMON_CMD_ALLSTATES */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COMMON */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COMMONSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_COMMONSTATE_CMD_ALLSTATESCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerCommonStateAllStatesChangedCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerCommonStateAllStatesChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerCommonStateAllStatesChangedCallback) {
                                decoder->SkyControllerCommonStateAllStatesChangedCallback (decoder->SkyControllerCommonStateAllStatesChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerCommonStateAllStatesChangedCb (ARCOMMANDS_Decoder_SkyControllerCommonStateAllStatesChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_COMMONSTATE_CMD_ALLSTATESCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COMMONSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SKYCONTROLLERSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_BATTERYCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerSkyControllerStateBatteryChangedCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryChangedCb))
                    {
                        uint8_t _percent;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _percent = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerSkyControllerStateBatteryChangedCallback) {
                                decoder->SkyControllerSkyControllerStateBatteryChangedCallback (_percent, decoder->SkyControllerSkyControllerStateBatteryChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryChangedCb (_percent, ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_BATTERYCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_GPSFIXCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerSkyControllerStateGpsFixChangedCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsFixChangedCb))
                    {
                        uint8_t _fixed;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _fixed = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerSkyControllerStateGpsFixChangedCallback) {
                                decoder->SkyControllerSkyControllerStateGpsFixChangedCallback (_fixed, decoder->SkyControllerSkyControllerStateGpsFixChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsFixChangedCb (_fixed, ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsFixChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_GPSFIXCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_GPSPOSITIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerSkyControllerStateGpsPositionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsPositionChangedCb))
                    {
                        double _latitude;
                        double _longitude;
                        double _altitude;
                        float _heading;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _heading = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerSkyControllerStateGpsPositionChangedCallback) {
                                decoder->SkyControllerSkyControllerStateGpsPositionChangedCallback (_latitude, _longitude, _altitude, _heading, decoder->SkyControllerSkyControllerStateGpsPositionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsPositionChangedCb (_latitude, _longitude, _altitude, _heading, ARCOMMANDS_Decoder_SkyControllerSkyControllerStateGpsPositionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_GPSPOSITIONCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_BATTERYSTATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerSkyControllerStateBatteryStateCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryStateCb))
                    {
                        eARCOMMANDS_SKYCONTROLLER_SKYCONTROLLERSTATE_BATTERYSTATE_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_SKYCONTROLLER_SKYCONTROLLERSTATE_BATTERYSTATE_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerSkyControllerStateBatteryStateCallback) {
                                decoder->SkyControllerSkyControllerStateBatteryStateCallback (_state, decoder->SkyControllerSkyControllerStateBatteryStateCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryStateCb (_state, ARCOMMANDS_Decoder_SkyControllerSkyControllerStateBatteryStateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_BATTERYSTATE */
                case ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_ATTITUDECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerSkyControllerStateAttitudeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerSkyControllerStateAttitudeChangedCb))
                    {
                        float _q0;
                        float _q1;
                        float _q2;
                        float _q3;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _q0 = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _q1 = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _q2 = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _q3 = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerSkyControllerStateAttitudeChangedCallback) {
                                decoder->SkyControllerSkyControllerStateAttitudeChangedCallback (_q0, _q1, _q2, _q3, decoder->SkyControllerSkyControllerStateAttitudeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerSkyControllerStateAttitudeChangedCb (_q0, _q1, _q2, _q3, ARCOMMANDS_Decoder_SkyControllerSkyControllerStateAttitudeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_ATTITUDECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SKYCONTROLLERSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_ACCESSPOINTSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_ACCESSPOINTSSID:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerAccessPointSettingsAccessPointSSIDCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointSSIDCb))
                    {
                        char * _ssid = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerAccessPointSettingsAccessPointSSIDCallback) {
                                decoder->SkyControllerAccessPointSettingsAccessPointSSIDCallback (_ssid, decoder->SkyControllerAccessPointSettingsAccessPointSSIDCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointSSIDCb (_ssid, ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointSSIDCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_ACCESSPOINTSSID */
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_ACCESSPOINTCHANNEL:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerAccessPointSettingsAccessPointChannelCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointChannelCb))
                    {
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerAccessPointSettingsAccessPointChannelCallback) {
                                decoder->SkyControllerAccessPointSettingsAccessPointChannelCallback (_channel, decoder->SkyControllerAccessPointSettingsAccessPointChannelCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointChannelCb (_channel, ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsAccessPointChannelCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_ACCESSPOINTCHANNEL */
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_WIFISELECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerAccessPointSettingsWifiSelectionCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsWifiSelectionCb))
                    {
                        eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_TYPE _type;
                        eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerAccessPointSettingsWifiSelectionCallback) {
                                decoder->SkyControllerAccessPointSettingsWifiSelectionCallback (_type, _band, _channel, decoder->SkyControllerAccessPointSettingsWifiSelectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsWifiSelectionCb (_type, _band, _channel, ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsWifiSelectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_WIFISELECTION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_ACCESSPOINTSETTINGS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_ACCESSPOINTSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_ACCESSPOINTSSIDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCb))
                    {
                        char * _ssid = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCallback) {
                                decoder->SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCallback (_ssid, decoder->SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCb (_ssid, ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointSSIDChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_ACCESSPOINTSSIDCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_ACCESSPOINTCHANNELCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerAccessPointSettingsStateAccessPointChannelChangedCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointChannelChangedCb))
                    {
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerAccessPointSettingsStateAccessPointChannelChangedCallback) {
                                decoder->SkyControllerAccessPointSettingsStateAccessPointChannelChangedCallback (_channel, decoder->SkyControllerAccessPointSettingsStateAccessPointChannelChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointChannelChangedCb (_channel, ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateAccessPointChannelChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_ACCESSPOINTCHANNELCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_WIFISELECTIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerAccessPointSettingsStateWifiSelectionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateWifiSelectionChangedCb))
                    {
                        eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type;
                        eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerAccessPointSettingsStateWifiSelectionChangedCallback) {
                                decoder->SkyControllerAccessPointSettingsStateWifiSelectionChangedCallback (_type, _band, _channel, decoder->SkyControllerAccessPointSettingsStateWifiSelectionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateWifiSelectionChangedCb (_type, _band, _channel, ARCOMMANDS_Decoder_SkyControllerAccessPointSettingsStateWifiSelectionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_WIFISELECTIONCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_ACCESSPOINTSETTINGSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CAMERA:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_CAMERA_CMD_RESETORIENTATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerCameraResetOrientationCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerCameraResetOrientationCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerCameraResetOrientationCallback) {
                                decoder->SkyControllerCameraResetOrientationCallback (decoder->SkyControllerCameraResetOrientationCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerCameraResetOrientationCb (ARCOMMANDS_Decoder_SkyControllerCameraResetOrientationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_CAMERA_CMD_RESETORIENTATION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CAMERA */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_GAMEPADINFOS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOS_CMD_GETGAMEPADCONTROLS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerGamepadInfosGetGamepadControlsCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerGamepadInfosGetGamepadControlsCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerGamepadInfosGetGamepadControlsCallback) {
                                decoder->SkyControllerGamepadInfosGetGamepadControlsCallback (decoder->SkyControllerGamepadInfosGetGamepadControlsCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerGamepadInfosGetGamepadControlsCb (ARCOMMANDS_Decoder_SkyControllerGamepadInfosGetGamepadControlsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOS_CMD_GETGAMEPADCONTROLS */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_GAMEPADINFOS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_GAMEPADINFOSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOSSTATE_CMD_GAMEPADCONTROL:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerGamepadInfosStateGamepadControlCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateGamepadControlCb))
                    {
                        eARCOMMANDS_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_TYPE _type;
                        int32_t _id;
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _id =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerGamepadInfosStateGamepadControlCallback) {
                                decoder->SkyControllerGamepadInfosStateGamepadControlCallback (_type, _id, _name, decoder->SkyControllerGamepadInfosStateGamepadControlCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateGamepadControlCb (_type, _id, _name, ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateGamepadControlCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOSSTATE_CMD_GAMEPADCONTROL */
                case ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOSSTATE_CMD_ALLGAMEPADCONTROLSSENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerGamepadInfosStateAllGamepadControlsSentCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateAllGamepadControlsSentCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerGamepadInfosStateAllGamepadControlsSentCallback) {
                                decoder->SkyControllerGamepadInfosStateAllGamepadControlsSentCallback (decoder->SkyControllerGamepadInfosStateAllGamepadControlsSentCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateAllGamepadControlsSentCb (ARCOMMANDS_Decoder_SkyControllerGamepadInfosStateAllGamepadControlsSentCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOSSTATE_CMD_ALLGAMEPADCONTROLSSENT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_GAMEPADINFOSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_BUTTONMAPPINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_GETCURRENTBUTTONMAPPINGS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerButtonMappingsGetCurrentButtonMappingsCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetCurrentButtonMappingsCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerButtonMappingsGetCurrentButtonMappingsCallback) {
                                decoder->SkyControllerButtonMappingsGetCurrentButtonMappingsCallback (decoder->SkyControllerButtonMappingsGetCurrentButtonMappingsCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetCurrentButtonMappingsCb (ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetCurrentButtonMappingsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_GETCURRENTBUTTONMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_GETAVAILABLEBUTTONMAPPINGS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerButtonMappingsGetAvailableButtonMappingsCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetAvailableButtonMappingsCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerButtonMappingsGetAvailableButtonMappingsCallback) {
                                decoder->SkyControllerButtonMappingsGetAvailableButtonMappingsCallback (decoder->SkyControllerButtonMappingsGetAvailableButtonMappingsCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetAvailableButtonMappingsCb (ARCOMMANDS_Decoder_SkyControllerButtonMappingsGetAvailableButtonMappingsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_GETAVAILABLEBUTTONMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_SETBUTTONMAPPING:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerButtonMappingsSetButtonMappingCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerButtonMappingsSetButtonMappingCb))
                    {
                        int32_t _key_id;
                        char * _mapping_uid = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _key_id =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mapping_uid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerButtonMappingsSetButtonMappingCallback) {
                                decoder->SkyControllerButtonMappingsSetButtonMappingCallback (_key_id, _mapping_uid, decoder->SkyControllerButtonMappingsSetButtonMappingCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerButtonMappingsSetButtonMappingCb (_key_id, _mapping_uid, ARCOMMANDS_Decoder_SkyControllerButtonMappingsSetButtonMappingCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_SETBUTTONMAPPING */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_DEFAULTBUTTONMAPPING:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerButtonMappingsDefaultButtonMappingCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerButtonMappingsDefaultButtonMappingCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerButtonMappingsDefaultButtonMappingCallback) {
                                decoder->SkyControllerButtonMappingsDefaultButtonMappingCallback (decoder->SkyControllerButtonMappingsDefaultButtonMappingCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerButtonMappingsDefaultButtonMappingCb (ARCOMMANDS_Decoder_SkyControllerButtonMappingsDefaultButtonMappingCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_DEFAULTBUTTONMAPPING */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_BUTTONMAPPINGS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_BUTTONMAPPINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_CURRENTBUTTONMAPPINGS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerButtonMappingsStateCurrentButtonMappingsCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateCurrentButtonMappingsCb))
                    {
                        int32_t _key_id;
                        char * _mapping_uid = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _key_id =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mapping_uid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerButtonMappingsStateCurrentButtonMappingsCallback) {
                                decoder->SkyControllerButtonMappingsStateCurrentButtonMappingsCallback (_key_id, _mapping_uid, decoder->SkyControllerButtonMappingsStateCurrentButtonMappingsCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateCurrentButtonMappingsCb (_key_id, _mapping_uid, ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateCurrentButtonMappingsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_CURRENTBUTTONMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_ALLCURRENTBUTTONMAPPINGSSENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCallback) {
                                decoder->SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCallback (decoder->SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCb (ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_ALLCURRENTBUTTONMAPPINGSSENT */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_AVAILABLEBUTTONMAPPINGS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerButtonMappingsStateAvailableButtonMappingsCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAvailableButtonMappingsCb))
                    {
                        char * _mapping_uid = NULL;
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mapping_uid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerButtonMappingsStateAvailableButtonMappingsCallback) {
                                decoder->SkyControllerButtonMappingsStateAvailableButtonMappingsCallback (_mapping_uid, _name, decoder->SkyControllerButtonMappingsStateAvailableButtonMappingsCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAvailableButtonMappingsCb (_mapping_uid, _name, ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAvailableButtonMappingsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_AVAILABLEBUTTONMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_ALLAVAILABLEBUTTONSMAPPINGSSENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCallback) {
                                decoder->SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCallback (decoder->SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCb (ARCOMMANDS_Decoder_SkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_ALLAVAILABLEBUTTONSMAPPINGSSENT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_BUTTONMAPPINGSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISMAPPINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_GETCURRENTAXISMAPPINGS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerAxisMappingsGetCurrentAxisMappingsCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetCurrentAxisMappingsCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerAxisMappingsGetCurrentAxisMappingsCallback) {
                                decoder->SkyControllerAxisMappingsGetCurrentAxisMappingsCallback (decoder->SkyControllerAxisMappingsGetCurrentAxisMappingsCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetCurrentAxisMappingsCb (ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetCurrentAxisMappingsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_GETCURRENTAXISMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_GETAVAILABLEAXISMAPPINGS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerAxisMappingsGetAvailableAxisMappingsCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetAvailableAxisMappingsCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerAxisMappingsGetAvailableAxisMappingsCallback) {
                                decoder->SkyControllerAxisMappingsGetAvailableAxisMappingsCallback (decoder->SkyControllerAxisMappingsGetAvailableAxisMappingsCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetAvailableAxisMappingsCb (ARCOMMANDS_Decoder_SkyControllerAxisMappingsGetAvailableAxisMappingsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_GETAVAILABLEAXISMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_SETAXISMAPPING:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerAxisMappingsSetAxisMappingCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerAxisMappingsSetAxisMappingCb))
                    {
                        int32_t _axis_id;
                        char * _mapping_uid = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis_id =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mapping_uid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerAxisMappingsSetAxisMappingCallback) {
                                decoder->SkyControllerAxisMappingsSetAxisMappingCallback (_axis_id, _mapping_uid, decoder->SkyControllerAxisMappingsSetAxisMappingCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerAxisMappingsSetAxisMappingCb (_axis_id, _mapping_uid, ARCOMMANDS_Decoder_SkyControllerAxisMappingsSetAxisMappingCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_SETAXISMAPPING */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_DEFAULTAXISMAPPING:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerAxisMappingsDefaultAxisMappingCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerAxisMappingsDefaultAxisMappingCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerAxisMappingsDefaultAxisMappingCallback) {
                                decoder->SkyControllerAxisMappingsDefaultAxisMappingCallback (decoder->SkyControllerAxisMappingsDefaultAxisMappingCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerAxisMappingsDefaultAxisMappingCb (ARCOMMANDS_Decoder_SkyControllerAxisMappingsDefaultAxisMappingCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_DEFAULTAXISMAPPING */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISMAPPINGS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISMAPPINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_CURRENTAXISMAPPINGS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerAxisMappingsStateCurrentAxisMappingsCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateCurrentAxisMappingsCb))
                    {
                        int32_t _axis_id;
                        char * _mapping_uid = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis_id =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mapping_uid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerAxisMappingsStateCurrentAxisMappingsCallback) {
                                decoder->SkyControllerAxisMappingsStateCurrentAxisMappingsCallback (_axis_id, _mapping_uid, decoder->SkyControllerAxisMappingsStateCurrentAxisMappingsCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateCurrentAxisMappingsCb (_axis_id, _mapping_uid, ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateCurrentAxisMappingsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_CURRENTAXISMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_ALLCURRENTAXISMAPPINGSSENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCallback) {
                                decoder->SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCallback (decoder->SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCb (ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_ALLCURRENTAXISMAPPINGSSENT */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_AVAILABLEAXISMAPPINGS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerAxisMappingsStateAvailableAxisMappingsCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAvailableAxisMappingsCb))
                    {
                        char * _mapping_uid = NULL;
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mapping_uid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerAxisMappingsStateAvailableAxisMappingsCallback) {
                                decoder->SkyControllerAxisMappingsStateAvailableAxisMappingsCallback (_mapping_uid, _name, decoder->SkyControllerAxisMappingsStateAvailableAxisMappingsCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAvailableAxisMappingsCb (_mapping_uid, _name, ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAvailableAxisMappingsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_AVAILABLEAXISMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_ALLAVAILABLEAXISMAPPINGSSENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCallback) {
                                decoder->SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCallback (decoder->SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCb (ARCOMMANDS_Decoder_SkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_ALLAVAILABLEAXISMAPPINGSSENT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISMAPPINGSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISFILTERS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_GETCURRENTAXISFILTERS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerAxisFiltersGetCurrentAxisFiltersCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetCurrentAxisFiltersCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerAxisFiltersGetCurrentAxisFiltersCallback) {
                                decoder->SkyControllerAxisFiltersGetCurrentAxisFiltersCallback (decoder->SkyControllerAxisFiltersGetCurrentAxisFiltersCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetCurrentAxisFiltersCb (ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetCurrentAxisFiltersCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_GETCURRENTAXISFILTERS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_GETPRESETAXISFILTERS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerAxisFiltersGetPresetAxisFiltersCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetPresetAxisFiltersCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerAxisFiltersGetPresetAxisFiltersCallback) {
                                decoder->SkyControllerAxisFiltersGetPresetAxisFiltersCallback (decoder->SkyControllerAxisFiltersGetPresetAxisFiltersCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetPresetAxisFiltersCb (ARCOMMANDS_Decoder_SkyControllerAxisFiltersGetPresetAxisFiltersCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_GETPRESETAXISFILTERS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_SETAXISFILTER:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerAxisFiltersSetAxisFilterCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerAxisFiltersSetAxisFilterCb))
                    {
                        int32_t _axis_id;
                        char * _filter_uid_or_builder = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis_id =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _filter_uid_or_builder = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerAxisFiltersSetAxisFilterCallback) {
                                decoder->SkyControllerAxisFiltersSetAxisFilterCallback (_axis_id, _filter_uid_or_builder, decoder->SkyControllerAxisFiltersSetAxisFilterCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerAxisFiltersSetAxisFilterCb (_axis_id, _filter_uid_or_builder, ARCOMMANDS_Decoder_SkyControllerAxisFiltersSetAxisFilterCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_SETAXISFILTER */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_DEFAULTAXISFILTERS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerAxisFiltersDefaultAxisFiltersCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerAxisFiltersDefaultAxisFiltersCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerAxisFiltersDefaultAxisFiltersCallback) {
                                decoder->SkyControllerAxisFiltersDefaultAxisFiltersCallback (decoder->SkyControllerAxisFiltersDefaultAxisFiltersCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerAxisFiltersDefaultAxisFiltersCb (ARCOMMANDS_Decoder_SkyControllerAxisFiltersDefaultAxisFiltersCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_DEFAULTAXISFILTERS */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISFILTERS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISFILTERSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_CURRENTAXISFILTERS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerAxisFiltersStateCurrentAxisFiltersCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateCurrentAxisFiltersCb))
                    {
                        int32_t _axis_id;
                        char * _filter_uid_or_builder = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis_id =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _filter_uid_or_builder = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerAxisFiltersStateCurrentAxisFiltersCallback) {
                                decoder->SkyControllerAxisFiltersStateCurrentAxisFiltersCallback (_axis_id, _filter_uid_or_builder, decoder->SkyControllerAxisFiltersStateCurrentAxisFiltersCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateCurrentAxisFiltersCb (_axis_id, _filter_uid_or_builder, ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateCurrentAxisFiltersCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_CURRENTAXISFILTERS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_ALLCURRENTFILTERSSENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerAxisFiltersStateAllCurrentFiltersSentCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllCurrentFiltersSentCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerAxisFiltersStateAllCurrentFiltersSentCallback) {
                                decoder->SkyControllerAxisFiltersStateAllCurrentFiltersSentCallback (decoder->SkyControllerAxisFiltersStateAllCurrentFiltersSentCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllCurrentFiltersSentCb (ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllCurrentFiltersSentCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_ALLCURRENTFILTERSSENT */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_PRESETAXISFILTERS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerAxisFiltersStatePresetAxisFiltersCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerAxisFiltersStatePresetAxisFiltersCb))
                    {
                        char * _filter_uid = NULL;
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _filter_uid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerAxisFiltersStatePresetAxisFiltersCallback) {
                                decoder->SkyControllerAxisFiltersStatePresetAxisFiltersCallback (_filter_uid, _name, decoder->SkyControllerAxisFiltersStatePresetAxisFiltersCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerAxisFiltersStatePresetAxisFiltersCb (_filter_uid, _name, ARCOMMANDS_Decoder_SkyControllerAxisFiltersStatePresetAxisFiltersCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_PRESETAXISFILTERS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_ALLPRESETFILTERSSENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerAxisFiltersStateAllPresetFiltersSentCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllPresetFiltersSentCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerAxisFiltersStateAllPresetFiltersSentCallback) {
                                decoder->SkyControllerAxisFiltersStateAllPresetFiltersSentCallback (decoder->SkyControllerAxisFiltersStateAllPresetFiltersSentCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllPresetFiltersSentCb (ARCOMMANDS_Decoder_SkyControllerAxisFiltersStateAllPresetFiltersSentCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_ALLPRESETFILTERSSENT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISFILTERSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COPILOTING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_COPILOTING_CMD_SETPILOTINGSOURCE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerCoPilotingSetPilotingSourceCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerCoPilotingSetPilotingSourceCb))
                    {
                        eARCOMMANDS_SKYCONTROLLER_COPILOTING_SETPILOTINGSOURCE_SOURCE _source;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _source = (eARCOMMANDS_SKYCONTROLLER_COPILOTING_SETPILOTINGSOURCE_SOURCE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerCoPilotingSetPilotingSourceCallback) {
                                decoder->SkyControllerCoPilotingSetPilotingSourceCallback (_source, decoder->SkyControllerCoPilotingSetPilotingSourceCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerCoPilotingSetPilotingSourceCb (_source, ARCOMMANDS_Decoder_SkyControllerCoPilotingSetPilotingSourceCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_COPILOTING_CMD_SETPILOTINGSOURCE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COPILOTING */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COPILOTINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_COPILOTINGSTATE_CMD_PILOTINGSOURCE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerCoPilotingStatePilotingSourceCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerCoPilotingStatePilotingSourceCb))
                    {
                        eARCOMMANDS_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE_SOURCE _source;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _source = (eARCOMMANDS_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE_SOURCE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerCoPilotingStatePilotingSourceCallback) {
                                decoder->SkyControllerCoPilotingStatePilotingSourceCallback (_source, decoder->SkyControllerCoPilotingStatePilotingSourceCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerCoPilotingStatePilotingSourceCb (_source, ARCOMMANDS_Decoder_SkyControllerCoPilotingStatePilotingSourceCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_COPILOTINGSTATE_CMD_PILOTINGSOURCE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COPILOTINGSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CALIBRATION:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATION_CMD_ENABLEMAGNETOCALIBRATIONQUALITYUPDATES:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCb))
                    {
                        uint8_t _enable;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enable = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCallback) {
                                decoder->SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCallback (_enable, decoder->SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCb (_enable, ARCOMMANDS_Decoder_SkyControllerCalibrationEnableMagnetoCalibrationQualityUpdatesCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATION_CMD_ENABLEMAGNETOCALIBRATIONQUALITYUPDATES */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CALIBRATION */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CALIBRATIONSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerCalibrationStateMagnetoCalibrationStateCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationStateCb))
                    {
                        eARCOMMANDS_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_STATUS _status;
                        uint8_t _X_Quality;
                        uint8_t _Y_Quality;
                        uint8_t _Z_Quality;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _status = (eARCOMMANDS_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_STATUS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _X_Quality = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _Y_Quality = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _Z_Quality = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerCalibrationStateMagnetoCalibrationStateCallback) {
                                decoder->SkyControllerCalibrationStateMagnetoCalibrationStateCallback (_status, _X_Quality, _Y_Quality, _Z_Quality, decoder->SkyControllerCalibrationStateMagnetoCalibrationStateCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationStateCb (_status, _X_Quality, _Y_Quality, _Z_Quality, ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationStateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTATE */
                case ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONQUALITYUPDATESSTATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCb))
                    {
                        uint8_t _enabled;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCallback) {
                                decoder->SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCallback (_enabled, decoder->SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCb (_enabled, ARCOMMANDS_Decoder_SkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONQUALITYUPDATESSTATE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CALIBRATIONSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_BUTTONEVENTS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONEVENTS_CMD_SETTINGS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerButtonEventsSettingsCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerButtonEventsSettingsCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerButtonEventsSettingsCallback) {
                                decoder->SkyControllerButtonEventsSettingsCallback (decoder->SkyControllerButtonEventsSettingsCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerButtonEventsSettingsCb (ARCOMMANDS_Decoder_SkyControllerButtonEventsSettingsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONEVENTS_CMD_SETTINGS */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_BUTTONEVENTS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_FACTORY:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_FACTORY_CMD_RESET:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->SkyControllerFactoryResetCallback) || (!decoder && ARCOMMANDS_Decoder_SkyControllerFactoryResetCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->SkyControllerFactoryResetCallback) {
                                decoder->SkyControllerFactoryResetCallback (decoder->SkyControllerFactoryResetCustom);
                            } else {
                                ARCOMMANDS_Decoder_SkyControllerFactoryResetCb (ARCOMMANDS_Decoder_SkyControllerFactoryResetCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_FACTORY_CMD_RESET */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_FACTORY */
            default:
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_SKYCONTROLLER */
        case ARCOMMANDS_ID_FEATURE_UNKNOWN_FEATURE_1:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_GEOGRAPHIC_RUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1GeographicRunCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1GeographicRunCb))
                    {
                        uint8_t _start;
                        uint8_t _distance_is_default;
                        float _distance;
                        uint8_t _elevation_is_default;
                        float _elevation;
                        uint8_t _azimuth_is_default;
                        float _azimuth;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _start = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _elevation_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _elevation = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _azimuth_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _azimuth = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1GeographicRunCallback) {
                                decoder->UnknownFeature1GeographicRunCallback (_start, _distance_is_default, _distance, _elevation_is_default, _elevation, _azimuth_is_default, _azimuth, decoder->UnknownFeature1GeographicRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1GeographicRunCb (_start, _distance_is_default, _distance, _elevation_is_default, _elevation, _azimuth_is_default, _azimuth, ARCOMMANDS_Decoder_UnknownFeature1GeographicRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_GEOGRAPHIC_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_RELATIVE_RUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1RelativeRunCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1RelativeRunCb))
                    {
                        uint8_t _start;
                        uint8_t _distance_is_default;
                        float _distance;
                        uint8_t _elevation_is_default;
                        float _elevation;
                        uint8_t _azimuth_is_default;
                        float _azimuth;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _start = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _elevation_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _elevation = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _azimuth_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _azimuth = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1RelativeRunCallback) {
                                decoder->UnknownFeature1RelativeRunCallback (_start, _distance_is_default, _distance, _elevation_is_default, _elevation, _azimuth_is_default, _azimuth, decoder->UnknownFeature1RelativeRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1RelativeRunCb (_start, _distance_is_default, _distance, _elevation_is_default, _elevation, _azimuth_is_default, _azimuth, ARCOMMANDS_Decoder_UnknownFeature1RelativeRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_RELATIVE_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_LOOK_AT_RUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1LookAtRunCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1LookAtRunCb))
                    {
                        uint8_t _start;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _start = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1LookAtRunCallback) {
                                decoder->UnknownFeature1LookAtRunCallback (_start, decoder->UnknownFeature1LookAtRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1LookAtRunCb (_start, ARCOMMANDS_Decoder_UnknownFeature1LookAtRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_LOOK_AT_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SPIRAL_ANIM_RUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1SpiralAnimRunCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimRunCb))
                    {
                        uint8_t _start;
                        uint8_t _speed_is_default;
                        float _speed;
                        uint8_t _revolution_nb_is_default;
                        float _revolution_number;
                        uint8_t _vertical_distance_is_default;
                        float _vertical_distance;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _start = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _revolution_nb_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _revolution_number = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1SpiralAnimRunCallback) {
                                decoder->UnknownFeature1SpiralAnimRunCallback (_start, _speed_is_default, _speed, _revolution_nb_is_default, _revolution_number, _vertical_distance_is_default, _vertical_distance, decoder->UnknownFeature1SpiralAnimRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimRunCb (_start, _speed_is_default, _speed, _revolution_nb_is_default, _revolution_number, _vertical_distance_is_default, _vertical_distance, ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_SPIRAL_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SWING_ANIM_RUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1SwingAnimRunCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1SwingAnimRunCb))
                    {
                        uint8_t _start;
                        uint8_t _speed_is_default;
                        float _speed;
                        uint8_t _vertical_distance_is_default;
                        float _vertical_distance;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _start = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1SwingAnimRunCallback) {
                                decoder->UnknownFeature1SwingAnimRunCallback (_start, _speed_is_default, _speed, _vertical_distance_is_default, _vertical_distance, decoder->UnknownFeature1SwingAnimRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1SwingAnimRunCb (_start, _speed_is_default, _speed, _vertical_distance_is_default, _vertical_distance, ARCOMMANDS_Decoder_UnknownFeature1SwingAnimRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_SWING_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_BOOMERANG_ANIM_RUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1BoomerangAnimRunCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimRunCb))
                    {
                        uint8_t _start;
                        uint8_t _speed_is_default;
                        float _speed;
                        uint8_t _distance_is_default;
                        float _distance;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _start = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1BoomerangAnimRunCallback) {
                                decoder->UnknownFeature1BoomerangAnimRunCallback (_start, _speed_is_default, _speed, _distance_is_default, _distance, decoder->UnknownFeature1BoomerangAnimRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimRunCb (_start, _speed_is_default, _speed, _distance_is_default, _distance, ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_BOOMERANG_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_CANDLE_ANIM_RUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1CandleAnimRunCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1CandleAnimRunCb))
                    {
                        uint8_t _start;
                        uint8_t _speed_is_default;
                        float _speed;
                        uint8_t _vertical_distance_is_default;
                        float _vertical_distance;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _start = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1CandleAnimRunCallback) {
                                decoder->UnknownFeature1CandleAnimRunCallback (_start, _speed_is_default, _speed, _vertical_distance_is_default, _vertical_distance, decoder->UnknownFeature1CandleAnimRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1CandleAnimRunCb (_start, _speed_is_default, _speed, _vertical_distance_is_default, _vertical_distance, ARCOMMANDS_Decoder_UnknownFeature1CandleAnimRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_CANDLE_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_DOLLY_SLIDE_ANIM_RUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1DollySlideAnimRunCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimRunCb))
                    {
                        uint8_t _start;
                        uint8_t _speed_is_default;
                        float _speed;
                        uint8_t _angle_is_default;
                        float _angle;
                        uint8_t _horizontal_distance_is_default;
                        float _horizontal_distance;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _start = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _angle_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _angle = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _horizontal_distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _horizontal_distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1DollySlideAnimRunCallback) {
                                decoder->UnknownFeature1DollySlideAnimRunCallback (_start, _speed_is_default, _speed, _angle_is_default, _angle, _horizontal_distance_is_default, _horizontal_distance, decoder->UnknownFeature1DollySlideAnimRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimRunCb (_start, _speed_is_default, _speed, _angle_is_default, _angle, _horizontal_distance_is_default, _horizontal_distance, ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_DOLLY_SLIDE_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_FRAMING_POSITION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1UserFramingPositionCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionCb))
                    {
                        int8_t _horizontal;
                        int8_t _vertical;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _horizontal =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1UserFramingPositionCallback) {
                                decoder->UnknownFeature1UserFramingPositionCallback (_horizontal, _vertical, decoder->UnknownFeature1UserFramingPositionCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionCb (_horizontal, _vertical, ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_USER_FRAMING_POSITION */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_GPS_DATA:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1UserGPSDataCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1UserGPSDataCb))
                    {
                        double _latitude;
                        double _longitude;
                        float _altitude;
                        float _horizontal_accuracy;
                        float _vertical_accuracy;
                        float _north_speed;
                        float _east_speed;
                        float _down_speed;
                        double _timestamp;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _horizontal_accuracy = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_accuracy = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _north_speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _east_speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _down_speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _timestamp = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1UserGPSDataCallback) {
                                decoder->UnknownFeature1UserGPSDataCallback (_latitude, _longitude, _altitude, _horizontal_accuracy, _vertical_accuracy, _north_speed, _east_speed, _down_speed, _timestamp, decoder->UnknownFeature1UserGPSDataCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1UserGPSDataCb (_latitude, _longitude, _altitude, _horizontal_accuracy, _vertical_accuracy, _north_speed, _east_speed, _down_speed, _timestamp, ARCOMMANDS_Decoder_UnknownFeature1UserGPSDataCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_USER_GPS_DATA */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_BARO_DATA:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1UserBaroDataCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1UserBaroDataCb))
                    {
                        float _pressure;
                        double _timestamp;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _pressure = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _timestamp = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1UserBaroDataCallback) {
                                decoder->UnknownFeature1UserBaroDataCallback (_pressure, _timestamp, decoder->UnknownFeature1UserBaroDataCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1UserBaroDataCb (_pressure, _timestamp, ARCOMMANDS_Decoder_UnknownFeature1UserBaroDataCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_USER_BARO_DATA */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_LYNX_DETECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1LynxDetectionCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1LynxDetectionCb))
                    {
                        float _target_pan;
                        float _target_tilt;
                        float _change_of_scale;
                        uint8_t _confidence_index;
                        uint8_t _is_new_selection;
                        uint64_t _timestamp;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _target_pan = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _target_tilt = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _change_of_scale = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _confidence_index = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _is_new_selection = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _timestamp = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1LynxDetectionCallback) {
                                decoder->UnknownFeature1LynxDetectionCallback (_target_pan, _target_tilt, _change_of_scale, _confidence_index, _is_new_selection, _timestamp, decoder->UnknownFeature1LynxDetectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1LynxDetectionCb (_target_pan, _target_tilt, _change_of_scale, _confidence_index, _is_new_selection, _timestamp, ARCOMMANDS_Decoder_UnknownFeature1LynxDetectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_LYNX_DETECTION */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_AVAILABILITY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1AvailabilityCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1AvailabilityCb))
                    {
                        eARCOMMANDS_UNKNOWN_FEATURE_1_TYPES_AVAILABLE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_UNKNOWN_FEATURE_1_TYPES_AVAILABLE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1AvailabilityCallback) {
                                decoder->UnknownFeature1AvailabilityCallback (_type, decoder->UnknownFeature1AvailabilityCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1AvailabilityCb (_type, ARCOMMANDS_Decoder_UnknownFeature1AvailabilityCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_AVAILABILITY */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_RUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1RunCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1RunCb))
                    {
                        eARCOMMANDS_UNKNOWN_FEATURE_1_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_UNKNOWN_FEATURE_1_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1RunCallback) {
                                decoder->UnknownFeature1RunCallback (_type, decoder->UnknownFeature1RunCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1RunCb (_type, ARCOMMANDS_Decoder_UnknownFeature1RunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_GEOGRAPHIC_CONFIG_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1GeographicConfigChangedCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1GeographicConfigChangedCb))
                    {
                        uint8_t _distance_is_default;
                        float _distance;
                        uint8_t _elevation_is_default;
                        float _elevation;
                        uint8_t _azimuth_is_default;
                        float _azimuth;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _elevation_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _elevation = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _azimuth_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _azimuth = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1GeographicConfigChangedCallback) {
                                decoder->UnknownFeature1GeographicConfigChangedCallback (_distance_is_default, _distance, _elevation_is_default, _elevation, _azimuth_is_default, _azimuth, decoder->UnknownFeature1GeographicConfigChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1GeographicConfigChangedCb (_distance_is_default, _distance, _elevation_is_default, _elevation, _azimuth_is_default, _azimuth, ARCOMMANDS_Decoder_UnknownFeature1GeographicConfigChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_GEOGRAPHIC_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_RELATIVE_CONFIG_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1RelativeConfigChangedCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1RelativeConfigChangedCb))
                    {
                        uint8_t _distance_is_default;
                        float _distance;
                        uint8_t _elevation_is_default;
                        float _elevation;
                        uint8_t _azimuth_is_default;
                        float _azimuth;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _elevation_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _elevation = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _azimuth_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _azimuth = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1RelativeConfigChangedCallback) {
                                decoder->UnknownFeature1RelativeConfigChangedCallback (_distance_is_default, _distance, _elevation_is_default, _elevation, _azimuth_is_default, _azimuth, decoder->UnknownFeature1RelativeConfigChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1RelativeConfigChangedCb (_distance_is_default, _distance, _elevation_is_default, _elevation, _azimuth_is_default, _azimuth, ARCOMMANDS_Decoder_UnknownFeature1RelativeConfigChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_RELATIVE_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_ANIM_RUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1AnimRunCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1AnimRunCb))
                    {
                        eARCOMMANDS_UNKNOWN_FEATURE_1_ANIM_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_UNKNOWN_FEATURE_1_ANIM_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1AnimRunCallback) {
                                decoder->UnknownFeature1AnimRunCallback (_type, decoder->UnknownFeature1AnimRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1AnimRunCb (_type, ARCOMMANDS_Decoder_UnknownFeature1AnimRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SPIRAL_ANIM_CONFIG_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1SpiralAnimConfigChangedCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimConfigChangedCb))
                    {
                        uint8_t _speed_is_default;
                        float _speed;
                        uint8_t _revolution_nb_is_default;
                        float _revolution_nb;
                        uint8_t _vertical_distance_is_default;
                        float _vertical_distance;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _revolution_nb_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _revolution_nb = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1SpiralAnimConfigChangedCallback) {
                                decoder->UnknownFeature1SpiralAnimConfigChangedCallback (_speed_is_default, _speed, _revolution_nb_is_default, _revolution_nb, _vertical_distance_is_default, _vertical_distance, decoder->UnknownFeature1SpiralAnimConfigChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimConfigChangedCb (_speed_is_default, _speed, _revolution_nb_is_default, _revolution_nb, _vertical_distance_is_default, _vertical_distance, ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimConfigChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_SPIRAL_ANIM_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SWING_ANIM_CONFIG_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1SwingAnimConfigChangedCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1SwingAnimConfigChangedCb))
                    {
                        uint8_t _speed_is_default;
                        float _speed;
                        uint8_t _vertical_distance_is_default;
                        float _vertical_distance;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1SwingAnimConfigChangedCallback) {
                                decoder->UnknownFeature1SwingAnimConfigChangedCallback (_speed_is_default, _speed, _vertical_distance_is_default, _vertical_distance, decoder->UnknownFeature1SwingAnimConfigChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1SwingAnimConfigChangedCb (_speed_is_default, _speed, _vertical_distance_is_default, _vertical_distance, ARCOMMANDS_Decoder_UnknownFeature1SwingAnimConfigChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_SWING_ANIM_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_BOOMERANG_ANIM_CONFIG_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1BoomerangAnimConfigChangedCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimConfigChangedCb))
                    {
                        uint8_t _speed_is_default;
                        float _speed;
                        uint8_t _distance_is_default;
                        float _distance;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1BoomerangAnimConfigChangedCallback) {
                                decoder->UnknownFeature1BoomerangAnimConfigChangedCallback (_speed_is_default, _speed, _distance_is_default, _distance, decoder->UnknownFeature1BoomerangAnimConfigChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimConfigChangedCb (_speed_is_default, _speed, _distance_is_default, _distance, ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimConfigChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_BOOMERANG_ANIM_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_CANDLE_ANIM_CONFIG_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1CandleAnimConfigChangedCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1CandleAnimConfigChangedCb))
                    {
                        uint8_t _speed_is_default;
                        float _speed;
                        uint8_t _vertical_distance_is_default;
                        float _vertical_distance;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1CandleAnimConfigChangedCallback) {
                                decoder->UnknownFeature1CandleAnimConfigChangedCallback (_speed_is_default, _speed, _vertical_distance_is_default, _vertical_distance, decoder->UnknownFeature1CandleAnimConfigChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1CandleAnimConfigChangedCb (_speed_is_default, _speed, _vertical_distance_is_default, _vertical_distance, ARCOMMANDS_Decoder_UnknownFeature1CandleAnimConfigChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_CANDLE_ANIM_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_DOLLY_SLIDE_ANIM_CONFIG_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1DollySlideAnimConfigChangedCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimConfigChangedCb))
                    {
                        uint8_t _speed_is_default;
                        float _speed;
                        uint8_t _angle_is_default;
                        float _angle;
                        uint8_t _horizontal_distance_is_default;
                        float _horizontal_distance;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _angle_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _angle = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _horizontal_distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _horizontal_distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1DollySlideAnimConfigChangedCallback) {
                                decoder->UnknownFeature1DollySlideAnimConfigChangedCallback (_speed_is_default, _speed, _angle_is_default, _angle, _horizontal_distance_is_default, _horizontal_distance, decoder->UnknownFeature1DollySlideAnimConfigChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimConfigChangedCb (_speed_is_default, _speed, _angle_is_default, _angle, _horizontal_distance_is_default, _horizontal_distance, ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimConfigChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_DOLLY_SLIDE_ANIM_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_FRAMING_POSITION_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1UserFramingPositionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionChangedCb))
                    {
                        int8_t _horizontal;
                        int8_t _vertical;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _horizontal =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1UserFramingPositionChangedCallback) {
                                decoder->UnknownFeature1UserFramingPositionChangedCallback (_horizontal, _vertical, decoder->UnknownFeature1UserFramingPositionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionChangedCb (_horizontal, _vertical, ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_USER_FRAMING_POSITION_CHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_UNKNOWN_FEATURE_1 */
        case ARCOMMANDS_ID_FEATURE_WIFI:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_WIFI_CMD_SCAN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiScanCallback) || (!decoder && ARCOMMANDS_Decoder_WifiScanCb))
                    {
                        uint8_t _band;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiScanCallback) {
                                decoder->WifiScanCallback (_band, decoder->WifiScanCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiScanCb (_band, ARCOMMANDS_Decoder_WifiScanCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_SCAN */
                case ARCOMMANDS_ID_WIFI_CMD_UPDATE_AUTHORIZED_CHANNELS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiUpdateAuthorizedChannelsCallback) || (!decoder && ARCOMMANDS_Decoder_WifiUpdateAuthorizedChannelsCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiUpdateAuthorizedChannelsCallback) {
                                decoder->WifiUpdateAuthorizedChannelsCallback (decoder->WifiUpdateAuthorizedChannelsCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiUpdateAuthorizedChannelsCb (ARCOMMANDS_Decoder_WifiUpdateAuthorizedChannelsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_UPDATE_AUTHORIZED_CHANNELS */
                case ARCOMMANDS_ID_WIFI_CMD_SET_AP_CHANNEL:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiSetApChannelCallback) || (!decoder && ARCOMMANDS_Decoder_WifiSetApChannelCb))
                    {
                        eARCOMMANDS_WIFI_SELECTION_TYPE _type;
                        eARCOMMANDS_WIFI_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_WIFI_SELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiSetApChannelCallback) {
                                decoder->WifiSetApChannelCallback (_type, _band, _channel, decoder->WifiSetApChannelCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiSetApChannelCb (_type, _band, _channel, ARCOMMANDS_Decoder_WifiSetApChannelCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_SET_AP_CHANNEL */
                case ARCOMMANDS_ID_WIFI_CMD_SET_SECURITY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiSetSecurityCallback) || (!decoder && ARCOMMANDS_Decoder_WifiSetSecurityCb))
                    {
                        eARCOMMANDS_WIFI_SECURITY_TYPE _type;
                        char * _key = NULL;
                        eARCOMMANDS_WIFI_SECURITY_KEY_TYPE _key_type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_WIFI_SECURITY_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _key = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _key_type = (eARCOMMANDS_WIFI_SECURITY_KEY_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiSetSecurityCallback) {
                                decoder->WifiSetSecurityCallback (_type, _key, _key_type, decoder->WifiSetSecurityCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiSetSecurityCb (_type, _key, _key_type, ARCOMMANDS_Decoder_WifiSetSecurityCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_SET_SECURITY */
                case ARCOMMANDS_ID_WIFI_CMD_SET_COUNTRY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiSetCountryCallback) || (!decoder && ARCOMMANDS_Decoder_WifiSetCountryCb))
                    {
                        eARCOMMANDS_WIFI_COUNTRY_SELECTION _selection_mode;
                        char * _code = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _selection_mode = (eARCOMMANDS_WIFI_COUNTRY_SELECTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _code = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiSetCountryCallback) {
                                decoder->WifiSetCountryCallback (_selection_mode, _code, decoder->WifiSetCountryCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiSetCountryCb (_selection_mode, _code, ARCOMMANDS_Decoder_WifiSetCountryCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_SET_COUNTRY */
                case ARCOMMANDS_ID_WIFI_CMD_SET_ENVIRONMENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiSetEnvironmentCallback) || (!decoder && ARCOMMANDS_Decoder_WifiSetEnvironmentCb))
                    {
                        eARCOMMANDS_WIFI_ENVIRONMENT _environment;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _environment = (eARCOMMANDS_WIFI_ENVIRONMENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiSetEnvironmentCallback) {
                                decoder->WifiSetEnvironmentCallback (_environment, decoder->WifiSetEnvironmentCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiSetEnvironmentCb (_environment, ARCOMMANDS_Decoder_WifiSetEnvironmentCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_SET_ENVIRONMENT */
                case ARCOMMANDS_ID_WIFI_CMD_SCANNED_ITEM:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiScannedItemCallback) || (!decoder && ARCOMMANDS_Decoder_WifiScannedItemCb))
                    {
                        char * _ssid = NULL;
                        int16_t _rssi;
                        eARCOMMANDS_WIFI_BAND _band;
                        uint8_t _channel;
                        uint8_t _list_flags;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rssi =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _list_flags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiScannedItemCallback) {
                                decoder->WifiScannedItemCallback (_ssid, _rssi, _band, _channel, _list_flags, decoder->WifiScannedItemCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiScannedItemCb (_ssid, _rssi, _band, _channel, _list_flags, ARCOMMANDS_Decoder_WifiScannedItemCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_SCANNED_ITEM */
                case ARCOMMANDS_ID_WIFI_CMD_AUTHORIZED_CHANNEL:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiAuthorizedChannelCallback) || (!decoder && ARCOMMANDS_Decoder_WifiAuthorizedChannelCb))
                    {
                        eARCOMMANDS_WIFI_BAND _band;
                        uint8_t _channel;
                        uint8_t _environment;
                        uint8_t _list_flags;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _environment = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _list_flags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiAuthorizedChannelCallback) {
                                decoder->WifiAuthorizedChannelCallback (_band, _channel, _environment, _list_flags, decoder->WifiAuthorizedChannelCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiAuthorizedChannelCb (_band, _channel, _environment, _list_flags, ARCOMMANDS_Decoder_WifiAuthorizedChannelCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_AUTHORIZED_CHANNEL */
                case ARCOMMANDS_ID_WIFI_CMD_AP_CHANNEL_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiApChannelChangedCallback) || (!decoder && ARCOMMANDS_Decoder_WifiApChannelChangedCb))
                    {
                        eARCOMMANDS_WIFI_SELECTION_TYPE _type;
                        eARCOMMANDS_WIFI_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_WIFI_SELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiApChannelChangedCallback) {
                                decoder->WifiApChannelChangedCallback (_type, _band, _channel, decoder->WifiApChannelChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiApChannelChangedCb (_type, _band, _channel, ARCOMMANDS_Decoder_WifiApChannelChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_AP_CHANNEL_CHANGED */
                case ARCOMMANDS_ID_WIFI_CMD_SECURITY_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiSecurityChangedCallback) || (!decoder && ARCOMMANDS_Decoder_WifiSecurityChangedCb))
                    {
                        char * _key = NULL;
                        eARCOMMANDS_WIFI_SECURITY_TYPE _key_type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _key = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _key_type = (eARCOMMANDS_WIFI_SECURITY_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiSecurityChangedCallback) {
                                decoder->WifiSecurityChangedCallback (_key, _key_type, decoder->WifiSecurityChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiSecurityChangedCb (_key, _key_type, ARCOMMANDS_Decoder_WifiSecurityChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_SECURITY_CHANGED */
                case ARCOMMANDS_ID_WIFI_CMD_COUNTRY_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiCountryChangedCallback) || (!decoder && ARCOMMANDS_Decoder_WifiCountryChangedCb))
                    {
                        eARCOMMANDS_WIFI_COUNTRY_SELECTION _selection_mode;
                        char * _code = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _selection_mode = (eARCOMMANDS_WIFI_COUNTRY_SELECTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _code = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiCountryChangedCallback) {
                                decoder->WifiCountryChangedCallback (_selection_mode, _code, decoder->WifiCountryChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiCountryChangedCb (_selection_mode, _code, ARCOMMANDS_Decoder_WifiCountryChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_COUNTRY_CHANGED */
                case ARCOMMANDS_ID_WIFI_CMD_ENVIRONMENT_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiEnvironmentChangedCallback) || (!decoder && ARCOMMANDS_Decoder_WifiEnvironmentChangedCb))
                    {
                        eARCOMMANDS_WIFI_ENVIRONMENT _environment;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _environment = (eARCOMMANDS_WIFI_ENVIRONMENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiEnvironmentChangedCallback) {
                                decoder->WifiEnvironmentChangedCallback (_environment, decoder->WifiEnvironmentChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiEnvironmentChangedCb (_environment, ARCOMMANDS_Decoder_WifiEnvironmentChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_ENVIRONMENT_CHANGED */
                case ARCOMMANDS_ID_WIFI_CMD_RSSI_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiRssiChangedCallback) || (!decoder && ARCOMMANDS_Decoder_WifiRssiChangedCb))
                    {
                        int16_t _rssi;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rssi =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiRssiChangedCallback) {
                                decoder->WifiRssiChangedCallback (_rssi, decoder->WifiRssiChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiRssiChangedCb (_rssi, ARCOMMANDS_Decoder_WifiRssiChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_RSSI_CHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_WIFI */
        default:
            retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
            break;
        }
    } // No else --> Processing block
    return retVal;
}

eARCOMMANDS_DECODER_ERROR
ARCOMMANDS_Decoder_DescribeBuffer (uint8_t *buffer, int32_t buffLen, char *resString, int32_t stringLen)
{
    eARCOMMANDS_ID_FEATURE commandFetaure = -1;
    int commandClass = -1;
    int commandId = -1;
    int32_t offset = 0;
    int32_t error = 0;
    int strOffset = 0;
    eARCOMMANDS_DECODER_ERROR retVal = ARCOMMANDS_DECODER_OK;
    if ((NULL == buffer) || (NULL == resString))
    {
        retVal = ARCOMMANDS_DECODER_ERROR;
    } // No else --> Arg check

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        if (ARCOMMANDS_Decoder_Init () == 0)
        {
            retVal = ARCOMMANDS_DECODER_ERROR;
        } // No else --> keep retVal to OK if init went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        commandFetaure = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
        if (error == 1)
        {
            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
        } // No else --> Do not modify retVal if read went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        commandClass = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
        if (error == 1)
        {
            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
        } // No else --> Do not modify retVal if read went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        commandId = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
        if (error == 1)
        {
            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
        } // No else --> Do not modify retVal if read went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK && stringLen > 0)
    {
        resString[0] = '\0';
    }
    else
    {
        retVal = ARCOMMANDS_DECODER_ERROR;
    }

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        switch (commandFetaure)
        {
        case ARCOMMANDS_ID_FEATURE_GENERIC:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_GENERIC_CMD_DEFAULT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("generic.default:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_GENERIC_CMD_DEFAULT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("generic.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("generic.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_GENERIC */
        case ARCOMMANDS_ID_FEATURE_ARDRONE3:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_FLATTRIM:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.FlatTrim:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_FLATTRIM */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_TAKEOFF:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.TakeOff:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_TAKEOFF */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_PCMD:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.PCMD:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | flag -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | roll -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | pitch -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | yaw -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | gaz -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | timestampAndSeqNum -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_PCMD */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_LANDING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.Landing:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_LANDING */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_EMERGENCY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.Emergency:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_EMERGENCY */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_NAVIGATEHOME:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.NavigateHome:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | start -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_NAVIGATEHOME */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_AUTOTAKEOFFMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.AutoTakeOffMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_AUTOTAKEOFFMODE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_MOVEBY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.moveBy:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | dX -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | dY -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | dZ -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | dPsi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_MOVEBY */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_USERTAKEOFF:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.UserTakeOff:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_USERTAKEOFF */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_CIRCLE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.Circle:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTING_CIRCLE_DIRECTION arg = (eARCOMMANDS_ARDRONE3_PILOTING_CIRCLE_DIRECTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTING_CIRCLE_DIRECTION)ARCOMMANDS_ReadWrite_PrintI32 (" | direction -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_CIRCLE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTING */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_ANIMATIONS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_ANIMATIONS_CMD_FLIP:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Animations.Flip:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_ANIMATIONS_FLIP_DIRECTION arg = (eARCOMMANDS_ARDRONE3_ANIMATIONS_FLIP_DIRECTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_ANIMATIONS_FLIP_DIRECTION)ARCOMMANDS_ReadWrite_PrintI32 (" | direction -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANIMATIONS_CMD_FLIP */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Animations.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_ANIMATIONS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERA:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_CAMERA_CMD_ORIENTATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Camera.Orientation:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | tilt -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | pan -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_CAMERA_CMD_ORIENTATION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Camera.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERA */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORD:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTURE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecord.Picture:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTURE */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEO:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecord.Video:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEO_RECORD arg = (eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEO_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEO_RECORD)ARCOMMANDS_ReadWrite_PrintI32 (" | record -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEO */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTUREV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecord.PictureV2:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTUREV2 */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEOV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecord.VideoV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEOV2_RECORD arg = (eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEOV2_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEOV2_RECORD)ARCOMMANDS_ReadWrite_PrintI32 (" | record -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEOV2 */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecord.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORD */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordState.PictureStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordState.VideoStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordState.PictureStateChangedV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2 */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordState.VideoStateChangedV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2 */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEORESOLUTIONSTATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordState.VideoResolutionState:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_STREAMING arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_STREAMING)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_STREAMING)ARCOMMANDS_ReadWrite_PrintI32 (" | streaming -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_RECORDING arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_RECORDING)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_RECORDING)ARCOMMANDS_ReadWrite_PrintI32 (" | recording -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEORESOLUTIONSTATE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordEvent.PictureEventChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_PrintI32 (" | event -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordEvent.VideoEventChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_PrintI32 (" | event -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordEvent.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDEVENT */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLATTRIMCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.FlatTrimChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLATTRIMCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLYINGSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.FlyingStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE arg = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLYINGSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALERTSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.AlertStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE arg = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALERTSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_NAVIGATEHOMESTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.NavigateHomeStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE arg = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON arg = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON)ARCOMMANDS_ReadWrite_PrintI32 (" | reason -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_NAVIGATEHOMESTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_POSITIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.PositionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_POSITIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_SPEEDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.SpeedChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speedX -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speedY -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speedZ -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_SPEEDCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ATTITUDECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.AttitudeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | roll -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | pitch -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | yaw -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ATTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_AUTOTAKEOFFMODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.AutoTakeOffModeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_AUTOTAKEOFFMODECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALTITUDECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.AltitudeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_GPSLOCATIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.GpsLocationChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | latitude_accuracy -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | longitude_accuracy -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | altitude_accuracy -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_GPSLOCATIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_LANDINGSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.LandingStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_LANDINGSTATECHANGED_STATE arg = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_LANDINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_LANDINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_LANDINGSTATECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGEVENT_CMD_MOVEBYEND:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingEvent.moveByEnd:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | dX -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | dY -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | dZ -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | dPsi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGEVENT_MOVEBYEND_ERROR arg = (eARCOMMANDS_ARDRONE3_PILOTINGEVENT_MOVEBYEND_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGEVENT_MOVEBYEND_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGEVENT_CMD_MOVEBYEND */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingEvent.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGEVENT */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFISCAN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Network.WifiScan:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORK_WIFISCAN_BAND arg = (eARCOMMANDS_ARDRONE3_NETWORK_WIFISCAN_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORK_WIFISCAN_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFISCAN */
                case ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFIAUTHCHANNEL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Network.WifiAuthChannel:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFIAUTHCHANNEL */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Network.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORK */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFISCANLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkState.WifiScanListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | ssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int16_t arg =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI16 (" | rssi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND arg = (eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFISCANLISTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFISCANCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkState.AllWifiScanChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFISCANCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkState.WifiAuthChannelListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND arg = (eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | in_or_out -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkState.AllWifiAuthChannelChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXALTITUDE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.MaxAltitude:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXALTITUDE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXTILT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.MaxTilt:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXTILT */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_ABSOLUTCONTROL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.AbsolutControl:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | on -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_ABSOLUTCONTROL */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXDISTANCE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.MaxDistance:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXDISTANCE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_NOFLYOVERMAXDISTANCE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.NoFlyOverMaxDistance:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | shouldNotFlyOver -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_NOFLYOVERMAXDISTANCE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXHORIZONTALSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.setAutonomousFlightMaxHorizontalSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXHORIZONTALSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXVERTICALSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.setAutonomousFlightMaxVerticalSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXVERTICALSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXHORIZONTALACCELERATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.setAutonomousFlightMaxHorizontalAcceleration:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXHORIZONTALACCELERATION */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXVERTICALACCELERATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.setAutonomousFlightMaxVerticalAcceleration:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXVERTICALACCELERATION */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXROTATIONSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.setAutonomousFlightMaxRotationSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXROTATIONSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_BANKEDTURN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.BankedTurn:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_BANKEDTURN */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MINALTITUDE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.MinAltitude:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MINALTITUDE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGDIRECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.CirclingDirection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_CIRCLINGDIRECTION_VALUE arg = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_CIRCLINGDIRECTION_VALUE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_CIRCLINGDIRECTION_VALUE)ARCOMMANDS_ReadWrite_PrintI32 (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGDIRECTION */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGRADIUS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.CirclingRadius:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGRADIUS */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGALTITUDE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.CirclingAltitude:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGALTITUDE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_PITCHMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.PitchMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_PITCHMODE_VALUE arg = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_PITCHMODE_VALUE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_PITCHMODE_VALUE)ARCOMMANDS_ReadWrite_PrintI32 (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_PITCHMODE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXALTITUDECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.MaxAltitudeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXALTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXTILTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.MaxTiltChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXTILTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_ABSOLUTCONTROLCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.AbsolutControlChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | on -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_ABSOLUTCONTROLCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXDISTANCECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.MaxDistanceChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXDISTANCECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_NOFLYOVERMAXDISTANCECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.NoFlyOverMaxDistanceChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | shouldNotFlyOver -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_NOFLYOVERMAXDISTANCECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXHORIZONTALSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.AutonomousFlightMaxHorizontalSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXHORIZONTALSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXVERTICALSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.AutonomousFlightMaxVerticalSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXVERTICALSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXHORIZONTALACCELERATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.AutonomousFlightMaxHorizontalAcceleration:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXHORIZONTALACCELERATION */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXVERTICALACCELERATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.AutonomousFlightMaxVerticalAcceleration:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXVERTICALACCELERATION */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXROTATIONSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.AutonomousFlightMaxRotationSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXROTATIONSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_BANKEDTURNCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.BankedTurnChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_BANKEDTURNCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MINALTITUDECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.MinAltitudeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MINALTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGDIRECTIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.CirclingDirectionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED_VALUE arg = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED_VALUE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED_VALUE)ARCOMMANDS_ReadWrite_PrintI32 (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGDIRECTIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGRADIUSCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.CirclingRadiusChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGRADIUSCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGALTITUDECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.CirclingAltitudeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGALTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_PITCHMODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.PitchModeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED_VALUE arg = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED_VALUE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED_VALUE)ARCOMMANDS_ReadWrite_PrintI32 (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_PITCHMODECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXVERTICALSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettings.MaxVerticalSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXVERTICALSPEED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXROTATIONSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettings.MaxRotationSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXROTATIONSPEED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_HULLPROTECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettings.HullProtection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | present -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_HULLPROTECTION */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_OUTDOOR:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettings.Outdoor:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | outdoor -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_OUTDOOR */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXPITCHROLLROTATIONSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettings.MaxPitchRollRotationSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXPITCHROLLROTATIONSPEED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXVERTICALSPEEDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettingsState.MaxVerticalSpeedChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXVERTICALSPEEDCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXROTATIONSPEEDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettingsState.MaxRotationSpeedChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXROTATIONSPEEDCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_HULLPROTECTIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettingsState.HullProtectionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | present -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_HULLPROTECTIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_OUTDOORCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettingsState.OutdoorChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | outdoor -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_OUTDOORCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXPITCHROLLROTATIONSPEEDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettingsState.MaxPitchRollRotationSpeedChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXPITCHROLLROTATIONSPEEDCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGS_CMD_WIFISELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkSettings.WifiSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_TYPE arg = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_BAND arg = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGS_CMD_WIFISELECTION */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGS_CMD_WIFISECURITY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkSettings.wifiSecurity:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_TYPE arg = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | key -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_KEYTYPE arg = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_KEYTYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_KEYTYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | keyType -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGS_CMD_WIFISECURITY */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkSettingsState.WifiSelectionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE arg = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND arg = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISECURITYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkSettingsState.wifiSecurityChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITYCHANGED_TYPE arg = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITYCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITYCHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISECURITYCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISECURITY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkSettingsState.wifiSecurity:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_TYPE arg = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | key -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_KEYTYPE arg = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_KEYTYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_KEYTYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | keyType -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISECURITY */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTMOTORVERSIONLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.ProductMotorVersionListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | motor_number -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | software -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | hardware -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTMOTORVERSIONLISTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTGPSVERSIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.ProductGPSVersionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | software -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | hardware -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTGPSVERSIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.MotorErrorStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | motorIds -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR arg = (eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | motorError -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORSOFTWAREVERSIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.MotorSoftwareVersionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | version -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORSOFTWAREVERSIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORFLIGHTSSTATUSCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.MotorFlightsStatusChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbFlights -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | lastFlightDuration -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | totalFlightDuration -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORFLIGHTSSTATUSCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORLASTERRORCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.MotorErrorLastErrorChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR arg = (eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | motorError -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORLASTERRORCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_P7ID:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.P7ID:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | serialID -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_P7ID */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_CPUID:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.CPUID:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_CPUID */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_PICTUREFORMATSELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.PictureFormatSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_PICTUREFORMATSELECTION_TYPE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_PICTUREFORMATSELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_PICTUREFORMATSELECTION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_PICTUREFORMATSELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_AUTOWHITEBALANCESELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.AutoWhiteBalanceSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_AUTOWHITEBALANCESELECTION_TYPE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_AUTOWHITEBALANCESELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_AUTOWHITEBALANCESELECTION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_AUTOWHITEBALANCESELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_EXPOSITIONSELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.ExpositionSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_EXPOSITIONSELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_SATURATIONSELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.SaturationSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_SATURATIONSELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_TIMELAPSESELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.TimelapseSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | interval -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_TIMELAPSESELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOAUTORECORDSELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.VideoAutorecordSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOAUTORECORDSELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOSTABILIZATIONMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.VideoStabilizationMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOSTABILIZATIONMODE_MODE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOSTABILIZATIONMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOSTABILIZATIONMODE_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOSTABILIZATIONMODE */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEORECORDINGMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.VideoRecordingMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORECORDINGMODE_MODE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORECORDINGMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORECORDINGMODE_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEORECORDINGMODE */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOFRAMERATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.VideoFramerate:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOFRAMERATE_FRAMERATE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOFRAMERATE_FRAMERATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOFRAMERATE_FRAMERATE)ARCOMMANDS_ReadWrite_PrintI32 (" | framerate -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOFRAMERATE */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEORESOLUTIONS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.VideoResolutions:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORESOLUTIONS_TYPE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORESOLUTIONS_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORESOLUTIONS_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEORESOLUTIONS */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_PICTUREFORMATCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.PictureFormatChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_PICTUREFORMATCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_AUTOWHITEBALANCECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.AutoWhiteBalanceChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_AUTOWHITEBALANCECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_EXPOSITIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.ExpositionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_EXPOSITIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_SATURATIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.SaturationChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_SATURATIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_TIMELAPSECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.TimelapseChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | interval -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | minInterval -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | maxInterval -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_TIMELAPSECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOAUTORECORDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.VideoAutorecordChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOAUTORECORDCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOSTABILIZATIONMODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.VideoStabilizationModeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED_MODE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOSTABILIZATIONMODECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEORECORDINGMODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.VideoRecordingModeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORECORDINGMODECHANGED_MODE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORECORDINGMODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORECORDINGMODECHANGED_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEORECORDINGMODECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOFRAMERATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.VideoFramerateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOFRAMERATECHANGED_FRAMERATE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOFRAMERATECHANGED_FRAMERATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOFRAMERATECHANGED_FRAMERATE)ARCOMMANDS_ReadWrite_PrintI32 (" | framerate -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOFRAMERATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEORESOLUTIONSCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.VideoResolutionsChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORESOLUTIONSCHANGED_TYPE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORESOLUTIONSCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORESOLUTIONSCHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEORESOLUTIONSCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMING_CMD_VIDEOENABLE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaStreaming.VideoEnable:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enable -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMING_CMD_VIDEOENABLE */
                case ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMING_CMD_VIDEOSTREAMMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaStreaming.VideoStreamMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIASTREAMING_VIDEOSTREAMMODE_MODE arg = (eARCOMMANDS_ARDRONE3_MEDIASTREAMING_VIDEOSTREAMMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIASTREAMING_VIDEOSTREAMMODE_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMING_CMD_VIDEOSTREAMMODE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaStreaming.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMING */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaStreamingState.VideoEnableChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED arg = (eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED)ARCOMMANDS_ReadWrite_PrintI32 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMINGSTATE_CMD_VIDEOSTREAMMODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaStreamingState.VideoStreamModeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOSTREAMMODECHANGED_MODE arg = (eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOSTREAMMODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOSTREAMMODECHANGED_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMINGSTATE_CMD_VIDEOSTREAMMODECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaStreamingState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMINGSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SETHOME:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettings.SetHome:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SETHOME */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RESETHOME:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettings.ResetHome:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RESETHOME */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SENDCONTROLLERGPS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettings.SendControllerGPS:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | horizontalAccuracy -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | verticalAccuracy -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SENDCONTROLLERGPS */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_HOMETYPE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettings.HomeType:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_GPSSETTINGS_HOMETYPE_TYPE arg = (eARCOMMANDS_ARDRONE3_GPSSETTINGS_HOMETYPE_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_GPSSETTINGS_HOMETYPE_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_HOMETYPE */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RETURNHOMEDELAY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettings.ReturnHomeDelay:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | delay -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RETURNHOMEDELAY */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettingsState.HomeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RESETHOMECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettingsState.ResetHomeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RESETHOMECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSFIXSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettingsState.GPSFixStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | fixed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSFIXSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSUPDATESTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettingsState.GPSUpdateStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE arg = (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSUPDATESTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMETYPECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettingsState.HomeTypeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE arg = (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMETYPECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RETURNHOMEDELAYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettingsState.ReturnHomeDelayChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | delay -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RETURNHOMEDELAYCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERASTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_CAMERASTATE_CMD_ORIENTATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.CameraState.Orientation:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | tilt -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | pan -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_CAMERASTATE_CMD_ORIENTATION */
                case ARCOMMANDS_ID_ARDRONE3_CAMERASTATE_CMD_DEFAULTCAMERAORIENTATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.CameraState.defaultCameraOrientation:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | tilt -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | pan -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_CAMERASTATE_CMD_DEFAULTCAMERAORIENTATION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.CameraState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERASTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_ELECTRICFREQUENCY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Antiflickering.electricFrequency:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERING_ELECTRICFREQUENCY_FREQUENCY arg = (eARCOMMANDS_ARDRONE3_ANTIFLICKERING_ELECTRICFREQUENCY_FREQUENCY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_ANTIFLICKERING_ELECTRICFREQUENCY_FREQUENCY)ARCOMMANDS_ReadWrite_PrintI32 (" | frequency -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_ELECTRICFREQUENCY */
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_SETMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Antiflickering.setMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERING_SETMODE_MODE arg = (eARCOMMANDS_ARDRONE3_ANTIFLICKERING_SETMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_ANTIFLICKERING_SETMODE_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_SETMODE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Antiflickering.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERING */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_ELECTRICFREQUENCYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.AntiflickeringState.electricFrequencyChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY arg = (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY)ARCOMMANDS_ReadWrite_PrintI32 (" | frequency -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_ELECTRICFREQUENCYCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_MODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.AntiflickeringState.modeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE arg = (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_MODECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.AntiflickeringState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERINGSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_NUMBEROFSATELLITECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSState.NumberOfSatelliteChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | numberOfSatellite -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_NUMBEROFSATELLITECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPEAVAILABILITYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSState.HomeTypeAvailabilityChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE arg = (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | available -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPEAVAILABILITYCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPECHOSENCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSState.HomeTypeChosenChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE arg = (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPECHOSENCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PROSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PROSTATE_CMD_FEATURES:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PROState.Features:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint64_t arg = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU64 (" | features -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PROSTATE_CMD_FEATURES */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PROState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PROSTATE */
            default:
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_ARDRONE3 */
        case ARCOMMANDS_ID_FEATURE_COMMON:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_COMMON_CLASS_NETWORK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_NETWORK_CMD_DISCONNECT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Network.Disconnect:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_NETWORK_CMD_DISCONNECT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Network.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_NETWORK */
            case ARCOMMANDS_ID_COMMON_CLASS_NETWORKEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_NETWORKEVENT_CMD_DISCONNECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.NetworkEvent.Disconnection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE arg = (eARCOMMANDS_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE)ARCOMMANDS_ReadWrite_PrintI32 (" | cause -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_NETWORKEVENT_CMD_DISCONNECTION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.NetworkEvent.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_NETWORKEVENT */
            case ARCOMMANDS_ID_COMMON_CLASS_SETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_ALLSETTINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Settings.AllSettings:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_ALLSETTINGS */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_RESET:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Settings.Reset:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_RESET */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_PRODUCTNAME:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Settings.ProductName:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_PRODUCTNAME */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_COUNTRY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Settings.Country:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | code -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_COUNTRY */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_AUTOCOUNTRY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Settings.AutoCountry:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | automatic -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_AUTOCOUNTRY */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Settings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_SETTINGS */
            case ARCOMMANDS_ID_COMMON_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_ALLSETTINGSCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.AllSettingsChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_ALLSETTINGSCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_RESETCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.ResetChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_RESETCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTNAMECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.ProductNameChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTNAMECHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTVERSIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.ProductVersionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | software -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | hardware -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTVERSIONCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALHIGHCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.ProductSerialHighChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | high -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALHIGHCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALLOWCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.ProductSerialLowChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | low -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALLOWCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_COUNTRYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.CountryChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | code -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_COUNTRYCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_AUTOCOUNTRYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.AutoCountryChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | automatic -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_AUTOCOUNTRYCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_COMMON:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_ALLSTATES:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Common.AllStates:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_ALLSTATES */
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTDATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Common.CurrentDate:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | date -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTDATE */
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTTIME:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Common.CurrentTime:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | time -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTTIME */
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_REBOOT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Common.Reboot:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_REBOOT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Common.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_COMMON */
            case ARCOMMANDS_ID_COMMON_CLASS_COMMONSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_ALLSTATESCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.AllStatesChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_ALLSTATESCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_BATTERYSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.BatteryStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | percent -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_BATTERYSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGESTATELISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.MassStorageStateListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGESTATELISTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOSTATELISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.MassStorageInfoStateListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | size -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | used_size -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | plugged -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | full -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | internal -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOSTATELISTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTDATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.CurrentDateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | date -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTDATECHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTTIMECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.CurrentTimeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | time -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTTIMECHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOREMAININGLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.MassStorageInfoRemainingListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | free_space -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | rec_time -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | photo_remaining -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOREMAININGLISTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_WIFISIGNALCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.WifiSignalChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int16_t arg =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI16 (" | rssi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_WIFISIGNALCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_SENSORSSTATESLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.SensorsStatesListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME arg = (eARCOMMANDS_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME)ARCOMMANDS_ReadWrite_PrintI32 (" | sensorName -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | sensorState -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_SENSORSSTATESLISTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_PRODUCTMODEL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.ProductModel:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_COMMONSTATE_PRODUCTMODEL_MODEL arg = (eARCOMMANDS_COMMON_COMMONSTATE_PRODUCTMODEL_MODEL)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_COMMONSTATE_PRODUCTMODEL_MODEL)ARCOMMANDS_ReadWrite_PrintI32 (" | model -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_PRODUCTMODEL */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_COUNTRYLISTKNOWN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.CountryListKnown:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | listFlags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | countryCodes -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_COUNTRYLISTKNOWN */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_DEPRECATEDMASSSTORAGECONTENTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.DeprecatedMassStorageContentChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbPhotos -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbVideos -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbPuds -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbCrashLogs -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_DEPRECATEDMASSSTORAGECONTENTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGECONTENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.MassStorageContent:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbPhotos -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbVideos -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbPuds -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbCrashLogs -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbRawPhotos -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGECONTENT */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGECONTENTFORCURRENTRUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.MassStorageContentForCurrentRun:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbPhotos -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbVideos -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbRawPhotos -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGECONTENTFORCURRENTRUN */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_COMMONSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_OVERHEAT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_SWITCHOFF:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.OverHeat.SwitchOff:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_SWITCHOFF */
                case ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_VENTILATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.OverHeat.Ventilate:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_VENTILATE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.OverHeat.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_OVERHEAT */
            case ARCOMMANDS_ID_COMMON_CLASS_OVERHEATSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.OverHeatState.OverHeatChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATCHANGED */
                case ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATREGULATIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.OverHeatState.OverHeatRegulationChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | regulationType -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATREGULATIONCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.OverHeatState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_OVERHEATSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_CONTROLLER:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CONTROLLER_CMD_ISPILOTING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Controller.isPiloting:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | piloting -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CONTROLLER_CMD_ISPILOTING */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Controller.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CONTROLLER */
            case ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_WIFISETTINGS_CMD_OUTDOORSETTING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.WifiSettings.OutdoorSetting:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | outdoor -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_WIFISETTINGS_CMD_OUTDOORSETTING */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.WifiSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGS */
            case ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_WIFISETTINGSSTATE_CMD_OUTDOORSETTINGSCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.WifiSettingsState.outdoorSettingsChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | outdoor -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_WIFISETTINGSSTATE_CMD_OUTDOORSETTINGSCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.WifiSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_MAVLINK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_MAVLINK_CMD_START:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Mavlink.Start:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | filepath -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_MAVLINK_START_TYPE arg = (eARCOMMANDS_COMMON_MAVLINK_START_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_MAVLINK_START_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINK_CMD_START */
                case ARCOMMANDS_ID_COMMON_MAVLINK_CMD_PAUSE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Mavlink.Pause:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINK_CMD_PAUSE */
                case ARCOMMANDS_ID_COMMON_MAVLINK_CMD_STOP:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Mavlink.Stop:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINK_CMD_STOP */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Mavlink.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_MAVLINK */
            case ARCOMMANDS_ID_COMMON_CLASS_MAVLINKSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKFILEPLAYINGSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.MavlinkState.MavlinkFilePlayingStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE arg = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | filepath -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE arg = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKFILEPLAYINGSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKPLAYERRORSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.MavlinkState.MavlinkPlayErrorStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR arg = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKPLAYERRORSTATECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.MavlinkState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_MAVLINKSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_CALIBRATION:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CALIBRATION_CMD_MAGNETOCALIBRATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Calibration.MagnetoCalibration:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | calibrate -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATION_CMD_MAGNETOCALIBRATION */
                case ARCOMMANDS_ID_COMMON_CALIBRATION_CMD_PITOTCALIBRATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Calibration.PitotCalibration:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | calibrate -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATION_CMD_PITOTCALIBRATION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Calibration.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CALIBRATION */
            case ARCOMMANDS_ID_COMMON_CLASS_CALIBRATIONSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CalibrationState.MagnetoCalibrationStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | xAxisCalibration -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | yAxisCalibration -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | zAxisCalibration -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | calibrationFailed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONREQUIREDSTATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CalibrationState.MagnetoCalibrationRequiredState:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | required -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONREQUIREDSTATE */
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CalibrationState.MagnetoCalibrationAxisToCalibrateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS arg = (eARCOMMANDS_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS)ARCOMMANDS_ReadWrite_PrintI32 (" | axis -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED */
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTARTEDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CalibrationState.MagnetoCalibrationStartedChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | started -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTARTEDCHANGED */
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_PITOTCALIBRATIONSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CalibrationState.PitotCalibrationStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_CALIBRATIONSTATE_PITOTCALIBRATIONSTATECHANGED_STATE arg = (eARCOMMANDS_COMMON_CALIBRATIONSTATE_PITOTCALIBRATIONSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_CALIBRATIONSTATE_PITOTCALIBRATIONSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | lastError -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_PITOTCALIBRATIONSTATECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CalibrationState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CALIBRATIONSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_CAMERASETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CAMERASETTINGSSTATE_CMD_CAMERASETTINGSCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CameraSettingsState.CameraSettingsChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | fov -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | panMax -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | panMin -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | tiltMax -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | tiltMin -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CAMERASETTINGSSTATE_CMD_CAMERASETTINGSCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CameraSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CAMERASETTINGSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_GPS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_GPS_CMD_CONTROLLERPOSITIONFORRUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.GPS.ControllerPositionForRun:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_GPS_CMD_CONTROLLERPOSITIONFORRUN */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.GPS.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_GPS */
            case ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_AVAILABILITYSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.FlightPlanState.AvailabilityStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | AvailabilityState -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_AVAILABILITYSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_COMPONENTSTATELISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.FlightPlanState.ComponentStateListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT arg = (eARCOMMANDS_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT)ARCOMMANDS_ReadWrite_PrintI32 (" | component -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | State -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_COMPONENTSTATELISTCHANGED */
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_LOCKSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.FlightPlanState.LockStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | LockState -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_LOCKSTATECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.FlightPlanState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_STARTINGERROREVENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.FlightPlanEvent.StartingErrorEvent:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_STARTINGERROREVENT */
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_SPEEDBRIDLEEVENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.FlightPlanEvent.SpeedBridleEvent:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_SPEEDBRIDLEEVENT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.FlightPlanEvent.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANEVENT */
            case ARCOMMANDS_ID_COMMON_CLASS_ARLIBSVERSIONSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_CONTROLLERLIBARCOMMANDSVERSION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ARLibsVersionsState.ControllerLibARCommandsVersion:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | version -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_CONTROLLERLIBARCOMMANDSVERSION */
                case ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_SKYCONTROLLERLIBARCOMMANDSVERSION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ARLibsVersionsState.SkyControllerLibARCommandsVersion:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | version -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_SKYCONTROLLERLIBARCOMMANDSVERSION */
                case ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_DEVICELIBARCOMMANDSVERSION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ARLibsVersionsState.DeviceLibARCommandsVersion:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | version -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_DEVICELIBARCOMMANDSVERSION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ARLibsVersionsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_ARLIBSVERSIONSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_AUDIO:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_AUDIO_CMD_CONTROLLERREADYFORSTREAMING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Audio.ControllerReadyForStreaming:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | ready -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_AUDIO_CMD_CONTROLLERREADYFORSTREAMING */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Audio.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_AUDIO */
            case ARCOMMANDS_ID_COMMON_CLASS_AUDIOSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_AUDIOSTATE_CMD_AUDIOSTREAMINGRUNNING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.AudioState.AudioStreamingRunning:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | running -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_AUDIOSTATE_CMD_AUDIOSTREAMINGRUNNING */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.AudioState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_AUDIOSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_HEADLIGHTS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_HEADLIGHTS_CMD_INTENSITY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Headlights.intensity:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | left -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | right -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_HEADLIGHTS_CMD_INTENSITY */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Headlights.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_HEADLIGHTS */
            case ARCOMMANDS_ID_COMMON_CLASS_HEADLIGHTSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_HEADLIGHTSSTATE_CMD_INTENSITYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.HeadlightsState.intensityChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | left -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | right -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_HEADLIGHTSSTATE_CMD_INTENSITYCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.HeadlightsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_HEADLIGHTSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_ANIMATIONS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STARTANIMATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Animations.StartAnimation:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_ANIMATIONS_STARTANIMATION_ANIM arg = (eARCOMMANDS_COMMON_ANIMATIONS_STARTANIMATION_ANIM)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_ANIMATIONS_STARTANIMATION_ANIM)ARCOMMANDS_ReadWrite_PrintI32 (" | anim -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STARTANIMATION */
                case ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STOPANIMATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Animations.StopAnimation:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_ANIMATIONS_STOPANIMATION_ANIM arg = (eARCOMMANDS_COMMON_ANIMATIONS_STOPANIMATION_ANIM)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_ANIMATIONS_STOPANIMATION_ANIM)ARCOMMANDS_ReadWrite_PrintI32 (" | anim -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STOPANIMATION */
                case ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STOPALLANIMATIONS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Animations.StopAllAnimations:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STOPALLANIMATIONS */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Animations.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_ANIMATIONS */
            case ARCOMMANDS_ID_COMMON_CLASS_ANIMATIONSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_ANIMATIONSSTATE_CMD_LIST:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.AnimationsState.List:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ANIM arg = (eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ANIM)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ANIM)ARCOMMANDS_ReadWrite_PrintI32 (" | anim -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_STATE arg = (eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ERROR arg = (eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ANIMATIONSSTATE_CMD_LIST */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.AnimationsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_ANIMATIONSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_ACCESSORY:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_ACCESSORY_CMD_CONFIG:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Accessory.Config:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_ACCESSORY_CONFIG_ACCESSORY arg = (eARCOMMANDS_COMMON_ACCESSORY_CONFIG_ACCESSORY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_ACCESSORY_CONFIG_ACCESSORY)ARCOMMANDS_ReadWrite_PrintI32 (" | accessory -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ACCESSORY_CMD_CONFIG */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Accessory.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_ACCESSORY */
            case ARCOMMANDS_ID_COMMON_CLASS_ACCESSORYSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_SUPPORTEDACCESSORIESLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.AccessoryState.SupportedAccessoriesListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_ACCESSORYSTATE_SUPPORTEDACCESSORIESLISTCHANGED_ACCESSORY arg = (eARCOMMANDS_COMMON_ACCESSORYSTATE_SUPPORTEDACCESSORIESLISTCHANGED_ACCESSORY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_ACCESSORYSTATE_SUPPORTEDACCESSORIESLISTCHANGED_ACCESSORY)ARCOMMANDS_ReadWrite_PrintI32 (" | accessory -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_SUPPORTEDACCESSORIESLISTCHANGED */
                case ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_ACCESSORYCONFIGCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.AccessoryState.AccessoryConfigChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_NEWACCESSORY arg = (eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_NEWACCESSORY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_NEWACCESSORY)ARCOMMANDS_ReadWrite_PrintI32 (" | newAccessory -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_ERROR arg = (eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_ACCESSORYCONFIGCHANGED */
                case ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_ACCESSORYCONFIGMODIFICATIONENABLED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.AccessoryState.AccessoryConfigModificationEnabled:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_ACCESSORYCONFIGMODIFICATIONENABLED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.AccessoryState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_ACCESSORYSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_CHARGER:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CHARGER_CMD_SETMAXCHARGERATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Charger.SetMaxChargeRate:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_CHARGER_SETMAXCHARGERATE_RATE arg = (eARCOMMANDS_COMMON_CHARGER_SETMAXCHARGERATE_RATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_CHARGER_SETMAXCHARGERATE_RATE)ARCOMMANDS_ReadWrite_PrintI32 (" | rate -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CHARGER_CMD_SETMAXCHARGERATE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Charger.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CHARGER */
            case ARCOMMANDS_ID_COMMON_CLASS_CHARGERSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_MAXCHARGERATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ChargerState.MaxChargeRateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_CHARGERSTATE_MAXCHARGERATECHANGED_RATE arg = (eARCOMMANDS_COMMON_CHARGERSTATE_MAXCHARGERATECHANGED_RATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_CHARGERSTATE_MAXCHARGERATECHANGED_RATE)ARCOMMANDS_ReadWrite_PrintI32 (" | rate -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_MAXCHARGERATECHANGED */
                case ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_CURRENTCHARGESTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ChargerState.CurrentChargeStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_STATUS arg = (eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_STATUS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_STATUS)ARCOMMANDS_ReadWrite_PrintI32 (" | status -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_PHASE arg = (eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_PHASE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_PHASE)ARCOMMANDS_ReadWrite_PrintI32 (" | phase -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_CURRENTCHARGESTATECHANGED */
                case ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_LASTCHARGERATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ChargerState.LastChargeRateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_CHARGERSTATE_LASTCHARGERATECHANGED_RATE arg = (eARCOMMANDS_COMMON_CHARGERSTATE_LASTCHARGERATECHANGED_RATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_CHARGERSTATE_LASTCHARGERATECHANGED_RATE)ARCOMMANDS_ReadWrite_PrintI32 (" | rate -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_LASTCHARGERATECHANGED */
                case ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_CHARGINGINFO:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ChargerState.ChargingInfo:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_PHASE arg = (eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_PHASE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_PHASE)ARCOMMANDS_ReadWrite_PrintI32 (" | phase -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_RATE arg = (eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_RATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_RATE)ARCOMMANDS_ReadWrite_PrintI32 (" | rate -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | intensity -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | fullChargingTime -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_CHARGINGINFO */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ChargerState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CHARGERSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_RUNSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_RUNSTATE_CMD_RUNIDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.RunState.RunIdChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | runId -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_RUNSTATE_CMD_RUNIDCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.RunState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_RUNSTATE */
            default:
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_COMMON */
        case ARCOMMANDS_ID_FEATURE_CONTROLLER_INFO:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_CONTROLLER_INFO_CMD_GPS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("controller_info.gps:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | horizontal_accuracy -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | vertical_accuracy -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | north_speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | east_speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | down_speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | timestamp -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_CONTROLLER_INFO_CMD_GPS */
                case ARCOMMANDS_ID_CONTROLLER_INFO_CMD_BAROMETER:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("controller_info.barometer:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | pressure -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | timestamp -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_CONTROLLER_INFO_CMD_BAROMETER */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("controller_info.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("controller_info.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_CONTROLLER_INFO */
        case ARCOMMANDS_ID_FEATURE_DEBUG:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_DEBUG_CMD_GET_ALL_SETTINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("debug.get_all_settings:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_DEBUG_CMD_GET_ALL_SETTINGS */
                case ARCOMMANDS_ID_DEBUG_CMD_SET_SETTING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("debug.set_setting:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_DEBUG_CMD_SET_SETTING */
                case ARCOMMANDS_ID_DEBUG_CMD_SETTINGS_INFO:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("debug.settings_info:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | listFlags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | label -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_DEBUG_SETTING_TYPE arg = (eARCOMMANDS_DEBUG_SETTING_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_DEBUG_SETTING_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_DEBUG_SETTING_MODE arg = (eARCOMMANDS_DEBUG_SETTING_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_DEBUG_SETTING_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | range_min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | range_max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | range_step -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_DEBUG_CMD_SETTINGS_INFO */
                case ARCOMMANDS_ID_DEBUG_CMD_SETTINGS_LIST:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("debug.settings_list:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_DEBUG_CMD_SETTINGS_LIST */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("debug.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("debug.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_DEBUG */
        case ARCOMMANDS_ID_FEATURE_DRONE_MANAGER:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_DISCOVER_DRONES:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("drone_manager.discover_drones:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_CMD_DISCOVER_DRONES */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_CONNECT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("drone_manager.connect:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | serial -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | key -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_CMD_CONNECT */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_FORGET:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("drone_manager.forget:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | serial -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_CMD_FORGET */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_DRONE_LIST_ITEM:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("drone_manager.drone_list_item:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | serial -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | model -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | connection_order -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | active -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | visible -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_DRONE_MANAGER_SECURITY arg = (eARCOMMANDS_DRONE_MANAGER_SECURITY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_DRONE_MANAGER_SECURITY)ARCOMMANDS_ReadWrite_PrintI32 (" | security -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | has_saved_key -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | rssi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | list_flags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_CMD_DRONE_LIST_ITEM */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_CONNECTION_STATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("drone_manager.connection_state:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_DRONE_MANAGER_CONNECTION_STATE arg = (eARCOMMANDS_DRONE_MANAGER_CONNECTION_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_DRONE_MANAGER_CONNECTION_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | serial -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | model -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_CMD_CONNECTION_STATE */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_AUTHENTICATION_FAILED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("drone_manager.authentication_failed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | serial -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | model -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_CMD_AUTHENTICATION_FAILED */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_CONNECTION_REFUSED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("drone_manager.connection_refused:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | serial -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | model -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_CMD_CONNECTION_REFUSED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("drone_manager.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("drone_manager.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_DRONE_MANAGER */
        case ARCOMMANDS_ID_FEATURE_JUMPINGSUMO:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_PILOTING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_PCMD:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Piloting.PCMD:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | flag -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | turn -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_PCMD */
                case ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_POSTURE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Piloting.Posture:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_PILOTING_POSTURE_TYPE arg = (eARCOMMANDS_JUMPINGSUMO_PILOTING_POSTURE_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_PILOTING_POSTURE_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_POSTURE */
                case ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_ADDCAPOFFSET:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Piloting.addCapOffset:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | offset -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_PILOTING_CMD_ADDCAPOFFSET */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Piloting.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_PILOTING */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_PILOTINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_PILOTINGSTATE_CMD_POSTURECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.PilotingState.PostureChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED_STATE arg = (eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_PILOTINGSTATE_CMD_POSTURECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_PILOTINGSTATE_CMD_ALERTSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.PilotingState.AlertStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED_STATE arg = (eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_PILOTINGSTATE_CMD_ALERTSTATECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_PILOTINGSTATE_CMD_SPEEDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.PilotingState.SpeedChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int16_t arg =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI16 (" | realSpeed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_PILOTINGSTATE_CMD_SPEEDCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.PilotingState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_PILOTINGSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ANIMATIONS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPSTOP:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Animations.JumpStop:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPSTOP */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPCANCEL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Animations.JumpCancel:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPCANCEL */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPLOAD:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Animations.JumpLoad:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMPLOAD */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMP:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Animations.Jump:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_JUMP_TYPE arg = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_JUMP_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_JUMP_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_JUMP */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_SIMPLEANIMATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Animations.SimpleAnimation:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_SIMPLEANIMATION_ID arg = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_SIMPLEANIMATION_ID)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_SIMPLEANIMATION_ID)ARCOMMANDS_ReadWrite_PrintI32 (" | id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONS_CMD_SIMPLEANIMATION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Animations.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ANIMATIONS */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ANIMATIONSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPLOADCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.AnimationsState.JumpLoadChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED_STATE arg = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPLOADCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPTYPECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.AnimationsState.JumpTypeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED_STATE arg = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPTYPECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPMOTORPROBLEMCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.AnimationsState.JumpMotorProblemChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED_ERROR arg = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ANIMATIONSSTATE_CMD_JUMPMOTORPROBLEMCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.AnimationsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ANIMATIONSSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_SETTINGSSTATE_CMD_PRODUCTGPSVERSIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.SettingsState.ProductGPSVersionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | software -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | hardware -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_SETTINGSSTATE_CMD_PRODUCTGPSVERSIONCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.SettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORD:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_PICTURE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecord.Picture:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_PICTURE */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_VIDEO:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecord.Video:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEO_RECORD arg = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEO_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEO_RECORD)ARCOMMANDS_ReadWrite_PrintI32 (" | record -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_VIDEO */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_PICTUREV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecord.PictureV2:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_PICTUREV2 */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_VIDEOV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecord.VideoV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEOV2_RECORD arg = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEOV2_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEOV2_RECORD)ARCOMMANDS_ReadWrite_PrintI32 (" | record -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORD_CMD_VIDEOV2 */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecord.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORD */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORDSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecordState.PictureStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecordState.VideoStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE arg = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecordState.PictureStateChangedV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE arg = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR arg = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2 */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecordState.VideoStateChangedV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE arg = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR arg = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2 */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecordState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORDSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORDEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecordEvent.PictureEventChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT arg = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_PrintI32 (" | event -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR arg = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecordEvent.VideoEventChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT arg = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_PrintI32 (" | event -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR arg = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaRecordEvent.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIARECORDEVENT */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSETTINGS_CMD_WIFISELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.NetworkSettings.WifiSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_TYPE arg = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_BAND arg = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSETTINGS_CMD_WIFISELECTION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.NetworkSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSETTINGS */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.NetworkSettingsState.WifiSelectionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE arg = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND arg = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.NetworkSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSETTINGSSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORK_CMD_WIFISCAN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Network.WifiScan:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_NETWORK_WIFISCAN_BAND arg = (eARCOMMANDS_JUMPINGSUMO_NETWORK_WIFISCAN_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_NETWORK_WIFISCAN_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORK_CMD_WIFISCAN */
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORK_CMD_WIFIAUTHCHANNEL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Network.WifiAuthChannel:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORK_CMD_WIFIAUTHCHANNEL */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.Network.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORK */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_WIFISCANLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.NetworkState.WifiScanListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | ssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int16_t arg =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI16 (" | rssi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_BAND arg = (eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_WIFISCANLISTCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_ALLWIFISCANCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.NetworkState.AllWifiScanChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_ALLWIFISCANCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.NetworkState.WifiAuthChannelListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND arg = (eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | in_or_out -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.NetworkState.AllWifiAuthChannelChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_LINKQUALITYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.NetworkState.LinkQualityChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | quality -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_NETWORKSTATE_CMD_LINKQUALITYCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.NetworkState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_NETWORKSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_AUDIOSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGS_CMD_MASTERVOLUME:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.AudioSettings.MasterVolume:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | volume -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGS_CMD_MASTERVOLUME */
                case ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGS_CMD_THEME:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.AudioSettings.Theme:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGS_THEME_THEME arg = (eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGS_THEME_THEME)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGS_THEME_THEME)ARCOMMANDS_ReadWrite_PrintI32 (" | theme -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGS_CMD_THEME */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.AudioSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_AUDIOSETTINGS */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_AUDIOSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGSSTATE_CMD_MASTERVOLUMECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.AudioSettingsState.MasterVolumeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | volume -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGSSTATE_CMD_MASTERVOLUMECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGSSTATE_CMD_THEMECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.AudioSettingsState.ThemeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED_THEME arg = (eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED_THEME)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED_THEME)ARCOMMANDS_ReadWrite_PrintI32 (" | theme -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_AUDIOSETTINGSSTATE_CMD_THEMECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.AudioSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_AUDIOSETTINGSSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ROADPLAN:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_ALLSCRIPTSMETADATA:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.RoadPlan.AllScriptsMetadata:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_ALLSCRIPTSMETADATA */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_SCRIPTUPLOADED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.RoadPlan.ScriptUploaded:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | uuid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | md5Hash -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_SCRIPTUPLOADED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_SCRIPTDELETE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.RoadPlan.ScriptDelete:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | uuid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_SCRIPTDELETE */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_PLAYSCRIPT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.RoadPlan.PlayScript:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | uuid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLAN_CMD_PLAYSCRIPT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.RoadPlan.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ROADPLAN */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ROADPLANSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTMETADATALISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.RoadPlanState.ScriptMetadataListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | uuid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | version -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | product -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint64_t arg = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU64 (" | lastModified -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTMETADATALISTCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_ALLSCRIPTSMETADATACHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.RoadPlanState.AllScriptsMetadataChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_ALLSCRIPTSMETADATACHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTUPLOADCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.RoadPlanState.ScriptUploadChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED_RESULTCODE arg = (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED_RESULTCODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED_RESULTCODE)ARCOMMANDS_ReadWrite_PrintI32 (" | resultCode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTUPLOADCHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTDELETECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.RoadPlanState.ScriptDeleteChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED_RESULTCODE arg = (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED_RESULTCODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED_RESULTCODE)ARCOMMANDS_ReadWrite_PrintI32 (" | resultCode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_SCRIPTDELETECHANGED */
                case ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_PLAYSCRIPTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.RoadPlanState.PlayScriptChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED_RESULTCODE arg = (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED_RESULTCODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED_RESULTCODE)ARCOMMANDS_ReadWrite_PrintI32 (" | resultCode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_ROADPLANSTATE_CMD_PLAYSCRIPTCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.RoadPlanState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_ROADPLANSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SPEEDSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_SPEEDSETTINGS_CMD_OUTDOOR:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.SpeedSettings.Outdoor:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | outdoor -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_SPEEDSETTINGS_CMD_OUTDOOR */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.SpeedSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SPEEDSETTINGS */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SPEEDSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_SPEEDSETTINGSSTATE_CMD_OUTDOORCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.SpeedSettingsState.OutdoorChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | outdoor -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_SPEEDSETTINGSSTATE_CMD_OUTDOORCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.SpeedSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_SPEEDSETTINGSSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIASTREAMING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIASTREAMING_CMD_VIDEOENABLE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaStreaming.VideoEnable:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enable -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIASTREAMING_CMD_VIDEOENABLE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaStreaming.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIASTREAMING */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIASTREAMINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaStreamingState.VideoEnableChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED arg = (eARCOMMANDS_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED)ARCOMMANDS_ReadWrite_PrintI32 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.MediaStreamingState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_MEDIASTREAMINGSTATE */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_VIDEOSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_VIDEOSETTINGS_CMD_AUTORECORD:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.VideoSettings.Autorecord:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_VIDEOSETTINGS_CMD_AUTORECORD */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.VideoSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_VIDEOSETTINGS */
            case ARCOMMANDS_ID_JUMPINGSUMO_CLASS_VIDEOSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_JUMPINGSUMO_VIDEOSETTINGSSTATE_CMD_AUTORECORDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.VideoSettingsState.AutorecordChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_JUMPINGSUMO_VIDEOSETTINGSSTATE_CMD_AUTORECORDCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.VideoSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_JUMPINGSUMO_CLASS_VIDEOSETTINGSSTATE */
            default:
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("JumpingSumo.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_JUMPINGSUMO */
        case ARCOMMANDS_ID_FEATURE_MAPPER:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MAPPER_CMD_GRAB:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.grab:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | buttons -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | axes -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_GRAB */
                case ARCOMMANDS_ID_MAPPER_CMD_MAP_BUTTON_ACTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.map_button_action:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | product -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MAPPER_BUTTON_ACTION arg = (eARCOMMANDS_MAPPER_BUTTON_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MAPPER_BUTTON_ACTION)ARCOMMANDS_ReadWrite_PrintI32 (" | action -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | buttons -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_MAP_BUTTON_ACTION */
                case ARCOMMANDS_ID_MAPPER_CMD_MAP_AXIS_ACTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.map_axis_action:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | product -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MAPPER_AXIS_ACTION arg = (eARCOMMANDS_MAPPER_AXIS_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MAPPER_AXIS_ACTION)ARCOMMANDS_ReadWrite_PrintI32 (" | action -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | axis -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | buttons -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_MAP_AXIS_ACTION */
                case ARCOMMANDS_ID_MAPPER_CMD_RESET_MAPPING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.reset_mapping:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | product -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_RESET_MAPPING */
                case ARCOMMANDS_ID_MAPPER_CMD_SET_EXPO:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.set_expo:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | product -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | axis -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MAPPER_EXPO_TYPE arg = (eARCOMMANDS_MAPPER_EXPO_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MAPPER_EXPO_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | expo -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_SET_EXPO */
                case ARCOMMANDS_ID_MAPPER_CMD_SET_INVERTED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.set_inverted:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | product -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | axis -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | inverted -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_SET_INVERTED */
                case ARCOMMANDS_ID_MAPPER_CMD_GRAB_STATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.grab_state:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | buttons -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | axes -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | buttons_state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_GRAB_STATE */
                case ARCOMMANDS_ID_MAPPER_CMD_GRAB_BUTTON_EVENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.grab_button_event:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | button -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MAPPER_BUTTON_EVENT arg = (eARCOMMANDS_MAPPER_BUTTON_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MAPPER_BUTTON_EVENT)ARCOMMANDS_ReadWrite_PrintI32 (" | event -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_GRAB_BUTTON_EVENT */
                case ARCOMMANDS_ID_MAPPER_CMD_GRAB_AXIS_EVENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.grab_axis_event:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | axis -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_GRAB_AXIS_EVENT */
                case ARCOMMANDS_ID_MAPPER_CMD_BUTTON_MAPPING_ITEM:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.button_mapping_item:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | uid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | product -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MAPPER_BUTTON_ACTION arg = (eARCOMMANDS_MAPPER_BUTTON_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MAPPER_BUTTON_ACTION)ARCOMMANDS_ReadWrite_PrintI32 (" | action -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | buttons -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | list_flags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_BUTTON_MAPPING_ITEM */
                case ARCOMMANDS_ID_MAPPER_CMD_AXIS_MAPPING_ITEM:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.axis_mapping_item:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | uid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | product -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MAPPER_AXIS_ACTION arg = (eARCOMMANDS_MAPPER_AXIS_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MAPPER_AXIS_ACTION)ARCOMMANDS_ReadWrite_PrintI32 (" | action -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | axis -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | buttons -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | list_flags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_AXIS_MAPPING_ITEM */
                case ARCOMMANDS_ID_MAPPER_CMD_APPLICATION_AXIS_EVENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.application_axis_event:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MAPPER_AXIS_ACTION arg = (eARCOMMANDS_MAPPER_AXIS_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MAPPER_AXIS_ACTION)ARCOMMANDS_ReadWrite_PrintI32 (" | action -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_APPLICATION_AXIS_EVENT */
                case ARCOMMANDS_ID_MAPPER_CMD_APPLICATION_BUTTON_EVENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.application_button_event:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MAPPER_BUTTON_ACTION arg = (eARCOMMANDS_MAPPER_BUTTON_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MAPPER_BUTTON_ACTION)ARCOMMANDS_ReadWrite_PrintI32 (" | action -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_APPLICATION_BUTTON_EVENT */
                case ARCOMMANDS_ID_MAPPER_CMD_EXPO_MAP_ITEM:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.expo_map_item:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | uid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | product -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | axis -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MAPPER_EXPO_TYPE arg = (eARCOMMANDS_MAPPER_EXPO_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MAPPER_EXPO_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | expo -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | list_flags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_EXPO_MAP_ITEM */
                case ARCOMMANDS_ID_MAPPER_CMD_INVERTED_MAP_ITEM:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.inverted_map_item:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | uid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | product -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | axis -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | inverted -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | list_flags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_INVERTED_MAP_ITEM */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_MAPPER */
        case ARCOMMANDS_ID_FEATURE_MINIDRONE:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_FLATTRIM:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Piloting.FlatTrim:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_FLATTRIM */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_TAKEOFF:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Piloting.TakeOff:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_TAKEOFF */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_PCMD:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Piloting.PCMD:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | flag -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | roll -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | pitch -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | yaw -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | gaz -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | timestamp -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_PCMD */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_LANDING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Piloting.Landing:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_LANDING */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_EMERGENCY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Piloting.Emergency:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_EMERGENCY */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_AUTOTAKEOFFMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Piloting.AutoTakeOffMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_AUTOTAKEOFFMODE */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_FLYINGMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Piloting.FlyingMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_PILOTING_FLYINGMODE_MODE arg = (eARCOMMANDS_MINIDRONE_PILOTING_FLYINGMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_PILOTING_FLYINGMODE_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_FLYINGMODE */
                case ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_PLANEGEARBOX:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Piloting.PlaneGearBox:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_PILOTING_PLANEGEARBOX_STATE arg = (eARCOMMANDS_MINIDRONE_PILOTING_PLANEGEARBOX_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_PILOTING_PLANEGEARBOX_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTING_CMD_PLANEGEARBOX */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Piloting.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTING */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_FLATTRIMCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingState.FlatTrimChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_FLATTRIMCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_FLYINGSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingState.FlyingStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE arg = (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_FLYINGSTATECHANGED */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_ALERTSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingState.AlertStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE arg = (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_ALERTSTATECHANGED */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_AUTOTAKEOFFMODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingState.AutoTakeOffModeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_AUTOTAKEOFFMODECHANGED */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_FLYINGMODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingState.FlyingModeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGMODECHANGED_MODE arg = (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGMODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGMODECHANGED_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_FLYINGMODECHANGED */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_PLANEGEARBOXCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingState.PlaneGearBoxChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_PILOTINGSTATE_PLANEGEARBOXCHANGED_STATE arg = (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_PLANEGEARBOXCHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_PLANEGEARBOXCHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSTATE_CMD_PLANEGEARBOXCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_ANIMATIONS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_ANIMATIONS_CMD_FLIP:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Animations.Flip:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_ANIMATIONS_FLIP_DIRECTION arg = (eARCOMMANDS_MINIDRONE_ANIMATIONS_FLIP_DIRECTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_ANIMATIONS_FLIP_DIRECTION)ARCOMMANDS_ReadWrite_PrintI32 (" | direction -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_ANIMATIONS_CMD_FLIP */
                case ARCOMMANDS_ID_MINIDRONE_ANIMATIONS_CMD_CAP:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Animations.Cap:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int16_t arg =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI16 (" | offset -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_ANIMATIONS_CMD_CAP */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Animations.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_ANIMATIONS */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORD:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_MEDIARECORD_CMD_PICTURE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.MediaRecord.Picture:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_MEDIARECORD_CMD_PICTURE */
                case ARCOMMANDS_ID_MINIDRONE_MEDIARECORD_CMD_PICTUREV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.MediaRecord.PictureV2:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_MEDIARECORD_CMD_PICTUREV2 */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.MediaRecord.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORD */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORDSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.MediaRecordState.PictureStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED */
                case ARCOMMANDS_ID_MINIDRONE_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.MediaRecordState.PictureStateChangedV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE arg = (eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR arg = (eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2 */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.MediaRecordState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORDSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORDEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.MediaRecordEvent.PictureEventChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT arg = (eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_PrintI32 (" | event -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR arg = (eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.MediaRecordEvent.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_MEDIARECORDEVENT */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGS_CMD_MAXALTITUDE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingSettings.MaxAltitude:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGS_CMD_MAXALTITUDE */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGS_CMD_MAXTILT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingSettings.MaxTilt:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGS_CMD_MAXTILT */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGS_CMD_PLANEMODEPITCH:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingSettings.PlaneModePitch:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGS_CMD_PLANEMODEPITCH */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSETTINGS */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGSSTATE_CMD_MAXALTITUDECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingSettingsState.MaxAltitudeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGSSTATE_CMD_MAXALTITUDECHANGED */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGSSTATE_CMD_MAXTILTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingSettingsState.MaxTiltChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGSSTATE_CMD_MAXTILTCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGSSTATE_CMD_PLANEMODEPITCHCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingSettingsState.PlaneModePitchChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_PILOTINGSETTINGSSTATE_CMD_PLANEMODEPITCHCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.PilotingSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_PILOTINGSETTINGSSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_SPEEDSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXVERTICALSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SpeedSettings.MaxVerticalSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXVERTICALSPEED */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXROTATIONSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SpeedSettings.MaxRotationSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXROTATIONSPEED */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_WHEELS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SpeedSettings.Wheels:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | present -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_WHEELS */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXHORIZONTALSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SpeedSettings.MaxHorizontalSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXHORIZONTALSPEED */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXPLANEMODEROTATIONSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SpeedSettings.MaxPlaneModeRotationSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGS_CMD_MAXPLANEMODEROTATIONSPEED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SpeedSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_SPEEDSETTINGS */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_SPEEDSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXVERTICALSPEEDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SpeedSettingsState.MaxVerticalSpeedChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXVERTICALSPEEDCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXROTATIONSPEEDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SpeedSettingsState.MaxRotationSpeedChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXROTATIONSPEEDCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_WHEELSCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SpeedSettingsState.WheelsChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | present -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_WHEELSCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXHORIZONTALSPEEDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SpeedSettingsState.MaxHorizontalSpeedChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXHORIZONTALSPEEDCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXPLANEMODEROTATIONSPEEDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SpeedSettingsState.MaxPlaneModeRotationSpeedChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SPEEDSETTINGSSTATE_CMD_MAXPLANEMODEROTATIONSPEEDCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SpeedSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_SPEEDSETTINGSSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_SETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_SETTINGS_CMD_CUTOUTMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Settings.CutOutMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enable -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SETTINGS_CMD_CUTOUTMODE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Settings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_SETTINGS */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_PRODUCTMOTORSVERSIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SettingsState.ProductMotorsVersionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | motor -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | software -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | hardware -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_PRODUCTMOTORSVERSIONCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_PRODUCTINERTIALVERSIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SettingsState.ProductInertialVersionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | software -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | hardware -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_PRODUCTINERTIALVERSIONCHANGED */
                case ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_CUTOUTMODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SettingsState.CutOutModeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enable -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_SETTINGSSTATE_CMD_CUTOUTMODECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.SettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_FLOODCONTROLSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_FLOODCONTROLSTATE_CMD_FLOODCONTROLCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.FloodControlState.FloodControlChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | delay -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_FLOODCONTROLSTATE_CMD_FLOODCONTROLCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.FloodControlState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_FLOODCONTROLSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_GPS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_GPS_CMD_CONTROLLERLATITUDEFORRUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.GPS.ControllerLatitudeForRun:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_GPS_CMD_CONTROLLERLATITUDEFORRUN */
                case ARCOMMANDS_ID_MINIDRONE_GPS_CMD_CONTROLLERLONGITUDEFORRUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.GPS.ControllerLongitudeForRun:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_GPS_CMD_CONTROLLERLONGITUDEFORRUN */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.GPS.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_GPS */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_CONFIGURATION:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_CONFIGURATION_CMD_CONTROLLERTYPE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Configuration.ControllerType:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_CONFIGURATION_CMD_CONTROLLERTYPE */
                case ARCOMMANDS_ID_MINIDRONE_CONFIGURATION_CMD_CONTROLLERNAME:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Configuration.ControllerName:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_CONFIGURATION_CMD_CONTROLLERNAME */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.Configuration.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_CONFIGURATION */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_USBACCESSORYSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_USBACCESSORYSTATE_CMD_LIGHTSTATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.UsbAccessoryState.LightState:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE_STATE arg = (eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | intensity -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | list_flags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_USBACCESSORYSTATE_CMD_LIGHTSTATE */
                case ARCOMMANDS_ID_MINIDRONE_USBACCESSORYSTATE_CMD_CLAWSTATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.UsbAccessoryState.ClawState:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_CLAWSTATE_STATE arg = (eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_CLAWSTATE_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_CLAWSTATE_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | list_flags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_USBACCESSORYSTATE_CMD_CLAWSTATE */
                case ARCOMMANDS_ID_MINIDRONE_USBACCESSORYSTATE_CMD_GUNSTATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.UsbAccessoryState.GunState:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_GUNSTATE_STATE arg = (eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_GUNSTATE_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_GUNSTATE_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | list_flags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_USBACCESSORYSTATE_CMD_GUNSTATE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.UsbAccessoryState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_USBACCESSORYSTATE */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_USBACCESSORY:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_USBACCESSORY_CMD_LIGHTCONTROL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.UsbAccessory.LightControl:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_USBACCESSORY_LIGHTCONTROL_MODE arg = (eARCOMMANDS_MINIDRONE_USBACCESSORY_LIGHTCONTROL_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_USBACCESSORY_LIGHTCONTROL_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | intensity -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_USBACCESSORY_CMD_LIGHTCONTROL */
                case ARCOMMANDS_ID_MINIDRONE_USBACCESSORY_CMD_CLAWCONTROL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.UsbAccessory.ClawControl:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_USBACCESSORY_CLAWCONTROL_ACTION arg = (eARCOMMANDS_MINIDRONE_USBACCESSORY_CLAWCONTROL_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_USBACCESSORY_CLAWCONTROL_ACTION)ARCOMMANDS_ReadWrite_PrintI32 (" | action -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_USBACCESSORY_CMD_CLAWCONTROL */
                case ARCOMMANDS_ID_MINIDRONE_USBACCESSORY_CMD_GUNCONTROL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.UsbAccessory.GunControl:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MINIDRONE_USBACCESSORY_GUNCONTROL_ACTION arg = (eARCOMMANDS_MINIDRONE_USBACCESSORY_GUNCONTROL_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MINIDRONE_USBACCESSORY_GUNCONTROL_ACTION)ARCOMMANDS_ReadWrite_PrintI32 (" | action -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_USBACCESSORY_CMD_GUNCONTROL */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.UsbAccessory.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_USBACCESSORY */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_REMOTECONTROLLER:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_REMOTECONTROLLER_CMD_SETPAIREDREMOTE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.RemoteController.SetPairedRemote:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | msb_mac -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | mid_mac -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | lsb_mac -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_REMOTECONTROLLER_CMD_SETPAIREDREMOTE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.RemoteController.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_REMOTECONTROLLER */
            case ARCOMMANDS_ID_MINIDRONE_CLASS_NAVIGATIONDATASTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MINIDRONE_NAVIGATIONDATASTATE_CMD_DRONEPOSITION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.NavigationDataState.DronePosition:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | posx -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | posy -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int16_t arg =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI16 (" | posz -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int16_t arg =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI16 (" | psi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int16_t arg =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI16 (" | ts -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MINIDRONE_NAVIGATIONDATASTATE_CMD_DRONEPOSITION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.NavigationDataState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_MINIDRONE_CLASS_NAVIGATIONDATASTATE */
            default:
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("MiniDrone.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_MINIDRONE */
        case ARCOMMANDS_ID_FEATURE_POWERUP:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_POWERUP_CLASS_PILOTING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_PILOTING_CMD_PCMD:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.Piloting.PCMD:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | flag -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | throttle -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | roll -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTING_CMD_PCMD */
                case ARCOMMANDS_ID_POWERUP_PILOTING_CMD_USERTAKEOFF:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.Piloting.UserTakeOff:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTING_CMD_USERTAKEOFF */
                case ARCOMMANDS_ID_POWERUP_PILOTING_CMD_MOTORMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.Piloting.MotorMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_PILOTING_MOTORMODE_MODE arg = (eARCOMMANDS_POWERUP_PILOTING_MOTORMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_PILOTING_MOTORMODE_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTING_CMD_MOTORMODE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.Piloting.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_PILOTING */
            case ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ALERTSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.PilotingState.AlertStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_PILOTINGSTATE_ALERTSTATECHANGED_STATE arg = (eARCOMMANDS_POWERUP_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ALERTSTATECHANGED */
                case ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_FLYINGSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.PilotingState.FlyingStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_PILOTINGSTATE_FLYINGSTATECHANGED_STATE arg = (eARCOMMANDS_POWERUP_PILOTINGSTATE_FLYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_PILOTINGSTATE_FLYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_FLYINGSTATECHANGED */
                case ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_MOTORMODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.PilotingState.MotorModeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_PILOTINGSTATE_MOTORMODECHANGED_MODE arg = (eARCOMMANDS_POWERUP_PILOTINGSTATE_MOTORMODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_PILOTINGSTATE_MOTORMODECHANGED_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_MOTORMODECHANGED */
                case ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ATTITUDECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.PilotingState.AttitudeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | roll -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | pitch -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | yaw -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ATTITUDECHANGED */
                case ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ALTITUDECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.PilotingState.AltitudeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ALTITUDECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.PilotingState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_PILOTINGSETTINGS_CMD_SET:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.PilotingSettings.set:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_PILOTINGSETTINGS_SET_SETTING arg = (eARCOMMANDS_POWERUP_PILOTINGSETTINGS_SET_SETTING)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_PILOTINGSETTINGS_SET_SETTING)ARCOMMANDS_ReadWrite_PrintI32 (" | setting -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSETTINGS_CMD_SET */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.PilotingSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSETTINGS */
            case ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_PILOTINGSETTINGSSTATE_CMD_SETTINGCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.PilotingSettingsState.settingChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_PILOTINGSETTINGSSTATE_SETTINGCHANGED_SETTING arg = (eARCOMMANDS_POWERUP_PILOTINGSETTINGSSTATE_SETTINGCHANGED_SETTING)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_PILOTINGSETTINGSSTATE_SETTINGCHANGED_SETTING)ARCOMMANDS_ReadWrite_PrintI32 (" | setting -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | list_flags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSETTINGSSTATE_CMD_SETTINGCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.PilotingSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSETTINGSSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORD:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_MEDIARECORD_CMD_PICTUREV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaRecord.PictureV2:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORD_CMD_PICTUREV2 */
                case ARCOMMANDS_ID_POWERUP_MEDIARECORD_CMD_VIDEOV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaRecord.VideoV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORD_VIDEOV2_RECORD arg = (eARCOMMANDS_POWERUP_MEDIARECORD_VIDEOV2_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_MEDIARECORD_VIDEOV2_RECORD)ARCOMMANDS_ReadWrite_PrintI32 (" | record -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORD_CMD_VIDEOV2 */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaRecord.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORD */
            case ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORDSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaRecordState.PictureStateChangedV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE arg = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR arg = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2 */
                case ARCOMMANDS_ID_POWERUP_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaRecordState.VideoStateChangedV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE arg = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR arg = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2 */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaRecordState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORDSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORDEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaRecordEvent.PictureEventChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT arg = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_PrintI32 (" | event -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR arg = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED */
                case ARCOMMANDS_ID_POWERUP_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaRecordEvent.VideoEventChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT arg = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_PrintI32 (" | event -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR arg = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaRecordEvent.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORDEVENT */
            case ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_NETWORKSETTINGS_CMD_WIFISELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.NetworkSettings.WifiSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_NETWORKSETTINGS_WIFISELECTION_TYPE arg = (eARCOMMANDS_POWERUP_NETWORKSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_NETWORKSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_NETWORKSETTINGS_WIFISELECTION_BAND arg = (eARCOMMANDS_POWERUP_NETWORKSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_NETWORKSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSETTINGS_CMD_WIFISELECTION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.NetworkSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSETTINGS */
            case ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.NetworkSettingsState.WifiSelectionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE arg = (eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND arg = (eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.NetworkSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSETTINGSSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_NETWORK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_NETWORK_CMD_WIFISCAN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.Network.WifiScan:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_NETWORK_WIFISCAN_BAND arg = (eARCOMMANDS_POWERUP_NETWORK_WIFISCAN_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_NETWORK_WIFISCAN_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORK_CMD_WIFISCAN */
                case ARCOMMANDS_ID_POWERUP_NETWORK_CMD_WIFIAUTHCHANNEL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.Network.WifiAuthChannel:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORK_CMD_WIFIAUTHCHANNEL */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.Network.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_NETWORK */
            case ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_WIFISCANLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.NetworkState.WifiScanListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | ssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int16_t arg =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI16 (" | rssi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_NETWORKSTATE_WIFISCANLISTCHANGED_BAND arg = (eARCOMMANDS_POWERUP_NETWORKSTATE_WIFISCANLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_NETWORKSTATE_WIFISCANLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_WIFISCANLISTCHANGED */
                case ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_ALLWIFISCANCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.NetworkState.AllWifiScanChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_ALLWIFISCANCHANGED */
                case ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.NetworkState.WifiAuthChannelListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND arg = (eARCOMMANDS_POWERUP_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | in_or_out -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED */
                case ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.NetworkState.AllWifiAuthChannelChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED */
                case ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_LINKQUALITYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.NetworkState.LinkQualityChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | quality -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_LINKQUALITYCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.NetworkState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_MEDIASTREAMING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_MEDIASTREAMING_CMD_VIDEOENABLE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaStreaming.VideoEnable:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enable -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIASTREAMING_CMD_VIDEOENABLE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaStreaming.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_MEDIASTREAMING */
            case ARCOMMANDS_ID_POWERUP_CLASS_MEDIASTREAMINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaStreamingState.VideoEnableChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED arg = (eARCOMMANDS_POWERUP_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED)ARCOMMANDS_ReadWrite_PrintI32 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaStreamingState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_MEDIASTREAMINGSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_VIDEOSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_VIDEOSETTINGS_CMD_AUTORECORD:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.VideoSettings.Autorecord:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enable -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_VIDEOSETTINGS_CMD_AUTORECORD */
                case ARCOMMANDS_ID_POWERUP_VIDEOSETTINGS_CMD_VIDEOMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.VideoSettings.VideoMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_VIDEOSETTINGS_VIDEOMODE_MODE arg = (eARCOMMANDS_POWERUP_VIDEOSETTINGS_VIDEOMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_VIDEOSETTINGS_VIDEOMODE_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_VIDEOSETTINGS_CMD_VIDEOMODE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.VideoSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_VIDEOSETTINGS */
            case ARCOMMANDS_ID_POWERUP_CLASS_VIDEOSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_VIDEOSETTINGSSTATE_CMD_AUTORECORDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.VideoSettingsState.AutorecordChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_VIDEOSETTINGSSTATE_CMD_AUTORECORDCHANGED */
                case ARCOMMANDS_ID_POWERUP_VIDEOSETTINGSSTATE_CMD_VIDEOMODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.VideoSettingsState.VideoModeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_VIDEOSETTINGSSTATE_VIDEOMODECHANGED_MODE arg = (eARCOMMANDS_POWERUP_VIDEOSETTINGSSTATE_VIDEOMODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_VIDEOSETTINGSSTATE_VIDEOMODECHANGED_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_VIDEOSETTINGSSTATE_CMD_VIDEOMODECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.VideoSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_VIDEOSETTINGSSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_SOUNDS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_SOUNDS_CMD_BUZZ:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.Sounds.buzz:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enable -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_SOUNDS_CMD_BUZZ */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.Sounds.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_SOUNDS */
            case ARCOMMANDS_ID_POWERUP_CLASS_SOUNDSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_SOUNDSSTATE_CMD_BUZZCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.SoundsState.buzzChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_SOUNDSSTATE_CMD_BUZZCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.SoundsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_SOUNDSSTATE */
            default:
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_POWERUP */
        case ARCOMMANDS_ID_FEATURE_PRO:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_PRO_CLASS_PRO:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_PRO_PRO_CMD_BOUGHTFEATURES:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("pro.Pro.BoughtFeatures:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint64_t arg = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU64 (" | features -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_PRO_PRO_CMD_BOUGHTFEATURES */
                case ARCOMMANDS_ID_PRO_PRO_CMD_RESPONSE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("pro.Pro.Response:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | listFlags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | signedChallenge -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_PRO_PRO_CMD_RESPONSE */
                case ARCOMMANDS_ID_PRO_PRO_CMD_ACTIVATEFEATURES:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("pro.Pro.ActivateFeatures:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint64_t arg = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU64 (" | features -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_PRO_PRO_CMD_ACTIVATEFEATURES */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("pro.Pro.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_PRO_CLASS_PRO */
            case ARCOMMANDS_ID_PRO_CLASS_PROSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_PRO_PROSTATE_CMD_SUPPORTEDFEATURES:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("pro.ProState.SupportedFeatures:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_PRO_PROSTATE_SUPPORTEDFEATURES_STATUS arg = (eARCOMMANDS_PRO_PROSTATE_SUPPORTEDFEATURES_STATUS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_PRO_PROSTATE_SUPPORTEDFEATURES_STATUS)ARCOMMANDS_ReadWrite_PrintI32 (" | status -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint64_t arg = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU64 (" | features -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_PRO_PROSTATE_CMD_SUPPORTEDFEATURES */
                case ARCOMMANDS_ID_PRO_PROSTATE_CMD_FEATURESACTIVATED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("pro.ProState.FeaturesActivated:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint64_t arg = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU64 (" | features -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_PRO_PROSTATE_CMD_FEATURESACTIVATED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("pro.ProState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_PRO_CLASS_PROSTATE */
            case ARCOMMANDS_ID_PRO_CLASS_PROEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_PRO_PROEVENT_CMD_CHALLENGEEVENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("pro.ProEvent.ChallengeEvent:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | challenge -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_PRO_PROEVENT_CMD_CHALLENGEEVENT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("pro.ProEvent.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_PRO_CLASS_PROEVENT */
            default:
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("pro.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_PRO */
        case ARCOMMANDS_ID_FEATURE_RC:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_RC_CMD_MONITOR_CHANNELS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.monitor_channels:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enable -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_RC_CMD_MONITOR_CHANNELS */
                case ARCOMMANDS_ID_RC_CMD_START_CALIBRATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.start_calibration:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_RC_CALIBRATION_TYPE arg = (eARCOMMANDS_RC_CALIBRATION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_RC_CALIBRATION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_RC_CHANNEL_TYPE arg = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_RC_CMD_START_CALIBRATION */
                case ARCOMMANDS_ID_RC_CMD_INVERT_CHANNEL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.invert_channel:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_RC_CHANNEL_TYPE arg = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | flag -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_RC_CMD_INVERT_CHANNEL */
                case ARCOMMANDS_ID_RC_CMD_ABORT_CALIBRATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.abort_calibration:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_RC_CMD_ABORT_CALIBRATION */
                case ARCOMMANDS_ID_RC_CMD_RESET_CALIBRATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.reset_calibration:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_RC_CMD_RESET_CALIBRATION */
                case ARCOMMANDS_ID_RC_CMD_RECEIVER_STATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.receiver_state:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_RC_RECEIVER_STATE arg = (eARCOMMANDS_RC_RECEIVER_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_RC_RECEIVER_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | protocol -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_RC_CMD_RECEIVER_STATE */
                case ARCOMMANDS_ID_RC_CMD_CHANNELS_MONITOR_STATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.channels_monitor_state:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_RC_CMD_CHANNELS_MONITOR_STATE */
                case ARCOMMANDS_ID_RC_CMD_CHANNEL_VALUE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.channel_value:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_RC_CHANNEL_TYPE arg = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int16_t arg =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI16 (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | list_flags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_RC_CMD_CHANNEL_VALUE */
                case ARCOMMANDS_ID_RC_CMD_CALIBRATION_STATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.calibration_state:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_RC_CALIBRATION_TYPE arg = (eARCOMMANDS_RC_CALIBRATION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_RC_CALIBRATION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_RC_CHANNEL_TYPE arg = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | supported -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | required -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | calibrated -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | neutral_calibrated -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | inverted -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_RC_CMD_CALIBRATION_STATE */
                case ARCOMMANDS_ID_RC_CMD_RECEIVER_QUALITY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.receiver_quality:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | level -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_RC_CMD_RECEIVER_QUALITY */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_RC */
        case ARCOMMANDS_ID_FEATURE_SKYCONTROLLER:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_WIFISTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFILIST:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.WifiState.WifiList:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | bssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | ssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | secured -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | saved -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | rssi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | frequency -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFILIST */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_CONNEXIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.WifiState.ConnexionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | ssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_STATUS arg = (eARCOMMANDS_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_STATUS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_STATUS)ARCOMMANDS_ReadWrite_PrintI32 (" | status -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_CONNEXIONCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFIAUTHCHANNELLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.WifiState.WifiAuthChannelListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_BAND arg = (eARCOMMANDS_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | in_or_out -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFIAUTHCHANNELLISTCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_ALLWIFIAUTHCHANNELCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.WifiState.AllWifiAuthChannelChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_ALLWIFIAUTHCHANNELCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFISIGNALCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.WifiState.WifiSignalChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | level -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFISTATE_CMD_WIFISIGNALCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.WifiState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_WIFISTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_WIFI:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_REQUESTWIFILIST:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Wifi.RequestWifiList:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_REQUESTWIFILIST */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_REQUESTCURRENTWIFI:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Wifi.RequestCurrentWifi:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_REQUESTCURRENTWIFI */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_CONNECTTOWIFI:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Wifi.ConnectToWifi:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | bssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | ssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | passphrase -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_CONNECTTOWIFI */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_FORGETWIFI:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Wifi.ForgetWifi:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | ssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_FORGETWIFI */
                case ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_WIFIAUTHCHANNEL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Wifi.WifiAuthChannel:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_WIFI_CMD_WIFIAUTHCHANNEL */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Wifi.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_WIFI */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_DEVICE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_REQUESTDEVICELIST:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Device.RequestDeviceList:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_REQUESTDEVICELIST */
                case ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_REQUESTCURRENTDEVICE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Device.RequestCurrentDevice:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_REQUESTCURRENTDEVICE */
                case ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_CONNECTTODEVICE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Device.ConnectToDevice:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | deviceName -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_DEVICE_CMD_CONNECTTODEVICE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Device.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_DEVICE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_DEVICESTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_DEVICESTATE_CMD_DEVICELIST:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.DeviceState.DeviceList:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_DEVICESTATE_CMD_DEVICELIST */
                case ARCOMMANDS_ID_SKYCONTROLLER_DEVICESTATE_CMD_CONNEXIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.DeviceState.ConnexionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_STATUS arg = (eARCOMMANDS_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_STATUS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_STATUS)ARCOMMANDS_ReadWrite_PrintI32 (" | status -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | deviceName -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | deviceProductID -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_DEVICESTATE_CMD_CONNEXIONCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.DeviceState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_DEVICESTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGS_CMD_ALLSETTINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Settings.AllSettings:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGS_CMD_ALLSETTINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGS_CMD_RESET:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Settings.Reset:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGS_CMD_RESET */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Settings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SETTINGS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_ALLSETTINGSCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.SettingsState.AllSettingsChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_ALLSETTINGSCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_RESETCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.SettingsState.ResetChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_RESETCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_PRODUCTSERIALCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.SettingsState.ProductSerialChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | serialNumber -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_PRODUCTSERIALCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_PRODUCTVARIANTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.SettingsState.ProductVariantChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_SETTINGSSTATE_PRODUCTVARIANTCHANGED_VARIANT arg = (eARCOMMANDS_SKYCONTROLLER_SETTINGSSTATE_PRODUCTVARIANTCHANGED_VARIANT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_SETTINGSSTATE_PRODUCTVARIANTCHANGED_VARIANT)ARCOMMANDS_ReadWrite_PrintI32 (" | variant -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_PRODUCTVARIANTCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_PRODUCTVERSIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.SettingsState.ProductVersionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | software -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | hardware -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SETTINGSSTATE_CMD_PRODUCTVERSIONCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.SettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COMMON:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_COMMON_CMD_ALLSTATES:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Common.AllStates:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_COMMON_CMD_ALLSTATES */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Common.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COMMON */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COMMONSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_COMMONSTATE_CMD_ALLSTATESCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.CommonState.AllStatesChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_COMMONSTATE_CMD_ALLSTATESCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.CommonState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COMMONSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SKYCONTROLLERSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_BATTERYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.SkyControllerState.BatteryChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | percent -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_BATTERYCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_GPSFIXCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.SkyControllerState.GpsFixChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | fixed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_GPSFIXCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_GPSPOSITIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.SkyControllerState.GpsPositionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | heading -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_GPSPOSITIONCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_BATTERYSTATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.SkyControllerState.BatteryState:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_SKYCONTROLLERSTATE_BATTERYSTATE_STATE arg = (eARCOMMANDS_SKYCONTROLLER_SKYCONTROLLERSTATE_BATTERYSTATE_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_SKYCONTROLLERSTATE_BATTERYSTATE_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_BATTERYSTATE */
                case ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_ATTITUDECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.SkyControllerState.AttitudeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | q0 -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | q1 -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | q2 -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | q3 -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_SKYCONTROLLERSTATE_CMD_ATTITUDECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.SkyControllerState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_SKYCONTROLLERSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_ACCESSPOINTSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_ACCESSPOINTSSID:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AccessPointSettings.AccessPointSSID:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | ssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_ACCESSPOINTSSID */
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_ACCESSPOINTCHANNEL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AccessPointSettings.AccessPointChannel:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_ACCESSPOINTCHANNEL */
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_WIFISELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AccessPointSettings.WifiSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_TYPE arg = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_BAND arg = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGS_CMD_WIFISELECTION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AccessPointSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_ACCESSPOINTSETTINGS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_ACCESSPOINTSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_ACCESSPOINTSSIDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AccessPointSettingsState.AccessPointSSIDChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | ssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_ACCESSPOINTSSIDCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_ACCESSPOINTCHANNELCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AccessPointSettingsState.AccessPointChannelChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_ACCESSPOINTCHANNELCHANGED */
                case ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_WIFISELECTIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AccessPointSettingsState.WifiSelectionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE arg = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_BAND arg = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_CMD_WIFISELECTIONCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AccessPointSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_ACCESSPOINTSETTINGSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CAMERA:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_CAMERA_CMD_RESETORIENTATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Camera.ResetOrientation:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_CAMERA_CMD_RESETORIENTATION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Camera.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CAMERA */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_GAMEPADINFOS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOS_CMD_GETGAMEPADCONTROLS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.GamepadInfos.getGamepadControls:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOS_CMD_GETGAMEPADCONTROLS */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.GamepadInfos.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_GAMEPADINFOS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_GAMEPADINFOSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOSSTATE_CMD_GAMEPADCONTROL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.GamepadInfosState.gamepadControl:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_TYPE arg = (eARCOMMANDS_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOSSTATE_CMD_GAMEPADCONTROL */
                case ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOSSTATE_CMD_ALLGAMEPADCONTROLSSENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.GamepadInfosState.allGamepadControlsSent:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_GAMEPADINFOSSTATE_CMD_ALLGAMEPADCONTROLSSENT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.GamepadInfosState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_GAMEPADINFOSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_BUTTONMAPPINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_GETCURRENTBUTTONMAPPINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.ButtonMappings.getCurrentButtonMappings:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_GETCURRENTBUTTONMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_GETAVAILABLEBUTTONMAPPINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.ButtonMappings.getAvailableButtonMappings:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_GETAVAILABLEBUTTONMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_SETBUTTONMAPPING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.ButtonMappings.setButtonMapping:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | key_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | mapping_uid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_SETBUTTONMAPPING */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_DEFAULTBUTTONMAPPING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.ButtonMappings.defaultButtonMapping:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGS_CMD_DEFAULTBUTTONMAPPING */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.ButtonMappings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_BUTTONMAPPINGS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_BUTTONMAPPINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_CURRENTBUTTONMAPPINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.ButtonMappingsState.currentButtonMappings:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | key_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | mapping_uid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_CURRENTBUTTONMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_ALLCURRENTBUTTONMAPPINGSSENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.ButtonMappingsState.allCurrentButtonMappingsSent:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_ALLCURRENTBUTTONMAPPINGSSENT */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_AVAILABLEBUTTONMAPPINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.ButtonMappingsState.availableButtonMappings:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | mapping_uid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_AVAILABLEBUTTONMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_ALLAVAILABLEBUTTONSMAPPINGSSENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.ButtonMappingsState.allAvailableButtonsMappingsSent:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CMD_ALLAVAILABLEBUTTONSMAPPINGSSENT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.ButtonMappingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_BUTTONMAPPINGSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISMAPPINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_GETCURRENTAXISMAPPINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisMappings.getCurrentAxisMappings:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_GETCURRENTAXISMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_GETAVAILABLEAXISMAPPINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisMappings.getAvailableAxisMappings:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_GETAVAILABLEAXISMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_SETAXISMAPPING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisMappings.setAxisMapping:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | axis_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | mapping_uid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_SETAXISMAPPING */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_DEFAULTAXISMAPPING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisMappings.defaultAxisMapping:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGS_CMD_DEFAULTAXISMAPPING */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisMappings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISMAPPINGS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISMAPPINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_CURRENTAXISMAPPINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisMappingsState.currentAxisMappings:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | axis_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | mapping_uid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_CURRENTAXISMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_ALLCURRENTAXISMAPPINGSSENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisMappingsState.allCurrentAxisMappingsSent:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_ALLCURRENTAXISMAPPINGSSENT */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_AVAILABLEAXISMAPPINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisMappingsState.availableAxisMappings:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | mapping_uid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_AVAILABLEAXISMAPPINGS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_ALLAVAILABLEAXISMAPPINGSSENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisMappingsState.allAvailableAxisMappingsSent:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISMAPPINGSSTATE_CMD_ALLAVAILABLEAXISMAPPINGSSENT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisMappingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISMAPPINGSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISFILTERS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_GETCURRENTAXISFILTERS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisFilters.getCurrentAxisFilters:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_GETCURRENTAXISFILTERS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_GETPRESETAXISFILTERS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisFilters.getPresetAxisFilters:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_GETPRESETAXISFILTERS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_SETAXISFILTER:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisFilters.setAxisFilter:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | axis_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | filter_uid_or_builder -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_SETAXISFILTER */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_DEFAULTAXISFILTERS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisFilters.defaultAxisFilters:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERS_CMD_DEFAULTAXISFILTERS */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisFilters.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISFILTERS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISFILTERSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_CURRENTAXISFILTERS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisFiltersState.currentAxisFilters:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | axis_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | filter_uid_or_builder -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_CURRENTAXISFILTERS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_ALLCURRENTFILTERSSENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisFiltersState.allCurrentFiltersSent:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_ALLCURRENTFILTERSSENT */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_PRESETAXISFILTERS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisFiltersState.presetAxisFilters:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | filter_uid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_PRESETAXISFILTERS */
                case ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_ALLPRESETFILTERSSENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisFiltersState.allPresetFiltersSent:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_AXISFILTERSSTATE_CMD_ALLPRESETFILTERSSENT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.AxisFiltersState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_AXISFILTERSSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COPILOTING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_COPILOTING_CMD_SETPILOTINGSOURCE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.CoPiloting.setPilotingSource:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_COPILOTING_SETPILOTINGSOURCE_SOURCE arg = (eARCOMMANDS_SKYCONTROLLER_COPILOTING_SETPILOTINGSOURCE_SOURCE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_COPILOTING_SETPILOTINGSOURCE_SOURCE)ARCOMMANDS_ReadWrite_PrintI32 (" | source -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_COPILOTING_CMD_SETPILOTINGSOURCE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.CoPiloting.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COPILOTING */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COPILOTINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_COPILOTINGSTATE_CMD_PILOTINGSOURCE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.CoPilotingState.pilotingSource:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE_SOURCE arg = (eARCOMMANDS_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE_SOURCE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE_SOURCE)ARCOMMANDS_ReadWrite_PrintI32 (" | source -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_COPILOTINGSTATE_CMD_PILOTINGSOURCE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.CoPilotingState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_COPILOTINGSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CALIBRATION:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATION_CMD_ENABLEMAGNETOCALIBRATIONQUALITYUPDATES:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Calibration.enableMagnetoCalibrationQualityUpdates:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enable -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATION_CMD_ENABLEMAGNETOCALIBRATIONQUALITYUPDATES */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Calibration.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CALIBRATION */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CALIBRATIONSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.CalibrationState.MagnetoCalibrationState:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_STATUS arg = (eARCOMMANDS_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_STATUS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_STATUS)ARCOMMANDS_ReadWrite_PrintI32 (" | status -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | X_Quality -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | Y_Quality -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | Z_Quality -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTATE */
                case ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONQUALITYUPDATESSTATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.CalibrationState.MagnetoCalibrationQualityUpdatesState:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONQUALITYUPDATESSTATE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.CalibrationState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_CALIBRATIONSTATE */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_BUTTONEVENTS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_BUTTONEVENTS_CMD_SETTINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.ButtonEvents.Settings:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_BUTTONEVENTS_CMD_SETTINGS */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.ButtonEvents.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_BUTTONEVENTS */
            case ARCOMMANDS_ID_SKYCONTROLLER_CLASS_FACTORY:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_SKYCONTROLLER_FACTORY_CMD_RESET:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Factory.Reset:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_SKYCONTROLLER_FACTORY_CMD_RESET */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.Factory.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_SKYCONTROLLER_CLASS_FACTORY */
            default:
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("SkyController.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_SKYCONTROLLER */
        case ARCOMMANDS_ID_FEATURE_UNKNOWN_FEATURE_1:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_GEOGRAPHIC_RUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.geographic_run:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | start -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | elevation_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | elevation -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | azimuth_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | azimuth -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_GEOGRAPHIC_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_RELATIVE_RUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.relative_run:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | start -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | elevation_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | elevation -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | azimuth_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | azimuth -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_RELATIVE_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_LOOK_AT_RUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.look_at_run:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | start -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_LOOK_AT_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SPIRAL_ANIM_RUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.spiral_anim_run:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | start -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | speed_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | revolution_nb_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | revolution_number -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | vertical_distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | vertical_distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SPIRAL_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SWING_ANIM_RUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.swing_anim_run:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | start -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | speed_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | vertical_distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | vertical_distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SWING_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_BOOMERANG_ANIM_RUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.boomerang_anim_run:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | start -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | speed_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_BOOMERANG_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_CANDLE_ANIM_RUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.candle_anim_run:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | start -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | speed_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | vertical_distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | vertical_distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_CANDLE_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_DOLLY_SLIDE_ANIM_RUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.dolly_slide_anim_run:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | start -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | speed_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | angle_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | angle -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | horizontal_distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | horizontal_distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_DOLLY_SLIDE_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_FRAMING_POSITION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.user_framing_position:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | horizontal -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | vertical -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_FRAMING_POSITION */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_GPS_DATA:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.user_GPS_data:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | horizontal_accuracy -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | vertical_accuracy -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | north_speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | east_speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | down_speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | timestamp -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_GPS_DATA */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_BARO_DATA:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.user_baro_data:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | pressure -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | timestamp -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_BARO_DATA */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_LYNX_DETECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.lynx_detection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | target_pan -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | target_tilt -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | change_of_scale -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | confidence_index -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | is_new_selection -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint64_t arg = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU64 (" | timestamp -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_LYNX_DETECTION */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_AVAILABILITY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.availability:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_UNKNOWN_FEATURE_1_TYPES_AVAILABLE arg = (eARCOMMANDS_UNKNOWN_FEATURE_1_TYPES_AVAILABLE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_UNKNOWN_FEATURE_1_TYPES_AVAILABLE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_AVAILABILITY */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_RUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.run:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_UNKNOWN_FEATURE_1_TYPE arg = (eARCOMMANDS_UNKNOWN_FEATURE_1_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_UNKNOWN_FEATURE_1_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_GEOGRAPHIC_CONFIG_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.geographic_config_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | elevation_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | elevation -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | azimuth_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | azimuth -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_GEOGRAPHIC_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_RELATIVE_CONFIG_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.relative_config_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | elevation_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | elevation -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | azimuth_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | azimuth -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_RELATIVE_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_ANIM_RUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.anim_run:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_UNKNOWN_FEATURE_1_ANIM_TYPE arg = (eARCOMMANDS_UNKNOWN_FEATURE_1_ANIM_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_UNKNOWN_FEATURE_1_ANIM_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SPIRAL_ANIM_CONFIG_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.spiral_anim_config_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | speed_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | revolution_nb_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | revolution_nb -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | vertical_distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | vertical_distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SPIRAL_ANIM_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SWING_ANIM_CONFIG_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.swing_anim_config_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | speed_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | vertical_distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | vertical_distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SWING_ANIM_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_BOOMERANG_ANIM_CONFIG_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.boomerang_anim_config_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | speed_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_BOOMERANG_ANIM_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_CANDLE_ANIM_CONFIG_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.candle_anim_config_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | speed_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | vertical_distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | vertical_distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_CANDLE_ANIM_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_DOLLY_SLIDE_ANIM_CONFIG_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.dolly_slide_anim_config_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | speed_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | angle_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | angle -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | horizontal_distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | horizontal_distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_DOLLY_SLIDE_ANIM_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_FRAMING_POSITION_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.user_framing_position_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | horizontal -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | vertical -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_FRAMING_POSITION_CHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_UNKNOWN_FEATURE_1 */
        case ARCOMMANDS_ID_FEATURE_WIFI:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_WIFI_CMD_SCAN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.scan:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_SCAN */
                case ARCOMMANDS_ID_WIFI_CMD_UPDATE_AUTHORIZED_CHANNELS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.update_authorized_channels:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_UPDATE_AUTHORIZED_CHANNELS */
                case ARCOMMANDS_ID_WIFI_CMD_SET_AP_CHANNEL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.set_ap_channel:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_SELECTION_TYPE arg = (eARCOMMANDS_WIFI_SELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_SELECTION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_BAND arg = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_SET_AP_CHANNEL */
                case ARCOMMANDS_ID_WIFI_CMD_SET_SECURITY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.set_security:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_SECURITY_TYPE arg = (eARCOMMANDS_WIFI_SECURITY_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_SECURITY_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | key -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_SECURITY_KEY_TYPE arg = (eARCOMMANDS_WIFI_SECURITY_KEY_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_SECURITY_KEY_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | key_type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_SET_SECURITY */
                case ARCOMMANDS_ID_WIFI_CMD_SET_COUNTRY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.set_country:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_COUNTRY_SELECTION arg = (eARCOMMANDS_WIFI_COUNTRY_SELECTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_COUNTRY_SELECTION)ARCOMMANDS_ReadWrite_PrintI32 (" | selection_mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | code -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_SET_COUNTRY */
                case ARCOMMANDS_ID_WIFI_CMD_SET_ENVIRONMENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.set_environment:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_ENVIRONMENT arg = (eARCOMMANDS_WIFI_ENVIRONMENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_ENVIRONMENT)ARCOMMANDS_ReadWrite_PrintI32 (" | environment -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_SET_ENVIRONMENT */
                case ARCOMMANDS_ID_WIFI_CMD_SCANNED_ITEM:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.scanned_item:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | ssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int16_t arg =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI16 (" | rssi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_BAND arg = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | list_flags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_SCANNED_ITEM */
                case ARCOMMANDS_ID_WIFI_CMD_AUTHORIZED_CHANNEL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.authorized_channel:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_BAND arg = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | environment -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | list_flags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_AUTHORIZED_CHANNEL */
                case ARCOMMANDS_ID_WIFI_CMD_AP_CHANNEL_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.ap_channel_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_SELECTION_TYPE arg = (eARCOMMANDS_WIFI_SELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_SELECTION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_BAND arg = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_AP_CHANNEL_CHANGED */
                case ARCOMMANDS_ID_WIFI_CMD_SECURITY_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.security_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | key -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_SECURITY_TYPE arg = (eARCOMMANDS_WIFI_SECURITY_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_SECURITY_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | key_type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_SECURITY_CHANGED */
                case ARCOMMANDS_ID_WIFI_CMD_COUNTRY_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.country_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_COUNTRY_SELECTION arg = (eARCOMMANDS_WIFI_COUNTRY_SELECTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_COUNTRY_SELECTION)ARCOMMANDS_ReadWrite_PrintI32 (" | selection_mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | code -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_COUNTRY_CHANGED */
                case ARCOMMANDS_ID_WIFI_CMD_ENVIRONMENT_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.environment_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_ENVIRONMENT arg = (eARCOMMANDS_WIFI_ENVIRONMENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_ENVIRONMENT)ARCOMMANDS_ReadWrite_PrintI32 (" | environment -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_ENVIRONMENT_CHANGED */
                case ARCOMMANDS_ID_WIFI_CMD_RSSI_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.rssi_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int16_t arg =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI16 (" | rssi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_RSSI_CHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_WIFI */
        default:
            strOffset = ARCOMMANDS_ReadWrite_WriteString ("UNKNOWN -> Unknown command", resString, stringLen, strOffset);
            retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
            break;
        }
    } // No else --> Processing block
    return retVal;
}

// END GENERATED CODE
